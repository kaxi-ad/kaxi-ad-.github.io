<!DOCTYPE html>


<html lang="zh-CN">
  

    <head>
      <meta charset="utf-8" />
        
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title>Redis |  卡西莫多的小站</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/favicon.ico" />
       
<link rel="stylesheet" href="/dist/main.css">

      
<link rel="stylesheet" href="/css/fonts/remixicon.css">

      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.staticfile.org/pace/1.2.4/pace.min.js"></script>
       
 

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    </head>
  </html>
</html>


<body>
  <div id="app">
    
      
    <main class="content on">
      <section class="outer">
  <article
  id="post-Redis"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h1 class="article-title sea-center" style="border-left:0" itemprop="name">
  Redis
</h1>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/09/02/Redis/" class="article-date">
  <time datetime="2022-09-02T03:20:25.000Z" itemprop="datePublished">2022-09-02</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a>
  </div>
  
<div class="word_count">
    <span class="post-time">
        <span class="post-meta-item-icon">
            <i class="ri-quill-pen-line"></i>
            <span class="post-meta-item-text"> 字数统计:</span>
            <span class="post-count">11.8k</span>
        </span>
    </span>

    <span class="post-time">
        &nbsp; | &nbsp;
        <span class="post-meta-item-icon">
            <i class="ri-book-open-line"></i>
            <span class="post-meta-item-text"> 阅读时长≈</span>
            <span class="post-count">48 分钟</span>
        </span>
    </span>
</div>
 
    </div>
      
    <div class="tocbot"></div>




  
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><h2 id="一、缓存原理"><a href="#一、缓存原理" class="headerlink" title="一、缓存原理"></a>一、缓存原理</h2><h3 id="1、缓存的思想"><a href="#1、缓存的思想" class="headerlink" title="1、缓存的思想"></a>1、缓存的思想</h3><h4 id="什么是缓存？"><a href="#什么是缓存？" class="headerlink" title="什么是缓存？"></a><strong>什么是缓存？</strong></h4><p><strong><u>空间换时间</u></strong></p>
<p>原指CPU上一种高速存储器CACHE，它先于内存与cpu交换数据，速度很快</p>
<p>存在内存中的原始数据复制集</p>
<h4 id="计算机系统缓存设计"><a href="#计算机系统缓存设计" class="headerlink" title="计算机系统缓存设计"></a>计算机系统缓存设计</h4><p><img src="/images/Redis/1.jpg" alt="计算机系统"></p>
<p><strong>高速的CPU被慢速的磁盘拖累了</strong>：如果每次ns级别的cpu要去ms级别的硬盘读取</p>
<p>计算机系统中默认两种缓存</p>
<ul>
<li>CPU里的末级缓存（LLC），缓存内存中数据，避免每次从内存存取数据。</li>
<li>内存中的高速页缓存（page cache），用来缓存磁盘中数据，避免每次从磁盘中存取数据。</li>
</ul>
<p><img src="/images/Redis/2.jpg" alt="计算机缓存"></p>
<p>缓存的两个特征：</p>
<ul>
<li>在一个层级化的系统中，缓存一定是一个快速子系统，数据存在缓存中，避免每次从慢速子系统中存取数据。</li>
<li>缓存系统的容量大小总是小于后端慢速系统的。</li>
</ul>
<h4 id="缓存的优势、代价"><a href="#缓存的优势、代价" class="headerlink" title="缓存的优势、代价"></a>缓存的优势、代价</h4><p>优势：</p>
<ul>
<li><p>提升用户体验</p>
</li>
<li><p>减轻服务器压力</p>
</li>
<li><p>提升系统性能</p>
<p>系统性能指标：相应时间、延迟时间、吞吐量、并发用户数和资源利用率等。</p>
</li>
</ul>
<p>代价：</p>
<ul>
<li><p>额外的硬件支出</p>
</li>
<li><p>高并发缓存失效</p>
<p>高并发场景下会出现缓存失效（缓存穿透、缓存雪崩、缓存击穿）</p>
<p>造成瞬间数据库访问量增大，甚至崩溃</p>
</li>
<li><p>缓存与数据库数据同步</p>
<p>缓存与数据库无法做的数据时时同步</p>
</li>
<li><p>缓存并发竞争</p>
<p>多个redis客户端同时对一个key进行set值的时候由于执行顺序引起的并发问题（更新丢失）</p>
</li>
</ul>
<h3 id="2、缓存的使用场景"><a href="#2、缓存的使用场景" class="headerlink" title="2、缓存的使用场景"></a>2、缓存的使用场景</h3><ul>
<li><p>DB缓存，减轻DB服务器压力</p>
<ul>
<li>读写分离，分库分表</li>
<li>提高系统响应，数据存在redis中</li>
</ul>
</li>
<li><p>做Session分离</p>
<p>传统的session由tomcat自己进行维护，集群或分布式环境，不同的tomcat管理各自的session。</p>
<p>可以使用redis临时保存session，多个服务器共享session信息</p>
</li>
</ul>
<h3 id="3、缓存的分类"><a href="#3、缓存的分类" class="headerlink" title="3、缓存的分类"></a>3、缓存的分类</h3><p><img src="/images/Redis/3.jpg" alt="缓存分类"></p>
<h4 id="客户端缓存"><a href="#客户端缓存" class="headerlink" title="客户端缓存"></a>客户端缓存</h4><p>传统互联网：页面缓存和浏览器缓存</p>
<p>移动互联网：APP缓存</p>
<h4 id="服务端缓存"><a href="#服务端缓存" class="headerlink" title="服务端缓存"></a>服务端缓存</h4><h5 id="（1）数据库级缓存"><a href="#（1）数据库级缓存" class="headerlink" title="（1）数据库级缓存"></a>（1）数据库级缓存</h5><p>MySQL在Server层使用查询缓存机制。将查询后的数据缓存起来。K-V结构，Key：select语句的hash值，Value：查询结果</p>
<p>InnoDB存储引擎中的buffer-pool用于缓存InnoDB索引及数据块。</p>
<h5 id="（2）本地缓存"><a href="#（2）本地缓存" class="headerlink" title="（2）本地缓存"></a>（2）本地缓存</h5><p>平台级缓存指的是带有缓存特性的应用框架。</p>
<p>比如：Caffeine、GuavaCache、OSCache（页面缓存）等。部署在应用服务器上，也成为服务器本地缓存。</p>
<h5 id="（3）应用级缓存（重点）"><a href="#（3）应用级缓存（重点）" class="headerlink" title="（3）应用级缓存（重点）"></a>（3）应用级缓存（重点）</h5><p>具有缓存功能的中间件：Redis、Memcached、EVCache（AWS）、Tair（阿里、美团）等。采用K-V形式存储。</p>
<p>利用集群支持高可用、高性能、高并发、高扩展。</p>
<p>分布式缓存</p>
<h4 id="网络缓存"><a href="#网络缓存" class="headerlink" title="网络缓存"></a>网络缓存</h4><p><strong>边缘缓存</strong></p>
<p>CDN（Content Delivery Network），内容分发网络</p>
<blockquote>
<p>核心原则是”就近访问“，用户上网时不直接访问源站，而是访问离他最近的一个CDN节点，术语叫”边缘节点“（edge node），其实就是缓存了源站内容的代理服务器，省去了”长途跋涉“的时间成本，实现了”网络加速“。</p>
</blockquote>
<p>CDN的执行流程</p>
<p><img src="/images/Redis/4.jpg" alt="执行流程"></p>
<p>全局负载均衡（Global Sever Load ）</p>
<blockquote>
<p>简称GSLB，是CDN的“大脑”，主要职责是当用户接入网络的时候在CDN专网中挑选出一个“最佳”节点提供服务，解决的是用户如何找到“最近的”边缘节点，对整个CDN网络进行“负载均衡”。</p>
</blockquote>
<p>原来没有CDN的，权威DNS返回的是网站自己服务器的实际IP地址，浏览器收到DNS解析结果后直连网站。</p>
<p>加入CDN后，权威DNS返回的不是IP地址，而是一个CNAME（Canonical Name）别名记录，指向的就是CDN的GSLB。</p>
<p>因为没拿到IP地址，于是本地DNS就会像GSLB再发起请求，就进入了CDN的全局负载均衡系统，开始“智能调度”，主要依据有：</p>
<ul>
<li>看用户的IP地址，查表得知地理位置，找相对最近的边缘节点；</li>
<li>看用户所在的运营商网络，找相同网络的边缘节点；</li>
<li>检查边缘节点的负载情况，找负载较轻的节点</li>
<li>其他，比如节点的“健康状况”、服务能力、带宽、响应时间等。</li>
</ul>
<p>CDN关键概念：“命中”和“回源”</p>
<p>好的CDN应该是命中率越高越好，回源率越低越好</p>
<p>CDN的使用场景：</p>
<ul>
<li>手机游戏包</li>
<li>广告的图片素材</li>
<li>静态字段（js css）</li>
</ul>
<p>CDN的优化：</p>
<ul>
<li><p>缓存预热</p>
<p>提前把资源推送到边缘节点，避免用户访问的时候回源</p>
</li>
<li><p>使用高性能服务器</p>
</li>
</ul>
<h3 id="4、缓存的读写模式"><a href="#4、缓存的读写模式" class="headerlink" title="4、缓存的读写模式"></a>4、缓存的读写模式</h3><p>旁路缓存：客户端访问缓存系统，访问失败后客户端再访问慢速数据库。最终还需要客户端更新缓存。</p>
<p>非旁路缓存：客户端访问缓存系统，访问失败后由缓存系统访问慢速数据库，由缓存系统更新缓存。</p>
<h4 id="缓存三种读写模式"><a href="#缓存三种读写模式" class="headerlink" title="缓存三种读写模式"></a><strong>缓存三种读写模式</strong></h4><h5 id="Cache-Aside-Pattern-常用"><a href="#Cache-Aside-Pattern-常用" class="headerlink" title="Cache Aside Pattern(常用)"></a><strong>Cache Aside Pattern(常用)</strong></h5><p>Cache Aside Pattern（旁路缓存），是最经典的缓存+数据库读写模式。</p>
<p>读的时候先读缓存，缓存没有，就读数据库，然后取出数据后放入缓存，同时返回响应。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">cacheKey</span> <span class="operator">=</span> “productid_11010003”;</span><br><span class="line"><span class="type">String</span> <span class="variable">cacheValue</span> <span class="operator">=</span> redisCache.get(cacheKey)；</span><br><span class="line"><span class="comment">//缓存命中</span></span><br><span class="line"><span class="keyword">if</span> ( cacheValue != NULL)</span><br><span class="line">	<span class="keyword">return</span> cacheValue;</span><br><span class="line"><span class="comment">//缓存缺失</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    cacheValue = getProductFromDB();</span><br><span class="line">    redisCache.put(cacheValue) <span class="comment">//缓存更新</span></span><br></pre></td></tr></table></figure>

<p>更新时，先更新数据库，再删除缓存</p>
<p>为什么是删除缓存，而不是更新缓存呢？</p>
<ul>
<li>缓存的值是一个结构：hash、list，更新数据需要遍历 先遍历（耗时）后修改</li>
<li>懒加载，使用的时候才更新缓存</li>
</ul>
<p>使用的时候才从DB中加载</p>
<p>也可以采用异步的方式填充缓存</p>
<p>开启一个线程　定时将DB的数据刷到缓存中</p>
<p><strong>高并发脏读的三种情况</strong></p>
<p>１、先更新数据库，再更新缓存</p>
<p>update与commit之间，更新缓存，提交失败，进行rollback</p>
<p>Redis是回滚前的脏值，数据库是回滚后的旧值，则DB与缓存数据不一致</p>
<p>２、先删除缓存，再更新数据库</p>
<p>update与commit之间，有新的读，缓存空，读DB数据到缓存，数据是旧的数据（快照）</p>
<p>commit后，DB为新数据</p>
<p>则DB与缓存数据不一致</p>
<p>３、先更新数据库，再删除缓存（推荐）</p>
<p>问题和２一样，但是redis的操作比MySQL快，所以出现问题的概率比先删缓存再更新数据库小</p>
<p>根本原因：Redis和Mysql不在同一个“事务”里，导致没有正确删除掉redis的旧值</p>
<p>最终一致性解决方案：延时双删策略</p>
<p>保证数据的最终一致性（延时双删）</p>
<p>１、先更新数据库同时删除缓存项（key），等读的时候再填充缓存</p>
<p>2、2秒后再删除一次缓存项（key）</p>
<p>3、设置缓存过期时间ttl超时删除key 比如10秒 或1小时</p>
<p>4、通过数据库的binlog来异步淘汰key，利用工具（cancal）将binlog日志采集发送到MQ中，然后通过ACK机制确认处理删除缓存</p>
<h5 id="Read-x2F-Write-Through-Pattern"><a href="#Read-x2F-Write-Through-Pattern" class="headerlink" title="Read&#x2F;Write Through Pattern"></a>Read&#x2F;Write Through Pattern</h5><p>应用程序只操作缓存，缓存操作数据库</p>
<p>Read-Through（穿透读模式&#x2F;直读模式）：应用程序读缓存，缓存没有，由源存回源到数据库，并写入缓存（guavacache）</p>
<p>Write-Through（穿透写模式&#x2F;直写模式）：应用程序写缓存，缓存写数据库。</p>
<p>该种模式需要提供数据库的handler，开发较为复杂</p>
<h5 id="Write-Behind-Caching-Pattern"><a href="#Write-Behind-Caching-Pattern" class="headerlink" title="Write Behind Caching Pattern"></a>Write Behind Caching Pattern</h5><p>应用程序只更新缓存。</p>
<p>缓存通过异步的方式将数据批量或合并后更新到DB中</p>
<p>不能实时同步，甚至会丢数据</p>
<h2 id="二、Redis基本功能"><a href="#二、Redis基本功能" class="headerlink" title="二、Redis基本功能"></a>二、Redis基本功能</h2><blockquote>
<p>Redis（Remote Dictinonary Server）远程字典服务器，是用C语言开发的一个开源的高性能键值对（key-value）内存数据库。</p>
</blockquote>
<p>Redis应用场景</p>
<ul>
<li>缓存使用，减轻DB压力</li>
<li>DB使用，用于临时存储数据（字典表，购买记录）</li>
<li>解决分布式场景下Session分离问题（登录信息）</li>
<li>任务队列（秒杀、抢红包等等）乐观锁</li>
<li>应用排行榜 zset</li>
<li>签到bitmap</li>
<li>分布式锁</li>
<li>冷热数据交换</li>
</ul>
<h3 id="1、安装"><a href="#1、安装" class="headerlink" title="1、安装"></a>1、安装</h3><p><a target="_blank" rel="noopener" href="https://redis.io/docs/getting-started/installation/install-redis-on-windows/">https://redis.io/docs/getting-started/installation/install-redis-on-windows/</a></p>
<h3 id="2、使用"><a href="#2、使用" class="headerlink" title="2、使用"></a>2、使用</h3><h4 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h4><p>命令行：redis-cli</p>
<p>java client:Jedis，Spring-Data-Redis</p>
<h3 id="3、数据类型"><a href="#3、数据类型" class="headerlink" title="3、数据类型"></a>3、数据类型</h3><p>Redis是一个Key-Value的存储系统，使用ANSI C语言编写</p>
<p>key的类型是字符串。</p>
<p>value的数据类型有：</p>
<p>常用的：string字符串类型，list列表类型、set集合类型、sortedset（zset）有序集合类型、bash类型。</p>
<p>不常见的：HyberLogLog类型、bitmap位图类型、geo地理位置类型</p>
<p>Redis5.0新增一种：stream类型</p>
<p>注：Redis中命令是忽略大小写，(set SET)，key是不忽略大小写的（NAME name）</p>
<p>底层数据结构一共有6种：简单动态字符串、双向链表、压缩列表、哈希表、跳表和整数数组</p>
<p>Redis的Key的设计</p>
<ul>
<li>用:分割</li>
<li>把表名转换为key前缀，比如：user:</li>
<li>第二段放置主键值</li>
<li>第三段放置列名</li>
</ul>
<p>比如：用户表user，转换为redis的key-value存储</p>
<p>username的key：user:9:username</p>
<p>{userid:9,username:zhangf}</p>
<p>email的key user:9:email</p>
<p>表示明确：看key知道意思</p>
<p>不易被覆盖</p>
<h4 id="string字符串类型"><a href="#string字符串类型" class="headerlink" title="string字符串类型"></a>string字符串类型</h4><p>Redis的String能表达3种值的类型：字符串、整数、浮点数100.01是个六位的串</p>
<p>常见操作命令：</p>
<table>
<thead>
<tr>
<th>命令名称</th>
<th></th>
<th>命令描述</th>
</tr>
</thead>
<tbody><tr>
<td>set</td>
<td>set key value</td>
<td>赋值</td>
</tr>
<tr>
<td>get</td>
<td>get key</td>
<td>取值</td>
</tr>
<tr>
<td>getset</td>
<td>getset key value</td>
<td>取值并赋值</td>
</tr>
<tr>
<td>setnx</td>
<td>setnx key value</td>
<td>当key不存在时才用赋值set keyvalue NX PX 3000原子操作，px设置毫秒数</td>
</tr>
<tr>
<td>append</td>
<td>append key value</td>
<td>向尾部追加值</td>
</tr>
<tr>
<td>strlen</td>
<td>strlen key</td>
<td>获取字符串长度</td>
</tr>
<tr>
<td>incr</td>
<td>incr key</td>
<td>递增数字</td>
</tr>
<tr>
<td>incrby</td>
<td>incrby key increment</td>
<td>增加指定的整数</td>
</tr>
<tr>
<td>decr</td>
<td>decr key</td>
<td>递减数字</td>
</tr>
<tr>
<td>decrby</td>
<td>decrby key decrement</td>
<td>减少指定的整数</td>
</tr>
</tbody></table>
<p>应用场景：</p>
<p>1、key和命令是字符串</p>
<p>2、普通的赋值</p>
<p>3、incr用于乐观锁</p>
<p>incr：递增数字，可用于实现乐观锁 watch（事务）</p>
<p>4、setnx用于分布式锁</p>
<p>当value不存在时采用赋值，可用于实现分布式锁</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; setnx name zhangf #如果name不存在赋值</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; setnx name zhangf #再次赋值失败</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; get name</span><br><span class="line">&quot;zhangf&quot;</span><br></pre></td></tr></table></figure>

<p>set</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; <span class="built_in">set</span> age <span class="number">18</span> NX PX <span class="number">10000</span> <span class="comment">#如果不存在赋值 有效期10秒</span></span><br><span class="line">OK</span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; <span class="built_in">set</span> age <span class="number">20</span> NX <span class="comment">#赋值失败</span></span><br><span class="line">(nil)</span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; get age <span class="comment">#age失效</span></span><br><span class="line">(nil)</span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; <span class="built_in">set</span> age <span class="number">30</span> NX PX <span class="number">10000</span> <span class="comment">#赋值成功</span></span><br><span class="line">OK</span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; get age</span><br><span class="line"><span class="string">&quot;30&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="list列表类型"><a href="#list列表类型" class="headerlink" title="list列表类型"></a>list列表类型</h4><p>list列表类型可以存储有序、可重复的元素</p>
<p>获取头部或尾部附近的记录是极快的</p>
<p>list的元素个数最多为2^32-1个(40亿)</p>
<p>常见操作命令如下表：</p>
<table>
<thead>
<tr>
<th>命令名称</th>
<th>命令格式</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>lpush</td>
<td>lpush key v1v2v3…</td>
<td>从左侧插入列表</td>
</tr>
<tr>
<td>lpop</td>
<td>lpop key</td>
<td>从列表左侧取出</td>
</tr>
<tr>
<td>rpush</td>
<td>rpush key v1v2v3 …</td>
<td>从右侧插入列表</td>
</tr>
<tr>
<td>rpop</td>
<td>rpop key</td>
<td>从列表右侧取出</td>
</tr>
<tr>
<td>lpushx</td>
<td>lpushx key value</td>
<td>将值插入到列表头部</td>
</tr>
<tr>
<td>rpushx</td>
<td>rpushx key value</td>
<td>将值插入到列表尾部</td>
</tr>
<tr>
<td>blpop</td>
<td>blpop keytimeout</td>
<td>从列表左侧取出，当列表为空时阻塞，可以设置最大阻塞时间，单位为秒</td>
</tr>
<tr>
<td>brpop</td>
<td>brpop keytimeout</td>
<td>从列表右侧取出，当列表为空时阻塞，可以设置最大阻塞时间，单位为秒</td>
</tr>
<tr>
<td>llen</td>
<td>llen key</td>
<td>获得列表中元素个数</td>
</tr>
<tr>
<td>lindex</td>
<td>lindex keyindex</td>
<td>获得列表中下标为index的元素，index从0开始</td>
</tr>
<tr>
<td>lrange</td>
<td>lrange keystart end</td>
<td>返回列表中指定区间的元素，区间通过start和end指定</td>
</tr>
<tr>
<td>lrem</td>
<td>lrem key count value</td>
<td>删除列表中与value相等的元素当count&gt;0时，lren会从列表左边开始删除；当count&lt;0时，lrem会从列表后边开始删除；当count&#x3D;0时，lrem删除所有值为value的元素</td>
</tr>
<tr>
<td>lset</td>
<td>lset key index value</td>
<td>将列表index位置的元素设置成value的值</td>
</tr>
<tr>
<td>ltrim</td>
<td>ltrim key start end</td>
<td>对列表进行修剪，只保留start到end区间</td>
</tr>
<tr>
<td>rpoplpush</td>
<td>rpoplpush key 1 key2</td>
<td>从key1列表右侧弹出并插入到key2列表左侧</td>
</tr>
<tr>
<td>brpoplpush</td>
<td>brpoplpush key1 key2</td>
<td>从key1列表右侧弹出并插入到key2列表左侧，会阻塞</td>
</tr>
<tr>
<td>linsert</td>
<td>linsert keyBEFORE&#x2F;AFTER pivot value</td>
<td>将value插入到列表，且位于值pivot之前或之后</td>
</tr>
</tbody></table>
<p>应用场景：</p>
<p>1、作为栈或队列使用</p>
<p>列表有序可以作为栈和队列使用</p>
<p>2、可用于各种列表，比如用户列表、商品列表、评论列表等</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; lpush list:<span class="number">1</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">3</span> <span class="comment">#左侧插入</span></span><br><span class="line">(integer) <span class="number">6</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; lrange list:<span class="number">1</span> <span class="number">0</span> <span class="literal">-1</span> <span class="comment">#返回列表中指定区间元素</span></span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;3&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;5&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;4&quot;</span></span><br><span class="line"><span class="number">4</span>) <span class="string">&quot;3&quot;</span></span><br><span class="line"><span class="number">5</span>) <span class="string">&quot;2&quot;</span></span><br><span class="line"><span class="number">6</span>) <span class="string">&quot;1&quot;</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; lpop list:<span class="number">1</span> <span class="comment">#列表左侧取出</span></span><br><span class="line"><span class="string">&quot;3&quot;</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; rpop list:<span class="number">1</span>	<span class="comment">#列表右侧取出</span></span><br><span class="line"><span class="string">&quot;1&quot;</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; lindex list:<span class="number">1</span> <span class="number">1</span> <span class="comment">#获得列表中下标为1的元素</span></span><br><span class="line"><span class="string">&quot;4&quot;</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; lrange list:<span class="number">1</span> <span class="number">0</span> <span class="literal">-1</span></span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;5&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;4&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;3&quot;</span></span><br><span class="line"><span class="number">4</span>) <span class="string">&quot;2&quot;</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; lindex list:<span class="number">1</span> <span class="number">1</span></span><br><span class="line"><span class="string">&quot;4&quot;</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; rpoplpush list:<span class="number">1</span> list:<span class="number">2</span> <span class="comment">#从key1列表右侧弹出并插入到key2列表左侧</span></span><br><span class="line"><span class="string">&quot;2&quot;</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; lrange list:<span class="number">2</span> <span class="number">0</span> <span class="literal">-1</span></span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;2&quot;</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; lrange list:<span class="number">1</span> <span class="number">0</span> <span class="literal">-1</span></span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;5&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;4&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;3&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="set集合"><a href="#set集合" class="headerlink" title="set集合"></a>set集合</h4><p>Set：无序、唯一元素</p>
<p>集合中最大的成员数为2^32-1</p>
<p>常见操作命令如下表：</p>
<table>
<thead>
<tr>
<th>命令名称</th>
<th>命令格式</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>sadd</td>
<td>sadd key mem1 mem2 …</td>
<td>为集合添加新成员</td>
</tr>
<tr>
<td>srem</td>
<td>srem key mem1 mem2 …</td>
<td>删除集合中指定成员</td>
</tr>
<tr>
<td>smembers</td>
<td>smembers key</td>
<td>获得集合中所有元素</td>
</tr>
<tr>
<td>spop</td>
<td>spop key</td>
<td>返回集合中一个随即元素，并将该元素删除</td>
</tr>
<tr>
<td>srandmember</td>
<td>srandmember key</td>
<td>返回集合中一个随机元素，不会删除该元素</td>
</tr>
<tr>
<td>scard</td>
<td>scard key</td>
<td>获得集合中元素的数量</td>
</tr>
<tr>
<td>sismember</td>
<td>sismember key member</td>
<td>判断元素是否在集合内</td>
</tr>
<tr>
<td>sinter</td>
<td>sinter key1 key2 key3</td>
<td>求多集合的交集</td>
</tr>
<tr>
<td>sdiff</td>
<td>sdiff key1 key2 key3</td>
<td>求多集合的差集</td>
</tr>
<tr>
<td>sunion</td>
<td>sunion key1 key2 key3</td>
<td>求多集合的并集</td>
</tr>
</tbody></table>
<p>应用场景：</p>
<p>适用于不能重复的且不需要顺序的数据结构</p>
<p>比如：关注的用户，还可以通过spop进行随机抽奖</p>
<p>举例：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; sadd <span class="built_in">set</span>:<span class="number">1</span> a b c d <span class="comment">#为集合添加新成员</span></span><br><span class="line">(integer) <span class="number">0</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; smembers <span class="built_in">set</span>:<span class="number">1</span> <span class="comment">#获得集合中所有元素</span></span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;d&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;b&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;a&quot;</span></span><br><span class="line"><span class="number">4</span>) <span class="string">&quot;c&quot;</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; srandmember <span class="built_in">set</span>:<span class="number">1</span> <span class="comment">#返回集合中一个随机元素,不删除</span></span><br><span class="line"><span class="string">&quot;c&quot;</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; srandmember <span class="built_in">set</span>:<span class="number">1</span></span><br><span class="line"><span class="string">&quot;c&quot;</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; sadd <span class="built_in">set</span>:<span class="number">2</span> b c <span class="built_in">r</span> f</span><br><span class="line">(integer) <span class="number">4</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; sinter <span class="built_in">set</span>:<span class="number">1</span> <span class="built_in">set</span>:<span class="number">2</span> <span class="comment">#交集</span></span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;c&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;b&quot;</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; spop <span class="built_in">set</span>:<span class="number">1</span></span><br><span class="line"><span class="string">&quot;b&quot;</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; smembers <span class="built_in">set</span>:<span class="number">1</span></span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;d&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;a&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;c&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="sortedset有序集合类型"><a href="#sortedset有序集合类型" class="headerlink" title="sortedset有序集合类型"></a>sortedset有序集合类型</h4><p>SortedSet（ZSet）有序集合:元素本身是无序不重复的</p>
<p>每个元素关联一个分数（score）</p>
<p>可按分数排序，分数可重复</p>
<p>常见操作命令如下表：</p>
<table>
<thead>
<tr>
<th>命令名称</th>
<th>命令格式</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>zadd</td>
<td>zadd key score1 member1 score2member2 …</td>
<td>为有序集合添加新成员</td>
</tr>
<tr>
<td>zrem</td>
<td>zrem key mem1 mem2 …</td>
<td>删除有序集合中指定成员</td>
</tr>
<tr>
<td>zcard</td>
<td>zcard key</td>
<td>获取有序集合中的元素数量</td>
</tr>
<tr>
<td>zcount</td>
<td>zcount key min max</td>
<td>返回集合中score值再[min,max]区间的元素数量</td>
</tr>
<tr>
<td>zincrby</td>
<td>zincrby key increment member</td>
<td>在集合的member分值上加increment</td>
</tr>
<tr>
<td>zscore</td>
<td>zscore key member</td>
<td>获得集合中member的分值</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>命令名称</th>
<th>命令格式</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>zrank</td>
<td>zrank key member</td>
<td>获得集合中member的排名（按分值从小到大）</td>
</tr>
<tr>
<td>zrevrank</td>
<td>zrevrank key member</td>
<td>获得集合中member的排名（按分值从大到小）</td>
</tr>
<tr>
<td>zrange</td>
<td>zrange key start end</td>
<td>获得集合中指定区间成员，按分数递增排序</td>
</tr>
<tr>
<td>zrevrange</td>
<td>zrevrange key start end</td>
<td>获得集合中指定区间成员，按分数递减排序</td>
</tr>
</tbody></table>
<p>应用场景：</p>
<p>由于可以按照分值排序，所以适用于各种排行榜。比如：点击排行榜、销量排行榜、关注排行榜等。举例：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zadd hit:1 100 item1 20 item2 45 item3</span><br><span class="line">(integer) 3</span><br><span class="line">127.0.0.1:6379&gt; zcard hit:1</span><br><span class="line">(integer) 3</span><br><span class="line">127.0.0.1:6379&gt; zscore hit:1 item3</span><br><span class="line">&quot;45&quot;</span><br><span class="line">127.0.0.1:6379&gt; zrevrange hit:1 0 -1</span><br><span class="line">1) &quot;item1&quot;</span><br><span class="line">2) &quot;item3&quot;</span><br><span class="line">3) &quot;item2&quot;</span><br></pre></td></tr></table></figure>

<h4 id="hash类型（散列表）"><a href="#hash类型（散列表）" class="headerlink" title="hash类型（散列表）"></a>hash类型（散列表）</h4><p>Redis hash 是一个string类型的field和value的映射表，它提供了字段和字段值的映射。</p>
<p>每个hash可以存储2^32-1键值对（40多亿）</p>
<p><img src="/images/Redis/5.jpg" alt="hash"></p>
<p>常见操作命令：</p>
<table>
<thead>
<tr>
<th>命令名称</th>
<th>命令格式</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>hset</td>
<td>hset key field value</td>
<td>赋值，不区别新增或修改</td>
</tr>
<tr>
<td>hmset</td>
<td>hmset key field1 value1 field2 value2</td>
<td>批量赋值</td>
</tr>
<tr>
<td>hsetnx</td>
<td>hsetnx key field value</td>
<td>赋值，如果filed存在则不操作</td>
</tr>
<tr>
<td>hexists</td>
<td>hexists key filed</td>
<td>查看某个field是否存在</td>
</tr>
<tr>
<td>hget</td>
<td>hget key field</td>
<td>឴获取一个字段值</td>
</tr>
<tr>
<td>hmget</td>
<td>hmget key field1 field2 …</td>
<td>获取多个字段值</td>
</tr>
<tr>
<td>hgetall</td>
<td>hgetall key</td>
<td>获取所有字段值</td>
</tr>
<tr>
<td>hdel</td>
<td>hdel key field1 field2…</td>
<td>删除指定字段</td>
</tr>
<tr>
<td>hincrby</td>
<td>hincrby key field increment</td>
<td>指定字段自增</td>
</tr>
<tr>
<td>hlen</td>
<td>hlen key</td>
<td>获得字段数量</td>
</tr>
</tbody></table>
<p>应用场景：</p>
<p>对象的存储，表数据的映射</p>
<p>举例：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hmset user:001 username zhangfei password 111 age 23 sex M	#批量复制</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; hgetall user:001	#获取所有字段值</span><br><span class="line">1) &quot;username&quot;</span><br><span class="line">2) &quot;zhangfei&quot;</span><br><span class="line">3) &quot;password&quot;</span><br><span class="line">4) &quot;111&quot;</span><br><span class="line">5) &quot;age&quot;</span><br><span class="line">6) &quot;23&quot;</span><br><span class="line">7) &quot;sex&quot;</span><br><span class="line">8) &quot;M&quot;</span><br><span class="line">127.0.0.1:6379&gt; hget user:001 username #获取id的username值</span><br><span class="line">&quot;zhangfei&quot;</span><br><span class="line">127.0.0.1:6379&gt; hincrby user:001 age 1 #指定字段自增</span><br><span class="line">(integer) 24</span><br><span class="line">127.0.0.1:6379&gt; hlen user:001	#获得字段数量</span><br><span class="line">(integer) 4</span><br></pre></td></tr></table></figure>

<h4 id="bitmap位图类型"><a href="#bitmap位图类型" class="headerlink" title="bitmap位图类型"></a>bitmap位图类型</h4><p>bitmap是进行位操作的</p>
<p>通过一个bit位来表示某个元素对应的值或者状态，其中的key就是对应元素本身。</p>
<p>bitmap本身会极大的节省储存空间。</p>
<p>常见操作命令：</p>
<table>
<thead>
<tr>
<th>命令名称</th>
<th>命令格式</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>setbit</td>
<td>setbit key offset value</td>
<td>设置key在offset处的bit值（只能是0或1）</td>
</tr>
<tr>
<td>getbit</td>
<td>getbit key offset</td>
<td>获得key在offset处的bit值</td>
</tr>
<tr>
<td>bitcount</td>
<td>bitcount key</td>
<td>获得key的bit位为1的个数</td>
</tr>
<tr>
<td>bitpos</td>
<td>bitpos key value</td>
<td>返回第一个被设置为bit值得索引值</td>
</tr>
<tr>
<td>bitop</td>
<td>bitop and[or&#x2F;xor&#x2F;not] destkey key [key …]</td>
<td>对多个key逻辑运算后存入destkey中</td>
</tr>
</tbody></table>
<p>应用场景：</p>
<ul>
<li>用户每月签到，用户id为key，日期作为偏移量 1表示签到</li>
<li>统计活跃用户，日期为key，用户id偏移量1表示活跃</li>
<li>查询用户在线状态，日期为key，用户id为偏移量 1表示在线</li>
</ul>
<p>举例：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; setbit user:sign:1000 20200101 1</span><br><span class="line">(integer) 0	#id为1000的用户20200101签到</span><br><span class="line">127.0.0.1:6379&gt; setbit user:sign:1000 20200103 1</span><br><span class="line">(integer) 0 #id为1000的用户20200103签到</span><br><span class="line">127.0.0.1:6379&gt; getbit user:sign:1000 20200101</span><br><span class="line">(integer) 1  #id为1000的用户20200101签到状态</span><br><span class="line">127.0.0.1:6379&gt; getbit user:sign:1000 20200102</span><br><span class="line">(integer) 0  #id为1000的用户20200102签到状态</span><br><span class="line">127.0.0.1:6379&gt; bitcount user:sign:1000</span><br><span class="line">(integer) 2  #获得id为1000的用户签到次数</span><br><span class="line">127.0.0.1:6379&gt; bitpos user:sign:1000 1</span><br><span class="line">(integer) 20200101	#id为1000的用户第一次签到日期</span><br><span class="line">127.0.0.1:6379&gt; setbit 20200201 1000 1</span><br><span class="line">(integer) 0	#20200201的1000号用户上线</span><br><span class="line">127.0.0.1:6379&gt; setbit 20200201 1001 1</span><br><span class="line">(integer) 0	#20200201的1001号用户上线</span><br><span class="line">127.0.0.1:6379&gt; setbit 20200201 1002 1</span><br><span class="line">(integer) 0	#20200201的1002号用户上线</span><br><span class="line">127.0.0.1:6379&gt; setbit 20200202 1000 1</span><br><span class="line">(integer) 0	#20200202的1000号用户上线</span><br><span class="line">127.0.0.1:6379&gt; bitcount 20200201</span><br><span class="line">(integer) 3	#20200201的上线用户有2个</span><br><span class="line">127.0.0.1:6379&gt; bitop or desk1 20200201 20200202</span><br><span class="line">(integer) 126	#合并20200201的用户和20200202上线</span><br><span class="line">127.0.0.1:6379&gt; bitcount desk1</span><br><span class="line">(integer) 3	#统计20200201和20200202都上线的用户个数</span><br></pre></td></tr></table></figure>

<h4 id="geo地理位置类型"><a href="#geo地理位置类型" class="headerlink" title="geo地理位置类型"></a>geo地理位置类型</h4><p>geo是Redis用来处理位置信息的。Redis3.2中正式使用，利用Z阶曲线、Base32编码和geohash算法</p>
<p><strong>GeoHash算法</strong></p>
<p>为了能高效地对经纬度进行比较，Redis采用了业界广泛使用地GeoHash编码方法。</p>
<table>
<thead>
<tr>
<th>命令方式</th>
<th>命令格式</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>geoadd</td>
<td>geoadd key 经度 纬度 成员 名称1精度1维度1成员 名称2 经度2 纬度2 …</td>
<td>添加地理坐标</td>
</tr>
<tr>
<td>geohash</td>
<td>geohash key 成员名称1 成员名称2 …</td>
<td>返回标准的geohash串</td>
</tr>
<tr>
<td>geopos</td>
<td>geopos key 成员名称1 成员名称2</td>
<td>返回成员经纬度</td>
</tr>
<tr>
<td>geodist</td>
<td>geodist key 成员1 成员2 单位</td>
<td>计算成员间经纬度</td>
</tr>
<tr>
<td>georadiusbymember</td>
<td>georadiusbymember key 成员 值单位 count 数 asc[desc]</td>
<td>根据成员查找附近的成员</td>
</tr>
</tbody></table>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">192.168.200.132:0&gt;geoadd user:addr 116.31 40.05 zhangf 116.38 39.88 zhaoyun 116.47 40.00 diaochan #添加用户地址 zhangf、zhaoyun、diaochan的经纬度</span><br><span class="line">&quot;3&quot;</span><br><span class="line">192.168.200.132:0&gt;geohash user:addr zhangf diaochan #获得zhangf和diaochan的geohash</span><br><span class="line"> 1)  &quot;wx4eydyk5m0&quot;</span><br><span class="line"> 2)  &quot;wx4gd3fbgs0&quot;</span><br><span class="line">192.168.200.132:0&gt;geopos user:addr zhaoyun #获得zhaoyun的经纬度</span><br><span class="line"> 1)    1)   &quot;116.38000041246414185&quot;</span><br><span class="line">  2)   &quot;39.88000114172373145&quot;</span><br><span class="line"></span><br><span class="line">192.168.200.132:0&gt;geodist user:addr zhangf diaochan #计算zhangfei到diaochan的距离，单位m</span><br><span class="line">&quot;14718.6972&quot;</span><br><span class="line">192.168.200.132:0&gt;geodist user:addr zhangf diaochan km #计算zhangf到diaochan的距离，单位是km</span><br><span class="line">&quot;14.7187&quot;</span><br><span class="line">192.168.200.132:0&gt;geodist user:addr zhangf zhaoyun km</span><br><span class="line">&quot;19.8276&quot;</span><br><span class="line">192.168.200.132:0&gt;georadiusbymember user:addr zhangf 20 km withcoord withdist count 3 asc</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">获得距离zhangf20km以内的按由近到远的顺序排除前三名的成员名称、距离及经纬度</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">withcoord：获得经纬度withdist：获得距离withhash：获得geohash码</span></span><br><span class="line"> 1)    1)   &quot;zhangf&quot;</span><br><span class="line">  2)   &quot;0.0000&quot;</span><br><span class="line">  3)      1)    &quot;116.31000012159347534&quot;</span><br><span class="line">   2)    &quot;40.04999982043828055&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> 2)    1)   &quot;diaochan&quot;</span><br><span class="line">  2)   &quot;14.7187&quot;</span><br><span class="line">  3)      1)    &quot;116.46999925374984741&quot;</span><br><span class="line">   2)    &quot;39.99999991084916218&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> 3)    1)   &quot;zhaoyun&quot;</span><br><span class="line">  2)   &quot;19.8276&quot;</span><br><span class="line">  3)      1)    &quot;116.38000041246414185&quot;</span><br><span class="line">   2)    &quot;39.88000114172373145&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="stream数据流类型"><a href="#stream数据流类型" class="headerlink" title="stream数据流类型"></a>stream数据流类型</h4><p>stream是Redis5.0后新增的数据结构，用于可持久化的消息队列。</p>
<p>几乎满足了消息队列具备的全部内容，包括：</p>
<ul>
<li>消息ID的序列化生成</li>
<li>消息遍历</li>
<li>消息的阻塞和非阻塞读取</li>
<li>消息的分组消费</li>
<li>未完成消息的处理</li>
<li>消息队列监控</li>
</ul>
<p>每个stream都有唯一的名称，他就是Redis的key，首次使用xadd指令追加消息时自动创建。</p>
<p>常见操作命令：</p>
<table>
<thead>
<tr>
<th>命令名称</th>
<th>命令格式</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>xadd</td>
<td>xadd key id &lt;*&gt; field1 value1….</td>
<td>将指定消息数据追加到指定队列(key)中，*表示最新生成的id(当前时间+序列号)</td>
</tr>
<tr>
<td>xread</td>
<td>xread [COUNT count] [BLOCK milliseconds] STREAMS key [key …] ID [ID …]</td>
<td>从消息队列中读取，COUNT：读取条数，BLOCK：阻塞读（默认不阻塞）key：队列 名称 id：消息id</td>
</tr>
<tr>
<td>xrange</td>
<td>xrange key start end [COUNT]</td>
<td>读取队列中给定ID范围的消息COUNT：返回消息条数（消息id从小到大）</td>
</tr>
<tr>
<td>xrevrange</td>
<td>xrevrange key start end[COUNT]</td>
<td>读取队列中给定ID范围的消息COUNT：返回消息条数（消息id从大到小）</td>
</tr>
<tr>
<td>xdel</td>
<td>xdel key id</td>
<td>删除队列的消息</td>
</tr>
<tr>
<td>xgroup</td>
<td>xgroup create key groupname id</td>
<td>创建一个新的消费组</td>
</tr>
<tr>
<td>xgroup</td>
<td>xgroup destory keygroupname</td>
<td>删除指定消费组</td>
</tr>
<tr>
<td>xgroup</td>
<td>xgroup delconsumer keygroupname cname</td>
<td>删除指定消费组中的某个消费者</td>
</tr>
<tr>
<td>xgroup</td>
<td>xgroup setid key id</td>
<td>修改指定消息的最大id</td>
</tr>
<tr>
<td>xreadgroup</td>
<td>xreadgroup group groupname consumer COUNT streams key</td>
<td>从队列中的消费组中创建消费者并消费数据（consumer不存在则创建）</td>
</tr>
</tbody></table>
<p>应用场景：</p>
<p>消息队列的使用</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; xadd topic:001 * name zhangfei age 23</span><br><span class="line">&quot;1662536946521-0&quot;</span><br><span class="line">127.0.0.1:6379&gt; xadd topic:001 * name zhaoyun age 24 name diaochan age 16</span><br><span class="line">&quot;1662536996569-0&quot;</span><br><span class="line">127.0.0.1:6379&gt; xrange topic:001 - +</span><br><span class="line">1) 1) &quot;1662536946521-0&quot;</span><br><span class="line">   2) 1) &quot;name&quot;</span><br><span class="line">      2) &quot;zhangfei&quot;</span><br><span class="line">      3) &quot;age&quot;</span><br><span class="line">      4) &quot;23&quot;</span><br><span class="line">2) 1) &quot;1662536996569-0&quot;</span><br><span class="line">   2) 1) &quot;name&quot;</span><br><span class="line">      2) &quot;zhaoyun&quot;</span><br><span class="line">      3) &quot;age&quot;</span><br><span class="line">      4) &quot;24&quot;</span><br><span class="line">      5) &quot;name&quot;</span><br><span class="line">      6) &quot;diaochan&quot;</span><br><span class="line">      7) &quot;age&quot;</span><br><span class="line">      8) &quot;16&quot;</span><br><span class="line">127.0.0.1:6379&gt; xread count 1 streams topic:001 0</span><br><span class="line">1) 1) &quot;topic:001&quot;</span><br><span class="line">   2) 1) 1) &quot;1662536946521-0&quot;</span><br><span class="line">         2) 1) &quot;name&quot;</span><br><span class="line">            2) &quot;zhangfei&quot;</span><br><span class="line">            3) &quot;age&quot;</span><br><span class="line">            4) &quot;23&quot;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">创建的group1</span>            </span><br><span class="line">127.0.0.1:6379&gt; xgroup create topic:001 group1 0</span><br><span class="line">OK</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">创建cus1加入到group1 消费 没有被消费国的消息 消费第一条</span></span><br><span class="line">127.0.0.1:6379&gt; xreadgroup group group1 cusl count 1 streams topic:001 &gt;</span><br><span class="line">1) 1) &quot;topic:001&quot;</span><br><span class="line">   2) 1) 1) &quot;1662536946521-0&quot;</span><br><span class="line">         2) 1) &quot;name&quot;</span><br><span class="line">            2) &quot;zhangfei&quot;</span><br><span class="line">            3) &quot;age&quot;</span><br><span class="line">            4) &quot;23&quot;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">继续消费第二条</span>            </span><br><span class="line">127.0.0.1:6379&gt; xreadgroup group group1 cusl count 1 streams topic:001 &gt;</span><br><span class="line">1) 1) &quot;topic:001&quot;</span><br><span class="line">   2) 1) 1) &quot;1662536996569-0&quot;</span><br><span class="line">         2) 1) &quot;name&quot;</span><br><span class="line">            2) &quot;zhaoyun&quot;</span><br><span class="line">            3) &quot;age&quot;</span><br><span class="line">            4) &quot;24&quot;</span><br><span class="line">            5) &quot;name&quot;</span><br><span class="line">            6) &quot;diaochan&quot;</span><br><span class="line">            7) &quot;age&quot;</span><br><span class="line">            8) &quot;16&quot;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">没有可消费的</span>            </span><br><span class="line">127.0.0.1:6379&gt; xreadgroup group group1 cusl count 1 streams topic:001 &gt;</span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure>

<h3 id="4、存储数据结构"><a href="#4、存储数据结构" class="headerlink" title="4、存储数据结构"></a>4、存储数据结构</h3><p>Redis数据结构</p>
<p><img src="/images/Redis/6.jpg" alt="数据结构"></p>
<p>Redis没有表的概念，Redis实例所对应的db以编号区分，db本身就是key的命名空间。</p>
<p>例如：user:1000作为key，表示user表的id&#x3D;1000的行</p>
<p><strong>RedisDB结构</strong></p>
<p>Redis中存在“数据库”的概念，该结构由redis.h中的redisDb定义。</p>
<p>当redis服务器初始化时，会预先分配16个数据库。</p>
<p>所有数据库保存到结构redisServer的一个成员redisServer.db数组中</p>
<p>redisClient中存在一个名叫db的指针指向当前使用的数据库</p>
<p>RedisDB结构体源码</p>
<h4 id="结构信息概览"><a href="#结构信息概览" class="headerlink" title="结构信息概览"></a>结构信息概览</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span>&#123;</span></span><br><span class="line">    <span class="type">unsigned</span> type:<span class="number">4</span>;<span class="comment">//类型 对象类型</span></span><br><span class="line">    <span class="type">unsigned</span> encoding:<span class="number">4</span>;<span class="comment">//编码</span></span><br><span class="line">    <span class="type">void</span> *ptr;<span class="comment">//指向底层实现数据结构的指针</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="type">int</span> refcount;<span class="comment">//引用计数</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="type">unsigned</span> lru:LRU_BITS;<span class="comment">//LRU_BITS为24bit 记录最后一次被命令程序访问的时间</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;robj;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>4位type</p>
<p>type字段表示对象的类型，占4位；</p>
<p>REDIS_STRING(字符串)、REDIS_LIST(列表)、REDIS_HASH(哈希)、REDIS_SET(集合)、REDIS_ZSET(有序集合)</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">192.168.200.132:0&gt;type k1</span><br><span class="line">&quot;string&quot;</span><br></pre></td></tr></table></figure>


</li>
<li><p>4位encoding</p>
<p>encoding表示对象的内部编码，占4位</p>
<p>Redis根据不同的使用场景来为对象设置不同的编码，大大提高了Redis的灵活性和效率。通过Object encoding查看编码</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">192.168.200.132:0&gt;object encoding k1</span><br><span class="line">&quot;embstr&quot;</span><br></pre></td></tr></table></figure>


</li>
<li><p>24位LRU</p>
<p>lru记录的是对象最后一次被命令程序访问的时间，（4.0版本占24位，2.6版本占22位）。高16位存储一个分钟数级别的时间戳，低8位存储访问计数（lfu：最近访问次数）</p>
<p>lru—-&gt;高16位:最后被访问的时间</p>
<p>lfu—-&gt;低8位：最近访问次数</p>
</li>
<li><p>refcount</p>
<p>记录该对象被引用次数</p>
<p>refcount作用用于对象的引用计数和内存回收</p>
<p>refcount&gt;1成为共享对象</p>
</li>
<li><p>ptr</p>
<p>指针指向具体数据</p>
<p>例如：set hello world，ptr指向包含world的SDS</p>
</li>
</ul>
<h4 id="7种type"><a href="#7种type" class="headerlink" title="7种type"></a>7种type</h4><h5 id="（1）字符串对象"><a href="#（1）字符串对象" class="headerlink" title="（1）字符串对象"></a>（1）字符串对象</h5><p>C语言：字符数组”\0”</p>
<p>Redis使用了SDS（Simple Dynamic String）。用于存储字符串和整型数据</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span>&#123;</span></span><br><span class="line">	<span class="comment">//记录buf数组中已使用字节的数量</span></span><br><span class="line">	<span class="type">int</span> len;</span><br><span class="line">    <span class="comment">//记录buf 数组中未使用字节的数量</span></span><br><span class="line">    <span class="type">int</span> <span class="built_in">free</span>;</span><br><span class="line">    <span class="comment">//字符数组，用于保存字符串</span></span><br><span class="line">    <span class="type">char</span> buf[];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>buf[]的长度&#x3D;len+free+1</p>
<p>SDS优势：</p>
<p>1、SDS在C字符串的基础上加入了free和len字段，获取字符串长度：SDS是O(1)，C字符串是O(n)</p>
<p>2、SDS由于记录了长度，在可能造成缓冲区溢出时会自动重新分配内存，杜绝了缓冲区溢出。</p>
<p>3、可以存取二进制数据，以字符串长度len来作为结束标识</p>
<p>使用场景：</p>
<p>SDS的主要应用在：存储字符串和整型数据、存储key、AOF缓冲区和用户输入缓冲</p>
<h5 id="（2）跳跃表（重点）"><a href="#（2）跳跃表（重点）" class="headerlink" title="（2）跳跃表（重点）"></a>（2）跳跃表（重点）</h5><p>跳跃表是有序集合（sorted-set）的底层实现，效率高，实现简单。</p>
<p>跳跃表的基本思想：</p>
<p>将有序链表中的部分节点分层，每一层都是一个有序链表。使用二分查找的思想</p>
<p>查找</p>
<p>时间复杂度O(logn)</p>
<p>Redis跳跃表的实现</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//跳跃表节点</span></span><br><span class="line">typedf <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span>&#123;</span></span><br><span class="line">    sds ele; <span class="comment">/* 存储字符串类型数据 redis3.0版本中使⽤robj类型表示，但是在redis4.0.1中直接使⽤sds类型表示 */</span></span><br><span class="line">	<span class="type">double</span> score;<span class="comment">//存储排序的分值</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">backward</span>;</span><span class="comment">//后退指针，指向当前节点最底层的前⼀个节点 /*</span></span><br><span class="line">层，柔性数组，随机⽣成<span class="number">1</span><span class="number">-64</span>的值</span><br><span class="line">*/</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">zskiplistLevel</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">forward</span>;</span> <span class="comment">//指向本层下⼀个节点</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> span;<span class="comment">//本层下个节点到本节点的元素个数</span></span><br><span class="line">	&#125;level[];</span><br><span class="line">&#125;zskiplistNode</span><br><span class="line">    </span><br><span class="line"><span class="comment">//链表</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplist</span>&#123;</span></span><br><span class="line">	<span class="comment">//表头节点和表尾节点</span></span><br><span class="line">	structz skiplistNode *header, *tail;</span><br><span class="line">	<span class="comment">//表中节点的数量</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> length;</span><br><span class="line">	<span class="comment">//表中层数最⼤的节点的层数</span></span><br><span class="line">	<span class="type">int</span> level;</span><br><span class="line">&#125;zskiplist;</span><br></pre></td></tr></table></figure>

<p>跳跃表的优势：</p>
<ul>
<li>可以快速查找需要的节点O(logn)</li>
<li>可以在O(1)的时间复杂度下，快速获得跳跃表的头节点、尾结点、长度和高度</li>
</ul>
<p>应用场景：有序集合的实现</p>
<h5 id="（3）字典-重点-难点"><a href="#（3）字典-重点-难点" class="headerlink" title="（3）字典(重点+难点)"></a>（3）字典(重点+难点)</h5><p><img src="/images/Redis/7.jpg" alt="全局hash表"></p>
<p>字典dict又称散列表(hash)，是用来存储键值对的一种数据结构。</p>
<p>Redis整个数据库使用字典来存储。（K-V结构）</p>
<p>对Redis进行CURD操作其实就是对字典中的数据进行CURD操作。</p>
<p><strong>数组</strong></p>
<p>用来存储数据的容器，采用头指针+偏移量的方式能够以O(1)的时间复杂度定位到数据所在的内存地址。</p>
<p>Redis海量存储 快</p>
<p><strong>Hash函数</strong></p>
<p>Hash(散列)，作用是把任意长度的输入通过散列算法转换成固定类型、固定长度的散列值。hash函数可以把Redis里的key:包括字符串、整数、浮点数统一转换成整数。</p>
<p>key&#x3D;100.1 String “100.1” 5位长度的字符串</p>
<p>Redis-cli：times 33</p>
<p>Redis-Server:MurmurHash</p>
<p>数组下标&#x3D;hash(key)%数组容量(hash值%数组容量得到的余数)</p>
<p><strong>Hash冲突</strong></p>
<p>不同的key经过计算后出现数组下表一致，称为Hash冲突。</p>
<p>采用单链表在相同的下标位置处存储原始key和value</p>
<p>当根据key找Value，找到数组下标，遍历单链表可以找出key相同的value</p>
<h6 id="Redis字典的实现"><a href="#Redis字典的实现" class="headerlink" title="Redis字典的实现"></a>Redis字典的实现</h6><p>Redis字典实现包括：字典(dict)、Hash表(dictht)、Hash表节点(dictEntry)。</p>
<p><strong>Hash表</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictht</span>&#123;</span></span><br><span class="line">	dictEntry *table;<span class="comment">//哈希表数组</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> size;<span class="comment">//哈希表数组的大小</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> sizemask;<span class="comment">//用于映射位置的掩码，值永远等于(size-1)</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> used;<span class="comment">//哈希表已有节点的数量，包含next单链表数据</span></span><br><span class="line">&#125;dictht;</span><br></pre></td></tr></table></figure>

<p>1、hash表的数组初始容量为4，随着k-v存储量的增加需要对hash表数组进行扩容，新扩容量为当前量的一倍，即4，8，16，32</p>
<p>2、索引值&#x3D;Hash值&amp;掩码值(Hash值与Hash表容量取余)</p>
<p><strong>Hash表节点</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span>&#123;</span></span><br><span class="line">	<span class="type">void</span> *key; <span class="comment">//键</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span>	<span class="comment">//值v的类型可以是以下4种类型</span></span><br><span class="line">        <span class="type">void</span> *val;</span><br><span class="line">        <span class="type">uint64_t</span> u64;</span><br><span class="line">        <span class="type">int64_t</span> s64;</span><br><span class="line">        <span class="type">double</span> d;</span><br><span class="line">    &#125;v;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> *<span class="title">next</span>;</span> <span class="comment">//指向下一个哈希表，形成单向链表 解决hash冲突</span></span><br><span class="line">&#125;dictEntry;</span><br></pre></td></tr></table></figure>

<p>key字段存储的是键值对中的键</p>
<p>v字段是个联合体，存储的是键值对中的值。</p>
<p>next指向下一个哈希表节点，用于解决hash冲突</p>
<p><strong>dict字典</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dict</span>&#123;</span></span><br><span class="line">    dictType *type;<span class="comment">//该字典对应的特定操作函数</span></span><br><span class="line">    <span class="type">void</span> *privdata;<span class="comment">//上述类型函数对应的可选参数</span></span><br><span class="line">    dictht ht[<span class="number">2</span>];<span class="comment">/*两张哈希表，存储键值对数据，ht[0]为原生哈希表，ht[1]为rehash哈希表*/</span></span><br><span class="line">    <span class="type">long</span> rehashidx;<span class="comment">/*rehash标识 当等于-1时表示没有在rehash，</span></span><br><span class="line"><span class="comment">否则表示正在进⾏rehash操作，存储的值表示</span></span><br><span class="line"><span class="comment">hash表 ht[0]的rehash进⾏到哪个索引值</span></span><br><span class="line"><span class="comment">(数组下标)*/</span></span><br><span class="line">    <span class="type">int</span> iterators; <span class="comment">//当前运行的迭代器数量</span></span><br><span class="line">&#125;dict;</span><br></pre></td></tr></table></figure>

<p>type字段，指向dictType结构体，里边包括了对盖子点操作的函数指针</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictType</span>&#123;</span></span><br><span class="line">	<span class="comment">//计算哈希值的函数</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="title function_">int</span> <span class="params">(*hashFunction)</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *key)</span>;</span><br><span class="line">    <span class="comment">//复制键的函数</span></span><br><span class="line">    <span class="type">void</span> *(*keyDup)(<span class="type">void</span> *privdata,<span class="type">const</span> <span class="type">void</span> *key);</span><br><span class="line">    <span class="comment">//复制值得函数</span></span><br><span class="line">    <span class="type">void</span> *(*valDup)(<span class="type">void</span> *privdata,<span class="type">const</span> <span class="type">void</span> *obj);</span><br><span class="line">    <span class="comment">//比较键的函数</span></span><br><span class="line">    <span class="type">int</span> (*keyCompare)(<span class="type">void</span> *privdata,<span class="type">const</span> <span class="type">void</span> *key1,<span class="type">const</span> <span class="type">void</span> *key2);</span><br><span class="line">    <span class="comment">//销毁键的函数</span></span><br><span class="line">    <span class="type">void</span> (*keyDestructor)(<span class="type">void</span> *privdata,<span class="type">void</span> *key);</span><br><span class="line">    <span class="comment">//销毁值的函数</span></span><br><span class="line">    <span class="type">void</span> (*valDestructor)(<span class="type">void</span> *privdata,<span class="type">void</span> *obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Redis字典除了主数据库的K-V数据存储以外，还可以用于：散列表对象、哨兵模式中的主从节点管理等</p>
<p>dictType是为了实现各种形态的字典而抽象出来的操作函数（多态）。</p>
<h6 id="字典扩容"><a href="#字典扩容" class="headerlink" title="字典扩容"></a>字典扩容</h6><p>字典达到存储上限（阈值0.75），需要rehash（扩容）</p>
<p>说明：</p>
<ul>
<li>初次申请默认容量为4个dictEntry，非初次申请为当前hash表容量的一倍。</li>
<li>rehashidx&#x3D;0标识要进行rehash操作。</li>
<li>新增加的数据在新的hash表h[1]</li>
<li>修改、删除、查询在老hash表h[0]、新hash表h[1]中(rehash中)</li>
<li>将老的hash表h[0]的数据重新计算索引值后全部迁移到新的哈希表h[1]中，这个过程成为rehash。</li>
</ul>
<p>应用场景：</p>
<ul>
<li>主数据库的K-V数据存储</li>
<li>散列表对象(hash)</li>
<li>哨兵模式中的主从节点管理</li>
</ul>
<h5 id="（4）压缩列表（重点）"><a href="#（4）压缩列表（重点）" class="headerlink" title="（4）压缩列表（重点）"></a>（4）压缩列表（重点）</h5><p>压缩列表（ziplist）是由一系列特殊编码的连续内存块组成的顺序型数据结构节省内存，<strong>这是一种非常节省内存的结构</strong>。</p>
<p>它是一个字节数组表头有三个字段zlbytes、zltail和zllen，分别标识列表长度、列表尾的偏移量，以及列表中的entry个数。压缩列表尾还有一个zlend，标识列表结束。每个节点可以保存一个字节数组或一个整数。</p>
<p>zlbytes：压缩列表的字节长度</p>
<p>zltail：压缩列表尾元素相对于压缩列表起始地址的偏移量</p>
<p>zllen：压缩列表的元素个数</p>
<p>entry1…entryX：压缩列表的各个节点</p>
<p>zlend：压缩列表的结尾，占一个字节，恒为0xFF（255）</p>
<p>entryX元素的编码结构：</p>
<ul>
<li>previous_entry_length ：表示前⼀个 entry 的⻓度。 prev_len 有两种取值情况： 1 字节或 5 字节。<br>取值 1 字节时，表示上⼀个 entry 的⻓度⼩于 254 字节。虽然 1 字节的值能表示的数值范围是 0 到<br>255，但是压缩列表中 zlend 的取值默认是 255，因此，就默认⽤ 255 表示整个压缩列表的结束，<br>其他表示⻓度的地⽅就不能再⽤ 255 这个值了。所以，当上⼀个 entry ⻓度⼩于 254 字节时，<br>prev_len 取值为 1 字节，否则，就取值为 5 字节。  </li>
<li>encoding：标识当前元素的编码1字节</li>
<li>content：数据内容</li>
</ul>
<p>ziplist结构体如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ziplist</span>&lt;</span>T&gt;&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> zlbytes; <span class="comment">//ziplist的长度字节数，包含头部、所有entry和zipend。</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> zloffset;<span class="comment">//从ziplist的头指针到只想最后一个entry的偏移量，用于快速反向查询</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> zllength; <span class="comment">//entry元素个数</span></span><br><span class="line">    T[] entry; <span class="comment">//元素值</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> zlend;<span class="comment">//ziplist结束符，值固定为0xFF</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zlentry</span>&#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> prevrawlensize; <span class="comment">//previous_entry_length字段的⻓度</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> prevrawlen; <span class="comment">//previous_entry_length字段存储的内容</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> lensize; <span class="comment">//encoding字段的⻓度</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> len; <span class="comment">//数据内容⻓度</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> headersize; <span class="comment">//当前元素的⾸部⻓度，即previous_entry_length字段⻓度与 encoding字段⻓度之和。</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> encoding; <span class="comment">//数据类型</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> *p; <span class="comment">//当前元素⾸地址</span></span><br><span class="line">&#125;zlentry</span><br></pre></td></tr></table></figure>

<p>应用场景：</p>
<p><strong>sorted-set和hash元素个数少且是小整数或短字符串（直接使用）</strong></p>
<p>list用快速链表(quicklist)数据结构存储，而快速链表是双向列表与压缩列表的组合。(间接使用)</p>
<p>注意：</p>
<p>不管是使⽤Hash还是Sorted Set，当采⽤ziplist⽅式存储时，虽然可以节省内存空间，但是<strong>在查询指定元素时，都要遍历整个ziplist</strong>，找到指定的元素。所以使⽤ziplist方式存储时，虽然可以利⽤CPU高速缓存，但也不适合存储过多的数据（hash-max-ziplist-entries和zset-max-ziplist-entries不宜设置过大），否则查询性能就会下降比较厉害。整体来说，这样的方案就是<strong>使用稀疏索引的思想 时间换空间</strong> ，我们需要权衡使用。  </p>
<p>使用ziplist存储，尽量存储int数据</p>
<ul>
<li>针对要存储的数据，会尽量选择占用内存小的方式存储（整数比字符串存储时占用内存更小）</li>
<li>ziplist每个元素紧凑排列，并且每个元素存储了上一个元素的长度，所以当修改其中一个元素超过一定大小时，会引发多个元素的<strong>级联调整</strong>。引发性能问题，需要注意。（后续redis版本提供了个listpack的数据结构解决这个问题）</li>
</ul>
<h5 id="5-整数集合"><a href="#5-整数集合" class="headerlink" title="(5)整数集合"></a>(5)整数集合</h5><p>整数集合(intset)是一个有序的(整数升序)、存储整数的连续存储结构。</p>
<p>当Redis集合类型的元素都是整数并且都处在64位有符号整数范围内(2^64),使用该结构体存储。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">192.168.200.132:0&gt;sadd set:001 1 3 5 6 2</span><br><span class="line">&quot;5&quot;</span><br><span class="line">192.168.200.132:0&gt;object encoding set:001</span><br><span class="line">&quot;intset&quot;</span><br><span class="line">192.168.200.132:0&gt;sadd set:004 1 100000000000000000000000000 999999999</span><br><span class="line">&quot;3&quot;</span><br><span class="line">192.168.200.132:0&gt;object encoding set:004</span><br><span class="line">&quot;hashtable&quot;</span><br></pre></td></tr></table></figure>

<p>intset结构图：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">intset</span>&#123;</span></span><br><span class="line">    <span class="comment">//编码方式</span></span><br><span class="line">    <span class="type">uint32_t</span> encoding;</span><br><span class="line">    <span class="comment">//集合包含的元素数量</span></span><br><span class="line">    <span class="type">uint32_t</span> length;</span><br><span class="line">    <span class="comment">//保存元素的数组</span></span><br><span class="line">    <span class="type">int8_t</span> contents[];</span><br><span class="line">&#125;intset;</span><br></pre></td></tr></table></figure>

<p>应用场景：</p>
<p>可以保存类型为int16_t、int32_t或者int64_t的整数值，并且保证集合中不会出现重复元素。</p>
<p>快速列表（重要）</p>
<p>列表的底层实现。（在Redis3.2之前，Redis采用双向链表(adlist)和压缩列表(ziplist)实现。）在Redis3.2以后结合adlist和ziplist的优势Redis设计出了quicklist</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">192.168.200.132:0&gt;lpush list:001 1 2 5 4 3</span><br><span class="line">&quot;5&quot;</span><br><span class="line">192.168.200.132:0&gt;object encoding list:001</span><br><span class="line">&quot;quicklist&quot;</span><br></pre></td></tr></table></figure>

<h5 id="6-双向链表-adlist"><a href="#6-双向链表-adlist" class="headerlink" title="(6)双向链表(adlist)"></a>(6)双向链表(adlist)</h5><p><img src="/images/Redis/8.jpg" alt="双向列表"></p>
<p>优势：</p>
<ul>
<li><p>双向：链表具有前置节点和后置节点的引用，获取这两个节点时间复杂度都为O(1)。</p>
</li>
<li><p>普通链表(单链表)：节点类保留下⼀节点的引用。链表类只保留头节点的引用，只能从头节点插入删除</p>
</li>
<li><p>无环：表头节点的 prev 指针和表尾节点的 next 指针都指向 NULL,对链表的访问都是以 NULL 结束。</p>
<p>环状：头的前一个节点指向尾节点</p>
</li>
<li><p>带链表长度计数器：通过 len 属性获取链表⻓度的时间复杂度为 O(1)。</p>
</li>
<li><p>多态：链表节点使⽤ void* 指针来保存节点值，可以保存各种不同类型的值。</p>
</li>
</ul>
<h5 id="7-快速列表"><a href="#7-快速列表" class="headerlink" title="(7)快速列表"></a>(7)快速列表</h5><p>quicklist是一个双向链表，链表中每个节点是一个ziplist结构。quicklist中的每个节点ziplist都能够存储多个数据元素。</p>
<p>quicklist结构定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">quicklist</span>&#123;</span></span><br><span class="line">	quciklistNode *head;	<span class="comment">//指向quicklist的头部</span></span><br><span class="line">    quicklistNode *tail;	<span class="comment">//指向quicklist的尾部</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> count;	<span class="comment">//列表中所有数据项的个数总和</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> len;		<span class="comment">//quicklist节点的个数，即ziplist的个数</span></span><br><span class="line">    <span class="type">int</span> fill : <span class="number">16</span>;			<span class="comment">//ziplist大小限定，由list-max-ziplist-size给定</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> compress : <span class="number">16</span>; <span class="comment">//节点压缩深度设置，由list-compress-depth给定(Redis设定)</span></span><br><span class="line">&#125;quicklist;</span><br></pre></td></tr></table></figure>

<p>quicklistNode的结构定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">quicklistNode</span>&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">quicklistNode</span> *<span class="title">prev</span>;</span> <span class="comment">// 指向上⼀个ziplist节点</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">quicklistNode</span> *<span class="title">next</span>;</span> <span class="comment">// 指向下⼀个ziplist节点</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> *zl; <span class="comment">// 数据指针，如果没有被压缩，就指向ziplist结构，反之指向 quicklistLZF结构</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> sz; <span class="comment">// 表示指向ziplist结构的总⻓度(内存占⽤⻓度)</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> count : <span class="number">16</span>; <span class="comment">// 表示ziplist中的数据项个数</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> encoding : <span class="number">2</span>; <span class="comment">// 编码⽅式， 1--ziplist， 2--quicklistLZF</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> container : <span class="number">2</span>; <span class="comment">// 预留字段，存放数据的⽅式， 1--NONE， 2--ziplist</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> recompress : <span class="number">1</span>; <span class="comment">// 解压标记，当查看⼀个被压缩的数据时，需要暂时解压，标记此参数为 1，之后再重新进⾏压缩</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> attempted_compress : <span class="number">1</span>; <span class="comment">// 测试相关</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> extra : <span class="number">10</span>; <span class="comment">// 扩展字段，暂时没⽤</span></span><br><span class="line">&#125;quicklistNode</span><br></pre></td></tr></table></figure>

<p><strong>数据压缩</strong></p>
<p>quicklist每个节点的实际数据存储结构为ziplist ，这种结构的优势在于节省存储空间。为了进⼀步降低ziplist的存储空间，还可以对ziplist进⾏压缩。 Redis采⽤的压缩算法是LZF。其基本思想是：数据与前面重复的记录重复位置及⻓度，不重复的记录原始数据。<br>压缩过后的数据可以分成多个⽚段，每个⽚段有两个部分：解释字段和数据字段。 quicklistLZF的结构体如下：  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">quicklistLZF</span>&#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> sz;<span class="comment">//LZF压缩后占用的字节数</span></span><br><span class="line">    <span class="type">char</span> compressed[];<span class="comment">//柔性数组，指向数据部分</span></span><br><span class="line">&#125;quicklistLZF;</span><br></pre></td></tr></table></figure>

<p>应用场景</p>
<p>列表(List)的底层实现、发布与订阅、慢查询、监视器等功能</p>
<h4 id="10种encoding"><a href="#10种encoding" class="headerlink" title="10种encoding"></a>10种encoding</h4><p>encoding表示对象的内部编码，占4位。</p>
<p>Redis通过encoding属性为对象设置不同的编码</p>
<p>对于少的和小的数据，Redis采用小的和压缩的存储方式，体现Redis的灵活性，大大提高了Redis的存储量和执行效率</p>
<h5 id="1-String"><a href="#1-String" class="headerlink" title="(1)String"></a>(1)String</h5><p>int、raw、embstr</p>
<ul>
<li>当保存的是Long类型整数时，RedisObject中的指针就直接赋值为整数数据了，这样就不用额外的指针再指向整数了，节省了指针的空间开销。</li>
<li>当保存的是字符串数据，且字符串小于等于44字节时，RedisObject中的元数据、指针和SDS是一块连续的内存区域，这样就可以避免内存碎片，对cpu cacheline也比较友好。embstr编码</li>
<li>当字符串大于44字节时，SDS的数据量就开始变多了，Redis不再把SDS和RedisObject布局在一起了，而是会给SDS分配独立的空间，并用指针指向SDS结构。这种布局方式称为raw编码模式</li>
</ul>
<h6 id="int"><a href="#int" class="headerlink" title="int"></a>int</h6><p>REDIS_ENCODING_INT(int类型的整数)</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">192.168.200.132:0&gt;set n1 123</span><br><span class="line">&quot;OK&quot;</span><br><span class="line">192.168.200.132:0&gt;object encoding n1</span><br><span class="line">&quot;int&quot;</span><br></pre></td></tr></table></figure>

<h6 id="embstr"><a href="#embstr" class="headerlink" title="embstr"></a>embstr</h6><p>REDIS_ENCODING_EMBSTR(编码的简单动态字符串)</p>
<p>小字符串 长度小于44字节</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">192.168.200.132:0&gt;set n1 abc</span><br><span class="line">&quot;OK&quot;</span><br><span class="line">192.168.200.132:0&gt;object encoding n1</span><br><span class="line">&quot;embstr&quot;</span><br></pre></td></tr></table></figure>

<h6 id="raw"><a href="#raw" class="headerlink" title="raw"></a>raw</h6><p>REDIS_ENCODING_RAW(简单动态字符串)</p>
<p>大字符串 长度大于44个字节</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">192.168.200.132:0&gt;set n1 aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa</span><br><span class="line">&quot;OK&quot;</span><br><span class="line">192.168.200.132:0&gt;object encoding n1</span><br><span class="line">&quot;raw&quot;</span><br></pre></td></tr></table></figure>



<h5 id="2-list"><a href="#2-list" class="headerlink" title="(2)list"></a>(2)list</h5><p>列表的编码是quicklist。</p>
<p>REDIS_ENCODING_QUICKLIST(快速列表)</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">192.168.200.132:0&gt;lpush list:001 1 2 3 4 6 5</span><br><span class="line">&quot;11&quot;</span><br><span class="line">192.168.200.132:0&gt;object encoding list:001</span><br><span class="line">&quot;quicklist&quot;</span><br></pre></td></tr></table></figure>

<h5 id="3-hash"><a href="#3-hash" class="headerlink" title="(3)hash"></a>(3)hash</h5><p>散列的编码是字典和压缩列表</p>
<h6 id="dict"><a href="#dict" class="headerlink" title="dict"></a>dict</h6><p>REDIS_ENCODING_HT(字典)</p>
<p>当散列表元素的个数⽐较多或元素不是⼩整数或短字符串时。  </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">192.168.200.132:0&gt;hmset user:003 username11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111 222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222</span><br><span class="line">&quot;OK&quot;</span><br><span class="line">192.168.200.132:0&gt;object encoding user:003</span><br><span class="line">&quot;hashtable&quot;</span><br></pre></td></tr></table></figure>

<h6 id="ziplist"><a href="#ziplist" class="headerlink" title="ziplist"></a>ziplist</h6><p>REDIS_ENCODING_ZIPLIST (压缩列表)<br>当散列表元素的个数⽐较少，且元素都是⼩整数或短字符串时。  </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hmset user:001 username zhangfei password 111 age 23</span><br><span class="line">sex M</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; object encoding user:001</span><br><span class="line">&quot;ziplist&quot;</span><br></pre></td></tr></table></figure>

<h5 id="4-set"><a href="#4-set" class="headerlink" title="(4)set"></a>(4)set</h5><p>整形集合和字典</p>
<h6 id="intset"><a href="#intset" class="headerlink" title="intset"></a>intset</h6><p>REDIS_ENCODING_INTSET(整数集合)</p>
<p>当Redis集合类型的元素都是整数并且都处在64位有符号整数范围内(&lt;18446744073709551616)</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">192.168.200.132:0&gt;sadd set:001 1 3 5 6 2</span><br><span class="line">&quot;5&quot;</span><br><span class="line">192.168.200.132:0&gt;object encoding set:001</span><br><span class="line">&quot;intset&quot;</span><br></pre></td></tr></table></figure>

<h6 id="dict-1"><a href="#dict-1" class="headerlink" title="dict"></a>dict</h6><p>REDIS_ENCODING_HT(字典)</p>
<p>当Redis集合类型元素是非整数或都处在64位有符号整数范围外(&gt;18446744073709551616)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">192.168.200.132:0&gt;sadd set:004 11111111111111111111111111111111111111111 22222222222222222222222222222222222222222222222222222222222222222222222222222222222</span><br><span class="line">&quot;2&quot;</span><br><span class="line">192.168.200.132:0&gt;object encoding set:004</span><br><span class="line">&quot;hashtable&quot;</span><br></pre></td></tr></table></figure>



<h5 id="5-zset"><a href="#5-zset" class="headerlink" title="(5)zset"></a>(5)zset</h5><p>压缩列表和跳跃表+字典</p>
<h6 id="ziplist-1"><a href="#ziplist-1" class="headerlink" title="ziplist"></a>ziplist</h6><p>REDIS_ENCODING_ZIPLIST(压缩列表)</p>
<p>元素个数比较少，且元素都是小整数或短字符串时。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">192.168.200.132:0&gt;zadd hit:1 100 item1 20 item2 45 item3</span><br><span class="line">&quot;3&quot;</span><br><span class="line">192.168.200.132:0&gt;object encoding hit:1</span><br><span class="line">&quot;listpack&quot;</span><br></pre></td></tr></table></figure>

<h6 id="skiplist-dict"><a href="#skiplist-dict" class="headerlink" title="skiplist+dict"></a>skiplist+dict</h6><p>REDIS_ENCODING_SKIPLIST(跳跃表+字典)</p>
<p>当元素的个数比较多或元素不是小整数或短字符串时</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">192.168</span><span class="number">.200</span><span class="number">.132</span>:<span class="number">0</span>&gt;zadd hit:<span class="number">002</span> <span class="number">100</span> item1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111 <span class="number">20</span> item2 <span class="number">45</span> item3</span><br><span class="line"><span class="string">&quot;3&quot;</span></span><br><span class="line"><span class="number">192.168</span><span class="number">.200</span><span class="number">.132</span>:<span class="number">0</span>&gt;object encoding hit:<span class="number">002</span></span><br><span class="line"><span class="string">&quot;skiplist&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="三、Redis原理"><a href="#三、Redis原理" class="headerlink" title="三、Redis原理"></a>三、Redis原理</h2><h3 id="1、Redis持久化"><a href="#1、Redis持久化" class="headerlink" title="1、Redis持久化"></a>1、Redis持久化</h3><h4 id="为什么要持久化"><a href="#为什么要持久化" class="headerlink" title="为什么要持久化"></a>为什么要持久化</h4><p>目的：为了快速的恢复数据而不是为了存储数据</p>
<p>持久化方式：RDB和AOF</p>
<p>注：Redis持久化不保证数据的完整性</p>
<p>当Redis用作DB时，DB数据要完整，所以一定要有一个完整的数据源（文件、mysql）在系统启动时，从这个完整的数据源中将数据load到Redis中</p>
<h4 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h4><p>RDB（Redis DataBase），是redis默认的存储方式，RDB方式是通过快照(snapshotting)完成的。</p>
<p>触发快照的方式</p>
<p>①符合自定义配置的快照规则（在redis.conf中配置）</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">save &quot;&quot; #不使用RDB存储	不能主从</span><br><span class="line"></span><br><span class="line">save 900 1 #表示15分钟(900秒)内至少一个键被更改则进行快照</span><br></pre></td></tr></table></figure>

<p>②执行save或者bgsave命令，save会阻塞在主进程，bgsave不会</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">192.168.200.132:0&gt;bgsave</span><br><span class="line">&quot;Background saving started&quot;</span><br></pre></td></tr></table></figure>

<p>③执行flushall命令</p>
<p>④执行主从复制操作(第一次)</p>
<h5 id="RDB执行流程-原理"><a href="#RDB执行流程-原理" class="headerlink" title="RDB执行流程(原理)"></a>RDB执行流程(原理)</h5><p>①Redis父进程⾸先判断：当前是否在执行save ，或bgsave&#x2F;bgrewriteaof ( aof文件重写命令)的子进<br>程，如果在执行则bgsave命令直接返回。<br>②父进程执行fork (调⽤OS函数复制主进程)操作创建子进程，这个 复制过程中父进程是阻塞的 ，<br>Redis不能执行来自客户端的任何命令。<br>③父进程fork后， bgsave命令返回”Background saving started”信息并不再阻塞父进程，并可以响<br>应其他命令。<br>④子进程创建RDB⽂件，根据父进程内存快照生成临时快照文件，完成后对原有文件进行原子替换。<br>( RDB始终完整)<br>⑤子进程发送信号给父进程表示完成，父进程更新统计信息。<br>⑥父进程fork子进程后，继续工作。 </p>
<h5 id="RDB优缺点"><a href="#RDB优缺点" class="headerlink" title="RDB优缺点"></a>RDB优缺点</h5><ul>
<li>优点</li>
</ul>
<p>RDB是二进制压缩文件，占用空间小，便于传输(传给slaver)</p>
<p>主进程fork子进程，可以最大化Redis性能，主进程不能太大，Redis的数据量不能太大，fork复制过程中主进程阻塞</p>
<ul>
<li>缺点</li>
</ul>
<p>不保证数据完整性，会丢失最后一次快照以后更改的所有数据</p>
<h5 id="场景提问"><a href="#场景提问" class="headerlink" title="场景提问"></a>场景提问</h5><p><strong>快照时可以修改嘛？</strong></p>
<p>Redis会借助操作系统的写时复制技术(Copy-On-Write,COW)，在执行快照的同时，正常处理写操作。</p>
<p>如果主线程也是读数据，那么和bgsave子线程不影响。</p>
<p>如果主线程要修改一块数据，这块数据会被复制一份，生成副本。主线程在这个副本上进行修改，同时bgsave子线程可以继续把原来的数据写入RDB文件。</p>
<p>详细：bgsave实际执⾏过程中，是⼦进程复制了主线程的页表，所以通过页表映射，能读到主线程的原始数<br>据，而当有新数据写⼊或数据修改时，主线程会把新数据或修改后的数据写到⼀个新的物理内存地址<br>上，并修改主线程自己的页表映射。所以， 子进程读到的类似于原始数据的⼀个副本，而主线程也可以<br>正常进行修改。  </p>
<h4 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h4><p>AOF(append only file)是Redis的另一种持久化方式。Redis默认情况下是不开启的。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Redis 将所有对数据库进⾏过写⼊的命令(及其参数) ( RESP)记录到 AOF ⽂件， 以此达到记录数据库状态的目的，</span><br><span class="line">这样当Redis重启后只要按顺序回放这些命令就会恢复到原始状态了。</span><br></pre></td></tr></table></figure>

<p><strong>AOF会记录过程， RDB只管结果</strong>  </p>
<p>AOF功能开启</p>
<p>配置redis.conf</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 可以通过修改redis.conf配置⽂件中的appendonly参数开启</span><br><span class="line">appendonly yes</span><br><span class="line"># AOF⽂件的保存位置和RDB⽂件的位置相同，都是通过dir参数设置的。</span><br><span class="line">dir ./</span><br><span class="line"># 默认的⽂件名是appendonly.aof，可以通过appendfilename参数修改</span><br><span class="line">appendfilename appendonly.aof</span><br></pre></td></tr></table></figure>

 
      <!-- reward -->
      
      <div id="reword-out">
        <div id="reward-btn">
          打赏
        </div>
      </div>
      
    </div>
    

    <!-- copyright -->
    
    <div class="declare">
      <ul class="post-copyright">
        <li>
          <i class="ri-copyright-line"></i>
          <strong>版权声明： </strong>
          
          本博客所有文章除特别声明外，著作权归作者所有。转载请注明出处！
          
        </li>
      </ul>
    </div>
    
    <footer class="article-footer">
       
<div class="share-btn">
      <span class="share-sns share-outer">
        <i class="ri-share-forward-line"></i>
        分享
      </span>
      <div class="share-wrap">
        <i class="arrow"></i>
        <div class="share-icons">
          
          <a class="weibo share-sns" href="javascript:;" data-type="weibo">
            <i class="ri-weibo-fill"></i>
          </a>
          <a class="weixin share-sns wxFab" href="javascript:;" data-type="weixin">
            <i class="ri-wechat-fill"></i>
          </a>
          <a class="qq share-sns" href="javascript:;" data-type="qq">
            <i class="ri-qq-fill"></i>
          </a>
          <a class="douban share-sns" href="javascript:;" data-type="douban">
            <i class="ri-douban-line"></i>
          </a>
          <!-- <a class="qzone share-sns" href="javascript:;" data-type="qzone">
            <i class="icon icon-qzone"></i>
          </a> -->
          
          <a class="facebook share-sns" href="javascript:;" data-type="facebook">
            <i class="ri-facebook-circle-fill"></i>
          </a>
          <a class="twitter share-sns" href="javascript:;" data-type="twitter">
            <i class="ri-twitter-fill"></i>
          </a>
          <a class="google share-sns" href="javascript:;" data-type="google">
            <i class="ri-google-fill"></i>
          </a>
        </div>
      </div>
</div>

<div class="wx-share-modal">
    <a class="modal-close" href="javascript:;"><i class="ri-close-circle-line"></i></a>
    <p>扫一扫，分享到微信</p>
    <div class="wx-qrcode">
      <img src="//api.qrserver.com/v1/create-qr-code/?size=150x150&data=http://example.com/2022/09/02/Redis/" alt="微信分享二维码">
    </div>
</div>

<div id="share-mask"></div>  
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/redis/" rel="tag">redis</a></li></ul>

    </footer>
  </div>

   
  <nav class="article-nav">
    
    
      <a href="/2022/08/19/%E9%9D%A2%E7%BB%8F%E6%89%8B%E5%86%8C/" class="article-nav-link">
        <strong class="article-nav-caption">下一篇</strong>
        <div class="article-nav-title">面经手册总结</div>
      </a>
    
  </nav>

   
<!-- valine评论 -->
<div id="vcomments-box">
  <div id="vcomments"></div>
</div>
<script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src="https://cdn.staticfile.org/valine/1.4.16/Valine.min.js"></script>
<script>
  new Valine({
    el: "#vcomments",
    app_id: "JBGc675TEhus7TRAduWDLOmp-gzGzoHsz",
    app_key: "9l3Nv4dmWzC0Aig8SwX01hm8",
    path: window.location.pathname,
    avatar: "monsterid",
    placeholder: "给我的文章加点评论吧~",
    recordIP: true,
  });
  const infoEle = document.querySelector("#vcomments .info");
  if (infoEle && infoEle.childNodes && infoEle.childNodes.length > 0) {
    infoEle.childNodes.forEach(function (item) {
      item.parentNode.removeChild(item);
    });
  }
</script>
<style>
  #vcomments-box {
    padding: 5px 30px;
  }

  @media screen and (max-width: 800px) {
    #vcomments-box {
      padding: 5px 0px;
    }
  }

  #vcomments-box #vcomments {
    background-color: #fff;
  }

  .v .vlist .vcard .vh {
    padding-right: 20px;
  }

  .v .vlist .vcard {
    padding-left: 10px;
  }
</style>

 
   
    
    <script src="https://cdn.staticfile.org/twikoo/1.4.18/twikoo.all.min.js"></script>
    <div id="twikoo" class="twikoo"></div>
    <script>
        twikoo.init({
            envId: ""
        })
    </script>
 
</article>

</section>
      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2015-2022
        <i class="ri-heart-fill heart_icon"></i> liang sm
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>访问人数:<span id="busuanzi_value_site_uv"></span></span>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>浏览次数:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="卡西莫多的小站"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/photos">照片</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/friends">友链</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/about">关于我</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="搜索">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>谢谢老板~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->
 
<script src="/js/tocbot.min.js"></script>

<script>
  tocbot.init({
    tocSelector: ".tocbot",
    contentSelector: ".article-entry",
    headingSelector: "h1, h2, h3, h4, h5, h6",
    hasInnerContainers: true,
    scrollSmooth: true,
    scrollContainer: "main",
    positionFixedSelector: ".tocbot",
    positionFixedClass: "is-position-fixed",
    fixedSidebarOffset: "auto",
  });
</script>

<script src="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.staticfile.org/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/default-skin/default-skin.min.css">
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.js"></script>
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->
 
<script src="/js/busuanzi-2.3.pure.min.js"></script>
 
<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->

<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.staticfile.org/clipboard.js/2.0.10/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->
 
<script src="/js/dz.js"></script>
 
<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    <div id="music">
    
    
    
    <iframe frameborder="no" border="1" marginwidth="0" marginheight="0" width="200" height="52"
        src="//music.163.com/outchain/player?type=2&id=28457938&auto=1&height=32"></iframe>
</div>

<style>
    #music {
        position: fixed;
        right: 15px;
        bottom: 0;
        z-index: 998;
    }
</style>
    
    

  </div>
</body>

</html>