<!DOCTYPE html>


<html lang="zh-CN">
  

    <head>
      <meta charset="utf-8" />
        
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title> 卡西莫多的小站</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/favicon.ico" />
       
<link rel="stylesheet" href="/dist/main.css">

      
<link rel="stylesheet" href="/css/fonts/remixicon.css">

      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.staticfile.org/pace/1.2.4/pace.min.js"></script>
       
 

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    </head>
  </html>
</html>


<body>
  <div id="app">
    
      
    <main class="content on">
      
<section class="cover">
    
      
      <a class="forkMe" href="https://github.com/Shen-Yu/hexo-theme-ayer"
        target="_blank"><img width="149" height="149" src="/images/forkme.png"
          class="attachment-full size-full" alt="Fork me on GitHub" data-recalc-dims="1"></a>
    
  <div class="cover-frame">
    <div class="bg-box">
      <img src="/images/cover1.jpg" alt="image frame" />
    </div>
    <div class="cover-inner text-center text-white">
      <h1><a href="/">卡西莫多的小站</a></h1>
      <div id="subtitle-box">
        
        <span id="subtitle"></span>
        
      </div>
      <div>
        
      </div>
    </div>
  </div>
  <div class="cover-learn-more">
    <a href="javascript:void(0)" class="anchor"><i class="ri-arrow-down-line"></i></a>
  </div>
</section>



<script src="https://cdn.staticfile.org/typed.js/2.0.12/typed.min.js"></script>


<!-- Subtitle -->

  <script>
    try {
      var typed = new Typed("#subtitle", {
        strings: ['面朝大海，春暖花开', '愿你一生努力，一生被爱', '想要的都拥有，得不到的都释怀'],
        startDelay: 0,
        typeSpeed: 200,
        loop: true,
        backSpeed: 100,
        showCursor: true
      });
    } catch (err) {
      console.log(err)
    }
  </script>
  
<div id="main">
  <section class="outer">
  
  
  

<div class="notice" style="margin-top:50px">
    <i class="ri-heart-fill"></i>
    <div class="notice-content" id="broad"></div>
</div>
<script type="text/javascript">
    fetch('https://v1.hitokoto.cn')
        .then(response => response.json())
        .then(data => {
            document.getElementById("broad").innerHTML = data.hitokoto;
        })
        .catch(console.error)
</script>

<style>
    .notice {
        padding: 20px;
        border: 1px dashed #e6e6e6;
        color: #969696;
        position: relative;
        display: inline-block;
        width: 100%;
        background: #fbfbfb50;
        border-radius: 10px;
    }

    .notice i {
        float: left;
        color: #999;
        font-size: 16px;
        padding-right: 10px;
        vertical-align: middle;
        margin-top: -2px;
    }

    .notice-content {
        display: initial;
        vertical-align: middle;
    }
</style>
  
  <article class="articles">
    
    
    
    
    <article
  id="post-Redis"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/09/02/Redis/"
    >Redis</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/09/02/Redis/" class="article-date">
  <time datetime="2022-09-02T03:20:25.000Z" itemprop="datePublished">2022-09-02</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><h2 id="一、缓存原理"><a href="#一、缓存原理" class="headerlink" title="一、缓存原理"></a>一、缓存原理</h2><h3 id="1、缓存的思想"><a href="#1、缓存的思想" class="headerlink" title="1、缓存的思想"></a>1、缓存的思想</h3><h4 id="什么是缓存？"><a href="#什么是缓存？" class="headerlink" title="什么是缓存？"></a><strong>什么是缓存？</strong></h4><p><strong><u>空间换时间</u></strong></p>
<p>原指CPU上一种高速存储器CACHE，它先于内存与cpu交换数据，速度很快</p>
<p>存在内存中的原始数据复制集</p>
<h4 id="计算机系统缓存设计"><a href="#计算机系统缓存设计" class="headerlink" title="计算机系统缓存设计"></a>计算机系统缓存设计</h4><p><img src="/images/Redis/1.jpg" alt="计算机系统"></p>
<p><strong>高速的CPU被慢速的磁盘拖累了</strong>：如果每次ns级别的cpu要去ms级别的硬盘读取</p>
<p>计算机系统中默认两种缓存</p>
<ul>
<li>CPU里的末级缓存（LLC），缓存内存中数据，避免每次从内存存取数据。</li>
<li>内存中的高速页缓存（page cache），用来缓存磁盘中数据，避免每次从磁盘中存取数据。</li>
</ul>
<p><img src="/images/Redis/2.jpg" alt="计算机缓存"></p>
<p>缓存的两个特征：</p>
<ul>
<li>在一个层级化的系统中，缓存一定是一个快速子系统，数据存在缓存中，避免每次从慢速子系统中存取数据。</li>
<li>缓存系统的容量大小总是小于后端慢速系统的。</li>
</ul>
<h4 id="缓存的优势、代价"><a href="#缓存的优势、代价" class="headerlink" title="缓存的优势、代价"></a>缓存的优势、代价</h4><p>优势：</p>
<ul>
<li><p>提升用户体验</p>
</li>
<li><p>减轻服务器压力</p>
</li>
<li><p>提升系统性能</p>
<p>系统性能指标：相应时间、延迟时间、吞吐量、并发用户数和资源利用率等。</p>
</li>
</ul>
<p>代价：</p>
<ul>
<li><p>额外的硬件支出</p>
</li>
<li><p>高并发缓存失效</p>
<p>高并发场景下会出现缓存失效（缓存穿透、缓存雪崩、缓存击穿）</p>
<p>造成瞬间数据库访问量增大，甚至崩溃</p>
</li>
<li><p>缓存与数据库数据同步</p>
<p>缓存与数据库无法做的数据时时同步</p>
</li>
<li><p>缓存并发竞争</p>
<p>多个redis客户端同时对一个key进行set值的时候由于执行顺序引起的并发问题（更新丢失）</p>
</li>
</ul>
<h3 id="2、缓存的使用场景"><a href="#2、缓存的使用场景" class="headerlink" title="2、缓存的使用场景"></a>2、缓存的使用场景</h3><ul>
<li><p>DB缓存，减轻DB服务器压力</p>
<ul>
<li>读写分离，分库分表</li>
<li>提高系统响应，数据存在redis中</li>
</ul>
</li>
<li><p>做Session分离</p>
<p>传统的session由tomcat自己进行维护，集群或分布式环境，不同的tomcat管理各自的session。</p>
<p>可以使用redis临时保存session，多个服务器共享session信息</p>
</li>
</ul>
<h3 id="3、缓存的分类"><a href="#3、缓存的分类" class="headerlink" title="3、缓存的分类"></a>3、缓存的分类</h3><p><img src="/images/Redis/3.jpg" alt="缓存分类"></p>
<h4 id="客户端缓存"><a href="#客户端缓存" class="headerlink" title="客户端缓存"></a>客户端缓存</h4><p>传统互联网：页面缓存和浏览器缓存</p>
<p>移动互联网：APP缓存</p>
<h4 id="服务端缓存"><a href="#服务端缓存" class="headerlink" title="服务端缓存"></a>服务端缓存</h4><h5 id="（1）数据库级缓存"><a href="#（1）数据库级缓存" class="headerlink" title="（1）数据库级缓存"></a>（1）数据库级缓存</h5><p>MySQL在Server层使用查询缓存机制。将查询后的数据缓存起来。K-V结构，Key：select语句的hash值，Value：查询结果</p>
<p>InnoDB存储引擎中的buffer-pool用于缓存InnoDB索引及数据块。</p>
<h5 id="（2）本地缓存"><a href="#（2）本地缓存" class="headerlink" title="（2）本地缓存"></a>（2）本地缓存</h5><p>平台级缓存指的是带有缓存特性的应用框架。</p>
<p>比如：Caffeine、GuavaCache、OSCache（页面缓存）等。部署在应用服务器上，也成为服务器本地缓存。</p>
<h5 id="（3）应用级缓存（重点）"><a href="#（3）应用级缓存（重点）" class="headerlink" title="（3）应用级缓存（重点）"></a>（3）应用级缓存（重点）</h5><p>具有缓存功能的中间件：Redis、Memcached、EVCache（AWS）、Tair（阿里、美团）等。采用K-V形式存储。</p>
<p>利用集群支持高可用、高性能、高并发、高扩展。</p>
<p>分布式缓存</p>
<h4 id="网络缓存"><a href="#网络缓存" class="headerlink" title="网络缓存"></a>网络缓存</h4><p><strong>边缘缓存</strong></p>
<p>CDN（Content Delivery Network），内容分发网络</p>
<blockquote>
<p>核心原则是”就近访问“，用户上网时不直接访问源站，而是访问离他最近的一个CDN节点，术语叫”边缘节点“（edge node），其实就是缓存了源站内容的代理服务器，省去了”长途跋涉“的时间成本，实现了”网络加速“。</p>
</blockquote>
<p>CDN的执行流程</p>
<p><img src="/images/Redis/4.jpg" alt="执行流程"></p>
<p>全局负载均衡（Global Sever Load ）</p>
<blockquote>
<p>简称GSLB，是CDN的“大脑”，主要职责是当用户接入网络的时候在CDN专网中挑选出一个“最佳”节点提供服务，解决的是用户如何找到“最近的”边缘节点，对整个CDN网络进行“负载均衡”。</p>
</blockquote>
<p>原来没有CDN的，权威DNS返回的是网站自己服务器的实际IP地址，浏览器收到DNS解析结果后直连网站。</p>
<p>加入CDN后，权威DNS返回的不是IP地址，而是一个CNAME（Canonical Name）别名记录，指向的就是CDN的GSLB。</p>
<p>因为没拿到IP地址，于是本地DNS就会像GSLB再发起请求，就进入了CDN的全局负载均衡系统，开始“智能调度”，主要依据有：</p>
<ul>
<li>看用户的IP地址，查表得知地理位置，找相对最近的边缘节点；</li>
<li>看用户所在的运营商网络，找相同网络的边缘节点；</li>
<li>检查边缘节点的负载情况，找负载较轻的节点</li>
<li>其他，比如节点的“健康状况”、服务能力、带宽、响应时间等。</li>
</ul>
<p>CDN关键概念：“命中”和“回源”</p>
<p>好的CDN应该是命中率越高越好，回源率越低越好</p>
<p>CDN的使用场景：</p>
<ul>
<li>手机游戏包</li>
<li>广告的图片素材</li>
<li>静态字段（js css）</li>
</ul>
<p>CDN的优化：</p>
<ul>
<li><p>缓存预热</p>
<p>提前把资源推送到边缘节点，避免用户访问的时候回源</p>
</li>
<li><p>使用高性能服务器</p>
</li>
</ul>
<h3 id="4、缓存的读写模式"><a href="#4、缓存的读写模式" class="headerlink" title="4、缓存的读写模式"></a>4、缓存的读写模式</h3><p>旁路缓存：客户端访问缓存系统，访问失败后客户端再访问慢速数据库。最终还需要客户端更新缓存。</p>
<p>非旁路缓存：客户端访问缓存系统，访问失败后由缓存系统访问慢速数据库，由缓存系统更新缓存。</p>
<h4 id="缓存三种读写模式"><a href="#缓存三种读写模式" class="headerlink" title="缓存三种读写模式"></a><strong>缓存三种读写模式</strong></h4><h5 id="Cache-Aside-Pattern-常用"><a href="#Cache-Aside-Pattern-常用" class="headerlink" title="Cache Aside Pattern(常用)"></a><strong>Cache Aside Pattern(常用)</strong></h5><p>Cache Aside Pattern（旁路缓存），是最经典的缓存+数据库读写模式。</p>
<p>读的时候先读缓存，缓存没有，就读数据库，然后取出数据后放入缓存，同时返回响应。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">cacheKey</span> <span class="operator">=</span> “productid_11010003”;</span><br><span class="line"><span class="type">String</span> <span class="variable">cacheValue</span> <span class="operator">=</span> redisCache.get(cacheKey)；</span><br><span class="line"><span class="comment">//缓存命中</span></span><br><span class="line"><span class="keyword">if</span> ( cacheValue != NULL)</span><br><span class="line">	<span class="keyword">return</span> cacheValue;</span><br><span class="line"><span class="comment">//缓存缺失</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    cacheValue = getProductFromDB();</span><br><span class="line">    redisCache.put(cacheValue) <span class="comment">//缓存更新</span></span><br></pre></td></tr></table></figure>

<p>更新时，先更新数据库，再删除缓存</p>
<p>为什么是删除缓存，而不是更新缓存呢？</p>
<ul>
<li>缓存的值是一个结构：hash、list，更新数据需要遍历 先遍历（耗时）后修改</li>
<li>懒加载，使用的时候才更新缓存</li>
</ul>
<p>使用的时候才从DB中加载</p>
<p>也可以采用异步的方式填充缓存</p>
<p>开启一个线程　定时将DB的数据刷到缓存中</p>
<p><strong>高并发脏读的三种情况</strong></p>
<p>１、先更新数据库，再更新缓存</p>
<p>update与commit之间，更新缓存，提交失败，进行rollback</p>
<p>Redis是回滚前的脏值，数据库是回滚后的旧值，则DB与缓存数据不一致</p>
<p>２、先删除缓存，再更新数据库</p>
<p>update与commit之间，有新的读，缓存空，读DB数据到缓存，数据是旧的数据（快照）</p>
<p>commit后，DB为新数据</p>
<p>则DB与缓存数据不一致</p>
<p>３、先更新数据库，再删除缓存（推荐）</p>
<p>问题和２一样，但是redis的操作比MySQL快，所以出现问题的概率比先删缓存再更新数据库小</p>
<p>根本原因：Redis和Mysql不在同一个“事务”里，导致没有正确删除掉redis的旧值</p>
<p>最终一致性解决方案：延时双删策略</p>
<p>保证数据的最终一致性（延时双删）</p>
<p>１、先更新数据库同时删除缓存项（key），等读的时候再填充缓存</p>
<p>2、2秒后再删除一次缓存项（key）</p>
<p>3、设置缓存过期时间ttl超时删除key 比如10秒 或1小时</p>
<p>4、通过数据库的binlog来异步淘汰key，利用工具（cancal）将binlog日志采集发送到MQ中，然后通过ACK机制确认处理删除缓存</p>
<h5 id="Read-x2F-Write-Through-Pattern"><a href="#Read-x2F-Write-Through-Pattern" class="headerlink" title="Read&#x2F;Write Through Pattern"></a>Read&#x2F;Write Through Pattern</h5><p>应用程序只操作缓存，缓存操作数据库</p>
<p>Read-Through（穿透读模式&#x2F;直读模式）：应用程序读缓存，缓存没有，由源存回源到数据库，并写入缓存（guavacache）</p>
<p>Write-Through（穿透写模式&#x2F;直写模式）：应用程序写缓存，缓存写数据库。</p>
<p>该种模式需要提供数据库的handler，开发较为复杂</p>
<h5 id="Write-Behind-Caching-Pattern"><a href="#Write-Behind-Caching-Pattern" class="headerlink" title="Write Behind Caching Pattern"></a>Write Behind Caching Pattern</h5><p>应用程序只更新缓存。</p>
<p>缓存通过异步的方式将数据批量或合并后更新到DB中</p>
<p>不能实时同步，甚至会丢数据</p>
<h2 id="二、Redis基本功能"><a href="#二、Redis基本功能" class="headerlink" title="二、Redis基本功能"></a>二、Redis基本功能</h2><blockquote>
<p>Redis（Remote Dictinonary Server）远程字典服务器，是用C语言开发的一个开源的高性能键值对（key-value）内存数据库。</p>
</blockquote>
<p>Redis应用场景</p>
<ul>
<li>缓存使用，减轻DB压力</li>
<li>DB使用，用于临时存储数据（字典表，购买记录）</li>
<li>解决分布式场景下Session分离问题（登录信息）</li>
<li>任务队列（秒杀、抢红包等等）乐观锁</li>
<li>应用排行榜 zset</li>
<li>签到bitmap</li>
<li>分布式锁</li>
<li>冷热数据交换</li>
</ul>
<h3 id="1、安装"><a href="#1、安装" class="headerlink" title="1、安装"></a>1、安装</h3><p><a target="_blank" rel="noopener" href="https://redis.io/docs/getting-started/installation/install-redis-on-windows/">https://redis.io/docs/getting-started/installation/install-redis-on-windows/</a></p>
<h3 id="2、使用"><a href="#2、使用" class="headerlink" title="2、使用"></a>2、使用</h3><h4 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h4><p>命令行：redis-cli</p>
<p>java client:Jedis，Spring-Data-Redis</p>
<h3 id="3、数据类型"><a href="#3、数据类型" class="headerlink" title="3、数据类型"></a>3、数据类型</h3><p>Redis是一个Key-Value的存储系统，使用ANSI C语言编写</p>
<p>key的类型是字符串。</p>
<p>value的数据类型有：</p>
<p>常用的：string字符串类型，list列表类型、set集合类型、sortedset（zset）有序集合类型、bash类型。</p>
<p>不常见的：HyberLogLog类型、bitmap位图类型、geo地理位置类型</p>
<p>Redis5.0新增一种：stream类型</p>
<p>注：Redis中命令是忽略大小写，(set SET)，key是不忽略大小写的（NAME name）</p>
<p>底层数据结构一共有6种：简单动态字符串、双向链表、压缩列表、哈希表、跳表和整数数组</p>
<p>Redis的Key的设计</p>
<ul>
<li>用:分割</li>
<li>把表名转换为key前缀，比如：user:</li>
<li>第二段放置主键值</li>
<li>第三段放置列名</li>
</ul>
<p>比如：用户表user，转换为redis的key-value存储</p>
<p>username的key：user:9:username</p>
<p>{userid:9,username:zhangf}</p>
<p>email的key user:9:email</p>
<p>表示明确：看key知道意思</p>
<p>不易被覆盖</p>
<h4 id="string字符串类型"><a href="#string字符串类型" class="headerlink" title="string字符串类型"></a>string字符串类型</h4><p>Redis的String能表达3种值的类型：字符串、整数、浮点数100.01是个六位的串</p>
<p>常见操作命令：</p>
<table>
<thead>
<tr>
<th>命令名称</th>
<th></th>
<th>命令描述</th>
</tr>
</thead>
<tbody><tr>
<td>set</td>
<td>set key value</td>
<td>赋值</td>
</tr>
<tr>
<td>get</td>
<td>get key</td>
<td>取值</td>
</tr>
<tr>
<td>getset</td>
<td>getset key value</td>
<td>取值并赋值</td>
</tr>
<tr>
<td>setnx</td>
<td>setnx key value</td>
<td>当key不存在时才用赋值set keyvalue NX PX 3000原子操作，px设置毫秒数</td>
</tr>
<tr>
<td>append</td>
<td>append key value</td>
<td>向尾部追加值</td>
</tr>
<tr>
<td>strlen</td>
<td>strlen key</td>
<td>获取字符串长度</td>
</tr>
<tr>
<td>incr</td>
<td>incr key</td>
<td>递增数字</td>
</tr>
<tr>
<td>incrby</td>
<td>incrby key increment</td>
<td>增加指定的整数</td>
</tr>
<tr>
<td>decr</td>
<td>decr key</td>
<td>递减数字</td>
</tr>
<tr>
<td>decrby</td>
<td>decrby key decrement</td>
<td>减少指定的整数</td>
</tr>
</tbody></table>
<p>应用场景：</p>
<p>1、key和命令是字符串</p>
<p>2、普通的赋值</p>
<p>3、incr用于乐观锁</p>
<p>incr：递增数字，可用于实现乐观锁 watch（事务）</p>
<p>4、setnx用于分布式锁</p>
<p>当value不存在时采用赋值，可用于实现分布式锁</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; setnx name zhangf #如果name不存在赋值</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; setnx name zhangf #再次赋值失败</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; get name</span><br><span class="line">&quot;zhangf&quot;</span><br></pre></td></tr></table></figure>

<p>set</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; <span class="built_in">set</span> age <span class="number">18</span> NX PX <span class="number">10000</span> <span class="comment">#如果不存在赋值 有效期10秒</span></span><br><span class="line">OK</span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; <span class="built_in">set</span> age <span class="number">20</span> NX <span class="comment">#赋值失败</span></span><br><span class="line">(nil)</span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; get age <span class="comment">#age失效</span></span><br><span class="line">(nil)</span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; <span class="built_in">set</span> age <span class="number">30</span> NX PX <span class="number">10000</span> <span class="comment">#赋值成功</span></span><br><span class="line">OK</span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; get age</span><br><span class="line"><span class="string">&quot;30&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="list列表类型"><a href="#list列表类型" class="headerlink" title="list列表类型"></a>list列表类型</h4><p>list列表类型可以存储有序、可重复的元素</p>
<p>获取头部或尾部附近的记录是极快的</p>
<p>list的元素个数最多为2^32-1个(40亿)</p>
<p>常见操作命令如下表：</p>
<table>
<thead>
<tr>
<th>命令名称</th>
<th>命令格式</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>lpush</td>
<td>lpush key v1v2v3…</td>
<td>从左侧插入列表</td>
</tr>
<tr>
<td>lpop</td>
<td>lpop key</td>
<td>从列表左侧取出</td>
</tr>
<tr>
<td>rpush</td>
<td>rpush key v1v2v3 …</td>
<td>从右侧插入列表</td>
</tr>
<tr>
<td>rpop</td>
<td>rpop key</td>
<td>从列表右侧取出</td>
</tr>
<tr>
<td>lpushx</td>
<td>lpushx key value</td>
<td>将值插入到列表头部</td>
</tr>
<tr>
<td>rpushx</td>
<td>rpushx key value</td>
<td>将值插入到列表尾部</td>
</tr>
<tr>
<td>blpop</td>
<td>blpop keytimeout</td>
<td>从列表左侧取出，当列表为空时阻塞，可以设置最大阻塞时间，单位为秒</td>
</tr>
<tr>
<td>brpop</td>
<td>brpop keytimeout</td>
<td>从列表右侧取出，当列表为空时阻塞，可以设置最大阻塞时间，单位为秒</td>
</tr>
<tr>
<td>llen</td>
<td>llen key</td>
<td>获得列表中元素个数</td>
</tr>
<tr>
<td>lindex</td>
<td>lindex keyindex</td>
<td>获得列表中下标为index的元素，index从0开始</td>
</tr>
<tr>
<td>lrange</td>
<td>lrange keystart end</td>
<td>返回列表中指定区间的元素，区间通过start和end指定</td>
</tr>
<tr>
<td>lrem</td>
<td>lrem key count value</td>
<td>删除列表中与value相等的元素当count&gt;0时，lren会从列表左边开始删除；当count&lt;0时，lrem会从列表后边开始删除；当count&#x3D;0时，lrem删除所有值为value的元素</td>
</tr>
<tr>
<td>lset</td>
<td>lset key index value</td>
<td>将列表index位置的元素设置成value的值</td>
</tr>
<tr>
<td>ltrim</td>
<td>ltrim key start end</td>
<td>对列表进行修剪，只保留start到end区间</td>
</tr>
<tr>
<td>rpoplpush</td>
<td>rpoplpush key 1 key2</td>
<td>从key1列表右侧弹出并插入到key2列表左侧</td>
</tr>
<tr>
<td>brpoplpush</td>
<td>brpoplpush key1 key2</td>
<td>从key1列表右侧弹出并插入到key2列表左侧，会阻塞</td>
</tr>
<tr>
<td>linsert</td>
<td>linsert keyBEFORE&#x2F;AFTER pivot value</td>
<td>将value插入到列表，且位于值pivot之前或之后</td>
</tr>
</tbody></table>
<p>应用场景：</p>
<p>1、作为栈或队列使用</p>
<p>列表有序可以作为栈和队列使用</p>
<p>2、可用于各种列表，比如用户列表、商品列表、评论列表等</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; lpush list:<span class="number">1</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">3</span> <span class="comment">#左侧插入</span></span><br><span class="line">(integer) <span class="number">6</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; lrange list:<span class="number">1</span> <span class="number">0</span> <span class="literal">-1</span> <span class="comment">#返回列表中指定区间元素</span></span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;3&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;5&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;4&quot;</span></span><br><span class="line"><span class="number">4</span>) <span class="string">&quot;3&quot;</span></span><br><span class="line"><span class="number">5</span>) <span class="string">&quot;2&quot;</span></span><br><span class="line"><span class="number">6</span>) <span class="string">&quot;1&quot;</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; lpop list:<span class="number">1</span> <span class="comment">#列表左侧取出</span></span><br><span class="line"><span class="string">&quot;3&quot;</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; rpop list:<span class="number">1</span>	<span class="comment">#列表右侧取出</span></span><br><span class="line"><span class="string">&quot;1&quot;</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; lindex list:<span class="number">1</span> <span class="number">1</span> <span class="comment">#获得列表中下标为1的元素</span></span><br><span class="line"><span class="string">&quot;4&quot;</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; lrange list:<span class="number">1</span> <span class="number">0</span> <span class="literal">-1</span></span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;5&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;4&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;3&quot;</span></span><br><span class="line"><span class="number">4</span>) <span class="string">&quot;2&quot;</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; lindex list:<span class="number">1</span> <span class="number">1</span></span><br><span class="line"><span class="string">&quot;4&quot;</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; rpoplpush list:<span class="number">1</span> list:<span class="number">2</span> <span class="comment">#从key1列表右侧弹出并插入到key2列表左侧</span></span><br><span class="line"><span class="string">&quot;2&quot;</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; lrange list:<span class="number">2</span> <span class="number">0</span> <span class="literal">-1</span></span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;2&quot;</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; lrange list:<span class="number">1</span> <span class="number">0</span> <span class="literal">-1</span></span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;5&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;4&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;3&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="set集合"><a href="#set集合" class="headerlink" title="set集合"></a>set集合</h4><p>Set：无序、唯一元素</p>
<p>集合中最大的成员数为2^32-1</p>
<p>常见操作命令如下表：</p>
<table>
<thead>
<tr>
<th>命令名称</th>
<th>命令格式</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>sadd</td>
<td>sadd key mem1 mem2 …</td>
<td>为集合添加新成员</td>
</tr>
<tr>
<td>srem</td>
<td>srem key mem1 mem2 …</td>
<td>删除集合中指定成员</td>
</tr>
<tr>
<td>smembers</td>
<td>smembers key</td>
<td>获得集合中所有元素</td>
</tr>
<tr>
<td>spop</td>
<td>spop key</td>
<td>返回集合中一个随即元素，并将该元素删除</td>
</tr>
<tr>
<td>srandmember</td>
<td>srandmember key</td>
<td>返回集合中一个随机元素，不会删除该元素</td>
</tr>
<tr>
<td>scard</td>
<td>scard key</td>
<td>获得集合中元素的数量</td>
</tr>
<tr>
<td>sismember</td>
<td>sismember key member</td>
<td>判断元素是否在集合内</td>
</tr>
<tr>
<td>sinter</td>
<td>sinter key1 key2 key3</td>
<td>求多集合的交集</td>
</tr>
<tr>
<td>sdiff</td>
<td>sdiff key1 key2 key3</td>
<td>求多集合的差集</td>
</tr>
<tr>
<td>sunion</td>
<td>sunion key1 key2 key3</td>
<td>求多集合的并集</td>
</tr>
</tbody></table>
<p>应用场景：</p>
<p>适用于不能重复的且不需要顺序的数据结构</p>
<p>比如：关注的用户，还可以通过spop进行随机抽奖</p>
<p>举例：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; sadd <span class="built_in">set</span>:<span class="number">1</span> a b c d <span class="comment">#为集合添加新成员</span></span><br><span class="line">(integer) <span class="number">0</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; smembers <span class="built_in">set</span>:<span class="number">1</span> <span class="comment">#获得集合中所有元素</span></span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;d&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;b&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;a&quot;</span></span><br><span class="line"><span class="number">4</span>) <span class="string">&quot;c&quot;</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; srandmember <span class="built_in">set</span>:<span class="number">1</span> <span class="comment">#返回集合中一个随机元素,不删除</span></span><br><span class="line"><span class="string">&quot;c&quot;</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; srandmember <span class="built_in">set</span>:<span class="number">1</span></span><br><span class="line"><span class="string">&quot;c&quot;</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; sadd <span class="built_in">set</span>:<span class="number">2</span> b c <span class="built_in">r</span> f</span><br><span class="line">(integer) <span class="number">4</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; sinter <span class="built_in">set</span>:<span class="number">1</span> <span class="built_in">set</span>:<span class="number">2</span> <span class="comment">#交集</span></span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;c&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;b&quot;</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; spop <span class="built_in">set</span>:<span class="number">1</span></span><br><span class="line"><span class="string">&quot;b&quot;</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; smembers <span class="built_in">set</span>:<span class="number">1</span></span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;d&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;a&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;c&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="sortedset有序集合类型"><a href="#sortedset有序集合类型" class="headerlink" title="sortedset有序集合类型"></a>sortedset有序集合类型</h4><p>SortedSet（ZSet）有序集合:元素本身是无序不重复的</p>
<p>每个元素关联一个分数（score）</p>
<p>可按分数排序，分数可重复</p>
<p>常见操作命令如下表：</p>
<table>
<thead>
<tr>
<th>命令名称</th>
<th>命令格式</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>zadd</td>
<td>zadd key score1 member1 score2member2 …</td>
<td>为有序集合添加新成员</td>
</tr>
<tr>
<td>zrem</td>
<td>zrem key mem1 mem2 …</td>
<td>删除有序集合中指定成员</td>
</tr>
<tr>
<td>zcard</td>
<td>zcard key</td>
<td>获取有序集合中的元素数量</td>
</tr>
<tr>
<td>zcount</td>
<td>zcount key min max</td>
<td>返回集合中score值再[min,max]区间的元素数量</td>
</tr>
<tr>
<td>zincrby</td>
<td>zincrby key increment member</td>
<td>在集合的member分值上加increment</td>
</tr>
<tr>
<td>zscore</td>
<td>zscore key member</td>
<td>获得集合中member的分值</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>命令名称</th>
<th>命令格式</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>zrank</td>
<td>zrank key member</td>
<td>获得集合中member的排名（按分值从小到大）</td>
</tr>
<tr>
<td>zrevrank</td>
<td>zrevrank key member</td>
<td>获得集合中member的排名（按分值从大到小）</td>
</tr>
<tr>
<td>zrange</td>
<td>zrange key start end</td>
<td>获得集合中指定区间成员，按分数递增排序</td>
</tr>
<tr>
<td>zrevrange</td>
<td>zrevrange key start end</td>
<td>获得集合中指定区间成员，按分数递减排序</td>
</tr>
</tbody></table>
<p>应用场景：</p>
<p>由于可以按照分值排序，所以适用于各种排行榜。比如：点击排行榜、销量排行榜、关注排行榜等。举例：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zadd hit:1 100 item1 20 item2 45 item3</span><br><span class="line">(integer) 3</span><br><span class="line">127.0.0.1:6379&gt; zcard hit:1</span><br><span class="line">(integer) 3</span><br><span class="line">127.0.0.1:6379&gt; zscore hit:1 item3</span><br><span class="line">&quot;45&quot;</span><br><span class="line">127.0.0.1:6379&gt; zrevrange hit:1 0 -1</span><br><span class="line">1) &quot;item1&quot;</span><br><span class="line">2) &quot;item3&quot;</span><br><span class="line">3) &quot;item2&quot;</span><br></pre></td></tr></table></figure>

<h4 id="hash类型（散列表）"><a href="#hash类型（散列表）" class="headerlink" title="hash类型（散列表）"></a>hash类型（散列表）</h4><p>Redis hash 是一个string类型的field和value的映射表，它提供了字段和字段值的映射。</p>
<p>每个hash可以存储2^32-1键值对（40多亿）</p>
<p><img src="/images/Redis/5.jpg" alt="hash"></p>
<p>常见操作命令：</p>
<table>
<thead>
<tr>
<th>命令名称</th>
<th>命令格式</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>hset</td>
<td>hset key field value</td>
<td>赋值，不区别新增或修改</td>
</tr>
<tr>
<td>hmset</td>
<td>hmset key field1 value1 field2 value2</td>
<td>批量赋值</td>
</tr>
<tr>
<td>hsetnx</td>
<td>hsetnx key field value</td>
<td>赋值，如果filed存在则不操作</td>
</tr>
<tr>
<td>hexists</td>
<td>hexists key filed</td>
<td>查看某个field是否存在</td>
</tr>
<tr>
<td>hget</td>
<td>hget key field</td>
<td>឴获取一个字段值</td>
</tr>
<tr>
<td>hmget</td>
<td>hmget key field1 field2 …</td>
<td>获取多个字段值</td>
</tr>
<tr>
<td>hgetall</td>
<td>hgetall key</td>
<td>获取所有字段值</td>
</tr>
<tr>
<td>hdel</td>
<td>hdel key field1 field2…</td>
<td>删除指定字段</td>
</tr>
<tr>
<td>hincrby</td>
<td>hincrby key field increment</td>
<td>指定字段自增</td>
</tr>
<tr>
<td>hlen</td>
<td>hlen key</td>
<td>获得字段数量</td>
</tr>
</tbody></table>
<p>应用场景：</p>
<p>对象的存储，表数据的映射</p>
<p>举例：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hmset user:001 username zhangfei password 111 age 23 sex M	#批量复制</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; hgetall user:001	#获取所有字段值</span><br><span class="line">1) &quot;username&quot;</span><br><span class="line">2) &quot;zhangfei&quot;</span><br><span class="line">3) &quot;password&quot;</span><br><span class="line">4) &quot;111&quot;</span><br><span class="line">5) &quot;age&quot;</span><br><span class="line">6) &quot;23&quot;</span><br><span class="line">7) &quot;sex&quot;</span><br><span class="line">8) &quot;M&quot;</span><br><span class="line">127.0.0.1:6379&gt; hget user:001 username #获取id的username值</span><br><span class="line">&quot;zhangfei&quot;</span><br><span class="line">127.0.0.1:6379&gt; hincrby user:001 age 1 #指定字段自增</span><br><span class="line">(integer) 24</span><br><span class="line">127.0.0.1:6379&gt; hlen user:001	#获得字段数量</span><br><span class="line">(integer) 4</span><br></pre></td></tr></table></figure>

<h4 id="bitmap位图类型"><a href="#bitmap位图类型" class="headerlink" title="bitmap位图类型"></a>bitmap位图类型</h4><p>bitmap是进行位操作的</p>
<p>通过一个bit位来表示某个元素对应的值或者状态，其中的key就是对应元素本身。</p>
<p>bitmap本身会极大的节省储存空间。</p>
<p>常见操作命令：</p>
<table>
<thead>
<tr>
<th>命令名称</th>
<th>命令格式</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>setbit</td>
<td>setbit key offset value</td>
<td>设置key在offset处的bit值（只能是0或1）</td>
</tr>
<tr>
<td>getbit</td>
<td>getbit key offset</td>
<td>获得key在offset处的bit值</td>
</tr>
<tr>
<td>bitcount</td>
<td>bitcount key</td>
<td>获得key的bit位为1的个数</td>
</tr>
<tr>
<td>bitpos</td>
<td>bitpos key value</td>
<td>返回第一个被设置为bit值得索引值</td>
</tr>
<tr>
<td>bitop</td>
<td>bitop and[or&#x2F;xor&#x2F;not] destkey key [key …]</td>
<td>对多个key逻辑运算后存入destkey中</td>
</tr>
</tbody></table>
<p>应用场景：</p>
<ul>
<li>用户每月签到，用户id为key，日期作为偏移量 1表示签到</li>
<li>统计活跃用户，日期为key，用户id偏移量1表示活跃</li>
<li>查询用户在线状态，日期为key，用户id为偏移量 1表示在线</li>
</ul>
<p>举例：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; setbit user:sign:1000 20200101 1</span><br><span class="line">(integer) 0	#id为1000的用户20200101签到</span><br><span class="line">127.0.0.1:6379&gt; setbit user:sign:1000 20200103 1</span><br><span class="line">(integer) 0 #id为1000的用户20200103签到</span><br><span class="line">127.0.0.1:6379&gt; getbit user:sign:1000 20200101</span><br><span class="line">(integer) 1  #id为1000的用户20200101签到状态</span><br><span class="line">127.0.0.1:6379&gt; getbit user:sign:1000 20200102</span><br><span class="line">(integer) 0  #id为1000的用户20200102签到状态</span><br><span class="line">127.0.0.1:6379&gt; bitcount user:sign:1000</span><br><span class="line">(integer) 2  #获得id为1000的用户签到次数</span><br><span class="line">127.0.0.1:6379&gt; bitpos user:sign:1000 1</span><br><span class="line">(integer) 20200101	#id为1000的用户第一次签到日期</span><br><span class="line">127.0.0.1:6379&gt; setbit 20200201 1000 1</span><br><span class="line">(integer) 0	#20200201的1000号用户上线</span><br><span class="line">127.0.0.1:6379&gt; setbit 20200201 1001 1</span><br><span class="line">(integer) 0	#20200201的1001号用户上线</span><br><span class="line">127.0.0.1:6379&gt; setbit 20200201 1002 1</span><br><span class="line">(integer) 0	#20200201的1002号用户上线</span><br><span class="line">127.0.0.1:6379&gt; setbit 20200202 1000 1</span><br><span class="line">(integer) 0	#20200202的1000号用户上线</span><br><span class="line">127.0.0.1:6379&gt; bitcount 20200201</span><br><span class="line">(integer) 3	#20200201的上线用户有2个</span><br><span class="line">127.0.0.1:6379&gt; bitop or desk1 20200201 20200202</span><br><span class="line">(integer) 126	#合并20200201的用户和20200202上线</span><br><span class="line">127.0.0.1:6379&gt; bitcount desk1</span><br><span class="line">(integer) 3	#统计20200201和20200202都上线的用户个数</span><br></pre></td></tr></table></figure>

<h4 id="geo地理位置类型"><a href="#geo地理位置类型" class="headerlink" title="geo地理位置类型"></a>geo地理位置类型</h4><p>geo是Redis用来处理位置信息的。Redis3.2中正式使用，利用Z阶曲线、Base32编码和geohash算法</p>
<p><strong>GeoHash算法</strong></p>
<p>为了能高效地对经纬度进行比较，Redis采用了业界广泛使用地GeoHash编码方法。</p>
<table>
<thead>
<tr>
<th>命令方式</th>
<th>命令格式</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>geoadd</td>
<td>geoadd key 经度 纬度 成员 名称1精度1维度1成员 名称2 经度2 纬度2 …</td>
<td>添加地理坐标</td>
</tr>
<tr>
<td>geohash</td>
<td>geohash key 成员名称1 成员名称2 …</td>
<td>返回标准的geohash串</td>
</tr>
<tr>
<td>geopos</td>
<td>geopos key 成员名称1 成员名称2</td>
<td>返回成员经纬度</td>
</tr>
<tr>
<td>geodist</td>
<td>geodist key 成员1 成员2 单位</td>
<td>计算成员间经纬度</td>
</tr>
<tr>
<td>georadiusbymember</td>
<td>georadiusbymember key 成员 值单位 count 数 asc[desc]</td>
<td>根据成员查找附近的成员</td>
</tr>
</tbody></table>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">192.168.200.132:0&gt;geoadd user:addr 116.31 40.05 zhangf 116.38 39.88 zhaoyun 116.47 40.00 diaochan #添加用户地址 zhangf、zhaoyun、diaochan的经纬度</span><br><span class="line">&quot;3&quot;</span><br><span class="line">192.168.200.132:0&gt;geohash user:addr zhangf diaochan #获得zhangf和diaochan的geohash</span><br><span class="line"> 1)  &quot;wx4eydyk5m0&quot;</span><br><span class="line"> 2)  &quot;wx4gd3fbgs0&quot;</span><br><span class="line">192.168.200.132:0&gt;geopos user:addr zhaoyun #获得zhaoyun的经纬度</span><br><span class="line"> 1)    1)   &quot;116.38000041246414185&quot;</span><br><span class="line">  2)   &quot;39.88000114172373145&quot;</span><br><span class="line"></span><br><span class="line">192.168.200.132:0&gt;geodist user:addr zhangf diaochan #计算zhangfei到diaochan的距离，单位m</span><br><span class="line">&quot;14718.6972&quot;</span><br><span class="line">192.168.200.132:0&gt;geodist user:addr zhangf diaochan km #计算zhangf到diaochan的距离，单位是km</span><br><span class="line">&quot;14.7187&quot;</span><br><span class="line">192.168.200.132:0&gt;geodist user:addr zhangf zhaoyun km</span><br><span class="line">&quot;19.8276&quot;</span><br><span class="line">192.168.200.132:0&gt;georadiusbymember user:addr zhangf 20 km withcoord withdist count 3 asc</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">获得距离zhangf20km以内的按由近到远的顺序排除前三名的成员名称、距离及经纬度</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">withcoord：获得经纬度withdist：获得距离withhash：获得geohash码</span></span><br><span class="line"> 1)    1)   &quot;zhangf&quot;</span><br><span class="line">  2)   &quot;0.0000&quot;</span><br><span class="line">  3)      1)    &quot;116.31000012159347534&quot;</span><br><span class="line">   2)    &quot;40.04999982043828055&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> 2)    1)   &quot;diaochan&quot;</span><br><span class="line">  2)   &quot;14.7187&quot;</span><br><span class="line">  3)      1)    &quot;116.46999925374984741&quot;</span><br><span class="line">   2)    &quot;39.99999991084916218&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> 3)    1)   &quot;zhaoyun&quot;</span><br><span class="line">  2)   &quot;19.8276&quot;</span><br><span class="line">  3)      1)    &quot;116.38000041246414185&quot;</span><br><span class="line">   2)    &quot;39.88000114172373145&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="stream数据流类型"><a href="#stream数据流类型" class="headerlink" title="stream数据流类型"></a>stream数据流类型</h4><p>stream是Redis5.0后新增的数据结构，用于可持久化的消息队列。</p>
<p>几乎满足了消息队列具备的全部内容，包括：</p>
<ul>
<li>消息ID的序列化生成</li>
<li>消息遍历</li>
<li>消息的阻塞和非阻塞读取</li>
<li>消息的分组消费</li>
<li>未完成消息的处理</li>
<li>消息队列监控</li>
</ul>
<p>每个stream都有唯一的名称，他就是Redis的key，首次使用xadd指令追加消息时自动创建。</p>
<p>常见操作命令：</p>
<table>
<thead>
<tr>
<th>命令名称</th>
<th>命令格式</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>xadd</td>
<td>xadd key id &lt;*&gt; field1 value1….</td>
<td>将指定消息数据追加到指定队列(key)中，*表示最新生成的id(当前时间+序列号)</td>
</tr>
<tr>
<td>xread</td>
<td>xread [COUNT count] [BLOCK milliseconds] STREAMS key [key …] ID [ID …]</td>
<td>从消息队列中读取，COUNT：读取条数，BLOCK：阻塞读（默认不阻塞）key：队列 名称 id：消息id</td>
</tr>
<tr>
<td>xrange</td>
<td>xrange key start end [COUNT]</td>
<td>读取队列中给定ID范围的消息COUNT：返回消息条数（消息id从小到大）</td>
</tr>
<tr>
<td>xrevrange</td>
<td>xrevrange key start end[COUNT]</td>
<td>读取队列中给定ID范围的消息COUNT：返回消息条数（消息id从大到小）</td>
</tr>
<tr>
<td>xdel</td>
<td>xdel key id</td>
<td>删除队列的消息</td>
</tr>
<tr>
<td>xgroup</td>
<td>xgroup create key groupname id</td>
<td>创建一个新的消费组</td>
</tr>
<tr>
<td>xgroup</td>
<td>xgroup destory keygroupname</td>
<td>删除指定消费组</td>
</tr>
<tr>
<td>xgroup</td>
<td>xgroup delconsumer keygroupname cname</td>
<td>删除指定消费组中的某个消费者</td>
</tr>
<tr>
<td>xgroup</td>
<td>xgroup setid key id</td>
<td>修改指定消息的最大id</td>
</tr>
<tr>
<td>xreadgroup</td>
<td>xreadgroup group groupname consumer COUNT streams key</td>
<td>从队列中的消费组中创建消费者并消费数据（consumer不存在则创建）</td>
</tr>
</tbody></table>
<p>应用场景：</p>
<p>消息队列的使用</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; xadd topic:001 * name zhangfei age 23</span><br><span class="line">&quot;1662536946521-0&quot;</span><br><span class="line">127.0.0.1:6379&gt; xadd topic:001 * name zhaoyun age 24 name diaochan age 16</span><br><span class="line">&quot;1662536996569-0&quot;</span><br><span class="line">127.0.0.1:6379&gt; xrange topic:001 - +</span><br><span class="line">1) 1) &quot;1662536946521-0&quot;</span><br><span class="line">   2) 1) &quot;name&quot;</span><br><span class="line">      2) &quot;zhangfei&quot;</span><br><span class="line">      3) &quot;age&quot;</span><br><span class="line">      4) &quot;23&quot;</span><br><span class="line">2) 1) &quot;1662536996569-0&quot;</span><br><span class="line">   2) 1) &quot;name&quot;</span><br><span class="line">      2) &quot;zhaoyun&quot;</span><br><span class="line">      3) &quot;age&quot;</span><br><span class="line">      4) &quot;24&quot;</span><br><span class="line">      5) &quot;name&quot;</span><br><span class="line">      6) &quot;diaochan&quot;</span><br><span class="line">      7) &quot;age&quot;</span><br><span class="line">      8) &quot;16&quot;</span><br><span class="line">127.0.0.1:6379&gt; xread count 1 streams topic:001 0</span><br><span class="line">1) 1) &quot;topic:001&quot;</span><br><span class="line">   2) 1) 1) &quot;1662536946521-0&quot;</span><br><span class="line">         2) 1) &quot;name&quot;</span><br><span class="line">            2) &quot;zhangfei&quot;</span><br><span class="line">            3) &quot;age&quot;</span><br><span class="line">            4) &quot;23&quot;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">创建的group1</span>            </span><br><span class="line">127.0.0.1:6379&gt; xgroup create topic:001 group1 0</span><br><span class="line">OK</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">创建cus1加入到group1 消费 没有被消费国的消息 消费第一条</span></span><br><span class="line">127.0.0.1:6379&gt; xreadgroup group group1 cusl count 1 streams topic:001 &gt;</span><br><span class="line">1) 1) &quot;topic:001&quot;</span><br><span class="line">   2) 1) 1) &quot;1662536946521-0&quot;</span><br><span class="line">         2) 1) &quot;name&quot;</span><br><span class="line">            2) &quot;zhangfei&quot;</span><br><span class="line">            3) &quot;age&quot;</span><br><span class="line">            4) &quot;23&quot;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">继续消费第二条</span>            </span><br><span class="line">127.0.0.1:6379&gt; xreadgroup group group1 cusl count 1 streams topic:001 &gt;</span><br><span class="line">1) 1) &quot;topic:001&quot;</span><br><span class="line">   2) 1) 1) &quot;1662536996569-0&quot;</span><br><span class="line">         2) 1) &quot;name&quot;</span><br><span class="line">            2) &quot;zhaoyun&quot;</span><br><span class="line">            3) &quot;age&quot;</span><br><span class="line">            4) &quot;24&quot;</span><br><span class="line">            5) &quot;name&quot;</span><br><span class="line">            6) &quot;diaochan&quot;</span><br><span class="line">            7) &quot;age&quot;</span><br><span class="line">            8) &quot;16&quot;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">没有可消费的</span>            </span><br><span class="line">127.0.0.1:6379&gt; xreadgroup group group1 cusl count 1 streams topic:001 &gt;</span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure>

<h3 id="4、存储数据结构"><a href="#4、存储数据结构" class="headerlink" title="4、存储数据结构"></a>4、存储数据结构</h3><p>Redis数据结构</p>
<p><img src="/images/Redis/6.jpg" alt="数据结构"></p>
<p>Redis没有表的概念，Redis实例所对应的db以编号区分，db本身就是key的命名空间。</p>
<p>例如：user:1000作为key，表示user表的id&#x3D;1000的行</p>
<p><strong>RedisDB结构</strong></p>
<p>Redis中存在“数据库”的概念，该结构由redis.h中的redisDb定义。</p>
<p>当redis服务器初始化时，会预先分配16个数据库。</p>
<p>所有数据库保存到结构redisServer的一个成员redisServer.db数组中</p>
<p>redisClient中存在一个名叫db的指针指向当前使用的数据库</p>
<p>RedisDB结构体源码</p>
<h4 id="结构信息概览"><a href="#结构信息概览" class="headerlink" title="结构信息概览"></a>结构信息概览</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span>&#123;</span></span><br><span class="line">    <span class="type">unsigned</span> type:<span class="number">4</span>;<span class="comment">//类型 对象类型</span></span><br><span class="line">    <span class="type">unsigned</span> encoding:<span class="number">4</span>;<span class="comment">//编码</span></span><br><span class="line">    <span class="type">void</span> *ptr;<span class="comment">//指向底层实现数据结构的指针</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="type">int</span> refcount;<span class="comment">//引用计数</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="type">unsigned</span> lru:LRU_BITS;<span class="comment">//LRU_BITS为24bit 记录最后一次被命令程序访问的时间</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;robj;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>4位type</p>
<p>type字段表示对象的类型，占4位；</p>
<p>REDIS_STRING(字符串)、REDIS_LIST(列表)、REDIS_HASH(哈希)、REDIS_SET(集合)、REDIS_ZSET(有序集合)</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">192.168.200.132:0&gt;type k1</span><br><span class="line">&quot;string&quot;</span><br></pre></td></tr></table></figure>


</li>
<li><p>4位encoding</p>
<p>encoding表示对象的内部编码，占4位</p>
<p>Redis根据不同的使用场景来为对象设置不同的编码，大大提高了Redis的灵活性和效率。通过Object encoding查看编码</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">192.168.200.132:0&gt;object encoding k1</span><br><span class="line">&quot;embstr&quot;</span><br></pre></td></tr></table></figure>


</li>
<li><p>24位LRU</p>
<p>lru记录的是对象最后一次被命令程序访问的时间，（4.0版本占24位，2.6版本占22位）。高16位存储一个分钟数级别的时间戳，低8位存储访问计数（lfu：最近访问次数）</p>
<p>lru—-&gt;高16位:最后被访问的时间</p>
<p>lfu—-&gt;低8位：最近访问次数</p>
</li>
<li><p>refcount</p>
<p>记录该对象被引用次数</p>
<p>refcount作用用于对象的引用计数和内存回收</p>
<p>refcount&gt;1成为共享对象</p>
</li>
<li><p>ptr</p>
<p>指针指向具体数据</p>
<p>例如：set hello world，ptr指向包含world的SDS</p>
</li>
</ul>
<h4 id="7种type"><a href="#7种type" class="headerlink" title="7种type"></a>7种type</h4><h5 id="（1）字符串对象"><a href="#（1）字符串对象" class="headerlink" title="（1）字符串对象"></a>（1）字符串对象</h5><p>C语言：字符数组”\0”</p>
<p>Redis使用了SDS（Simple Dynamic String）。用于存储字符串和整型数据</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span>&#123;</span></span><br><span class="line">	<span class="comment">//记录buf数组中已使用字节的数量</span></span><br><span class="line">	<span class="type">int</span> len;</span><br><span class="line">    <span class="comment">//记录buf 数组中未使用字节的数量</span></span><br><span class="line">    <span class="type">int</span> <span class="built_in">free</span>;</span><br><span class="line">    <span class="comment">//字符数组，用于保存字符串</span></span><br><span class="line">    <span class="type">char</span> buf[];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>buf[]的长度&#x3D;len+free+1</p>
<p>SDS优势：</p>
<p>1、SDS在C字符串的基础上加入了free和len字段，获取字符串长度：SDS是O(1)，C字符串是O(n)</p>
<p>2、SDS由于记录了长度，在可能造成缓冲区溢出时会自动重新分配内存，杜绝了缓冲区溢出。</p>
<p>3、可以存取二进制数据，以字符串长度len来作为结束标识</p>
<p>使用场景：</p>
<p>SDS的主要应用在：存储字符串和整型数据、存储key、AOF缓冲区和用户输入缓冲</p>
<h5 id="（2）跳跃表（重点）"><a href="#（2）跳跃表（重点）" class="headerlink" title="（2）跳跃表（重点）"></a>（2）跳跃表（重点）</h5><p>跳跃表是有序集合（sorted-set）的底层实现，效率高，实现简单。</p>
<p>跳跃表的基本思想：</p>
<p>将有序链表中的部分节点分层，每一层都是一个有序链表。使用二分查找的思想</p>
<p>查找</p>
<p>时间复杂度O(logn)</p>
<p>Redis跳跃表的实现</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//跳跃表节点</span></span><br><span class="line">typedf <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span>&#123;</span></span><br><span class="line">    sds ele; <span class="comment">/* 存储字符串类型数据 redis3.0版本中使⽤robj类型表示，但是在redis4.0.1中直接使⽤sds类型表示 */</span></span><br><span class="line">	<span class="type">double</span> score;<span class="comment">//存储排序的分值</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">backward</span>;</span><span class="comment">//后退指针，指向当前节点最底层的前⼀个节点 /*</span></span><br><span class="line">层，柔性数组，随机⽣成<span class="number">1</span><span class="number">-64</span>的值</span><br><span class="line">*/</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">zskiplistLevel</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">forward</span>;</span> <span class="comment">//指向本层下⼀个节点</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> span;<span class="comment">//本层下个节点到本节点的元素个数</span></span><br><span class="line">	&#125;level[];</span><br><span class="line">&#125;zskiplistNode</span><br><span class="line">    </span><br><span class="line"><span class="comment">//链表</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplist</span>&#123;</span></span><br><span class="line">	<span class="comment">//表头节点和表尾节点</span></span><br><span class="line">	structz skiplistNode *header, *tail;</span><br><span class="line">	<span class="comment">//表中节点的数量</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> length;</span><br><span class="line">	<span class="comment">//表中层数最⼤的节点的层数</span></span><br><span class="line">	<span class="type">int</span> level;</span><br><span class="line">&#125;zskiplist;</span><br></pre></td></tr></table></figure>

<p>跳跃表的优势：</p>
<ul>
<li>可以快速查找需要的节点O(logn)</li>
<li>可以在O(1)的时间复杂度下，快速获得跳跃表的头节点、尾结点、长度和高度</li>
</ul>
<p>应用场景：有序集合的实现</p>
<h5 id="（3）字典-重点-难点"><a href="#（3）字典-重点-难点" class="headerlink" title="（3）字典(重点+难点)"></a>（3）字典(重点+难点)</h5><p><img src="/images/Redis/7.jpg" alt="全局hash表"></p>
<p>字典dict又称散列表(hash)，是用来存储键值对的一种数据结构。</p>
<p>Redis整个数据库使用字典来存储。（K-V结构）</p>
<p>对Redis进行CURD操作其实就是对字典中的数据进行CURD操作。</p>
<p><strong>数组</strong></p>
<p>用来存储数据的容器，采用头指针+偏移量的方式能够以O(1)的时间复杂度定位到数据所在的内存地址。</p>
<p>Redis海量存储 快</p>
<p><strong>Hash函数</strong></p>
<p>Hash(散列)，作用是把任意长度的输入通过散列算法转换成固定类型、固定长度的散列值。hash函数可以把Redis里的key:包括字符串、整数、浮点数统一转换成整数。</p>
<p>key&#x3D;100.1 String “100.1” 5位长度的字符串</p>
<p>Redis-cli：times 33</p>
<p>Redis-Server:MurmurHash</p>
<p>数组下标&#x3D;hash(key)%数组容量(hash值%数组容量得到的余数)</p>
<p><strong>Hash冲突</strong></p>
<p>不同的key经过计算后出现数组下表一致，称为Hash冲突。</p>
<p>采用单链表在相同的下标位置处存储原始key和value</p>
<p>当根据key找Value，找到数组下标，遍历单链表可以找出key相同的value</p>
<h6 id="Redis字典的实现"><a href="#Redis字典的实现" class="headerlink" title="Redis字典的实现"></a>Redis字典的实现</h6><p>Redis字典实现包括：字典(dict)、Hash表(dictht)、Hash表节点(dictEntry)。</p>
<p><strong>Hash表</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictht</span>&#123;</span></span><br><span class="line">	dictEntry *table;<span class="comment">//哈希表数组</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> size;<span class="comment">//哈希表数组的大小</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> sizemask;<span class="comment">//用于映射位置的掩码，值永远等于(size-1)</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> used;<span class="comment">//哈希表已有节点的数量，包含next单链表数据</span></span><br><span class="line">&#125;dictht;</span><br></pre></td></tr></table></figure>

<p>1、hash表的数组初始容量为4，随着k-v存储量的增加需要对hash表数组进行扩容，新扩容量为当前量的一倍，即4，8，16，32</p>
<p>2、索引值&#x3D;Hash值&amp;掩码值(Hash值与Hash表容量取余)</p>
<p><strong>Hash表节点</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span>&#123;</span></span><br><span class="line">	<span class="type">void</span> *key; <span class="comment">//键</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span>	<span class="comment">//值v的类型可以是以下4种类型</span></span><br><span class="line">        <span class="type">void</span> *val;</span><br><span class="line">        <span class="type">uint64_t</span> u64;</span><br><span class="line">        <span class="type">int64_t</span> s64;</span><br><span class="line">        <span class="type">double</span> d;</span><br><span class="line">    &#125;v;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> *<span class="title">next</span>;</span> <span class="comment">//指向下一个哈希表，形成单向链表 解决hash冲突</span></span><br><span class="line">&#125;dictEntry;</span><br></pre></td></tr></table></figure>

<p>key字段存储的是键值对中的键</p>
<p>v字段是个联合体，存储的是键值对中的值。</p>
<p>next指向下一个哈希表节点，用于解决hash冲突</p>
<p><strong>dict字典</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dict</span>&#123;</span></span><br><span class="line">    dictType *type;<span class="comment">//该字典对应的特定操作函数</span></span><br><span class="line">    <span class="type">void</span> *privdata;<span class="comment">//上述类型函数对应的可选参数</span></span><br><span class="line">    dictht ht[<span class="number">2</span>];<span class="comment">/*两张哈希表，存储键值对数据，ht[0]为原生哈希表，ht[1]为rehash哈希表*/</span></span><br><span class="line">    <span class="type">long</span> rehashidx;<span class="comment">/*rehash标识 当等于-1时表示没有在rehash，</span></span><br><span class="line"><span class="comment">否则表示正在进⾏rehash操作，存储的值表示</span></span><br><span class="line"><span class="comment">hash表 ht[0]的rehash进⾏到哪个索引值</span></span><br><span class="line"><span class="comment">(数组下标)*/</span></span><br><span class="line">    <span class="type">int</span> iterators; <span class="comment">//当前运行的迭代器数量</span></span><br><span class="line">&#125;dict;</span><br></pre></td></tr></table></figure>

<p>type字段，指向dictType结构体，里边包括了对盖子点操作的函数指针</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictType</span>&#123;</span></span><br><span class="line">	<span class="comment">//计算哈希值的函数</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="title function_">int</span> <span class="params">(*hashFunction)</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *key)</span>;</span><br><span class="line">    <span class="comment">//复制键的函数</span></span><br><span class="line">    <span class="type">void</span> *(*keyDup)(<span class="type">void</span> *privdata,<span class="type">const</span> <span class="type">void</span> *key);</span><br><span class="line">    <span class="comment">//复制值得函数</span></span><br><span class="line">    <span class="type">void</span> *(*valDup)(<span class="type">void</span> *privdata,<span class="type">const</span> <span class="type">void</span> *obj);</span><br><span class="line">    <span class="comment">//比较键的函数</span></span><br><span class="line">    <span class="type">int</span> (*keyCompare)(<span class="type">void</span> *privdata,<span class="type">const</span> <span class="type">void</span> *key1,<span class="type">const</span> <span class="type">void</span> *key2);</span><br><span class="line">    <span class="comment">//销毁键的函数</span></span><br><span class="line">    <span class="type">void</span> (*keyDestructor)(<span class="type">void</span> *privdata,<span class="type">void</span> *key);</span><br><span class="line">    <span class="comment">//销毁值的函数</span></span><br><span class="line">    <span class="type">void</span> (*valDestructor)(<span class="type">void</span> *privdata,<span class="type">void</span> *obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Redis字典除了主数据库的K-V数据存储以外，还可以用于：散列表对象、哨兵模式中的主从节点管理等</p>
<p>dictType是为了实现各种形态的字典而抽象出来的操作函数（多态）。</p>
<h6 id="字典扩容"><a href="#字典扩容" class="headerlink" title="字典扩容"></a>字典扩容</h6><p>字典达到存储上限（阈值0.75），需要rehash（扩容）</p>
<p>说明：</p>
<ul>
<li>初次申请默认容量为4个dictEntry，非初次申请为当前hash表容量的一倍。</li>
<li>rehashidx&#x3D;0标识要进行rehash操作。</li>
<li>新增加的数据在新的hash表h[1]</li>
<li>修改、删除、查询在老hash表h[0]、新hash表h[1]中(rehash中)</li>
<li>将老的hash表h[0]的数据重新计算索引值后全部迁移到新的哈希表h[1]中，这个过程成为rehash。</li>
</ul>
<p>应用场景：</p>
<ul>
<li>主数据库的K-V数据存储</li>
<li>散列表对象(hash)</li>
<li>哨兵模式中的主从节点管理</li>
</ul>
<h5 id="（4）压缩列表（重点）"><a href="#（4）压缩列表（重点）" class="headerlink" title="（4）压缩列表（重点）"></a>（4）压缩列表（重点）</h5><p>压缩列表（ziplist）是由一系列特殊编码的连续内存块组成的顺序型数据结构节省内存，<strong>这是一种非常节省内存的结构</strong>。</p>
<p>它是一个字节数组表头有三个字段zlbytes、zltail和zllen，分别标识列表长度、列表尾的偏移量，以及列表中的entry个数。压缩列表尾还有一个zlend，标识列表结束。每个节点可以保存一个字节数组或一个整数。</p>
<p>zlbytes：压缩列表的字节长度</p>
<p>zltail：压缩列表尾元素相对于压缩列表起始地址的偏移量</p>
<p>zllen：压缩列表的元素个数</p>
<p>entry1…entryX：压缩列表的各个节点</p>
<p>zlend：压缩列表的结尾，占一个字节，恒为0xFF（255）</p>
<p>entryX元素的编码结构：</p>
<ul>
<li>previous_entry_length ：表示前⼀个 entry 的⻓度。 prev_len 有两种取值情况： 1 字节或 5 字节。<br>取值 1 字节时，表示上⼀个 entry 的⻓度⼩于 254 字节。虽然 1 字节的值能表示的数值范围是 0 到<br>255，但是压缩列表中 zlend 的取值默认是 255，因此，就默认⽤ 255 表示整个压缩列表的结束，<br>其他表示⻓度的地⽅就不能再⽤ 255 这个值了。所以，当上⼀个 entry ⻓度⼩于 254 字节时，<br>prev_len 取值为 1 字节，否则，就取值为 5 字节。  </li>
<li>encoding：标识当前元素的编码1字节</li>
<li>content：数据内容</li>
</ul>
<p>ziplist结构体如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ziplist</span>&lt;</span>T&gt;&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> zlbytes; <span class="comment">//ziplist的长度字节数，包含头部、所有entry和zipend。</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> zloffset;<span class="comment">//从ziplist的头指针到只想最后一个entry的偏移量，用于快速反向查询</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> zllength; <span class="comment">//entry元素个数</span></span><br><span class="line">    T[] entry; <span class="comment">//元素值</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> zlend;<span class="comment">//ziplist结束符，值固定为0xFF</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zlentry</span>&#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> prevrawlensize; <span class="comment">//previous_entry_length字段的⻓度</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> prevrawlen; <span class="comment">//previous_entry_length字段存储的内容</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> lensize; <span class="comment">//encoding字段的⻓度</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> len; <span class="comment">//数据内容⻓度</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> headersize; <span class="comment">//当前元素的⾸部⻓度，即previous_entry_length字段⻓度与 encoding字段⻓度之和。</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> encoding; <span class="comment">//数据类型</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> *p; <span class="comment">//当前元素⾸地址</span></span><br><span class="line">&#125;zlentry</span><br></pre></td></tr></table></figure>

<p>应用场景：</p>
<p><strong>sorted-set和hash元素个数少且是小整数或短字符串（直接使用）</strong></p>
<p>list用快速链表(quicklist)数据结构存储，而快速链表是双向列表与压缩列表的组合。(间接使用)</p>
<p>注意：</p>
<p>不管是使⽤Hash还是Sorted Set，当采⽤ziplist⽅式存储时，虽然可以节省内存空间，但是<strong>在查询指定元素时，都要遍历整个ziplist</strong>，找到指定的元素。所以使⽤ziplist方式存储时，虽然可以利⽤CPU高速缓存，但也不适合存储过多的数据（hash-max-ziplist-entries和zset-max-ziplist-entries不宜设置过大），否则查询性能就会下降比较厉害。整体来说，这样的方案就是<strong>使用稀疏索引的思想 时间换空间</strong> ，我们需要权衡使用。  </p>
<p>使用ziplist存储，尽量存储int数据</p>
<ul>
<li>针对要存储的数据，会尽量选择占用内存小的方式存储（整数比字符串存储时占用内存更小）</li>
<li>ziplist每个元素紧凑排列，并且每个元素存储了上一个元素的长度，所以当修改其中一个元素超过一定大小时，会引发多个元素的<strong>级联调整</strong>。引发性能问题，需要注意。（后续redis版本提供了个listpack的数据结构解决这个问题）</li>
</ul>
<h5 id="5-整数集合"><a href="#5-整数集合" class="headerlink" title="(5)整数集合"></a>(5)整数集合</h5><p>整数集合(intset)是一个有序的(整数升序)、存储整数的连续存储结构。</p>
<p>当Redis集合类型的元素都是整数并且都处在64位有符号整数范围内(2^64),使用该结构体存储。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">192.168.200.132:0&gt;sadd set:001 1 3 5 6 2</span><br><span class="line">&quot;5&quot;</span><br><span class="line">192.168.200.132:0&gt;object encoding set:001</span><br><span class="line">&quot;intset&quot;</span><br><span class="line">192.168.200.132:0&gt;sadd set:004 1 100000000000000000000000000 999999999</span><br><span class="line">&quot;3&quot;</span><br><span class="line">192.168.200.132:0&gt;object encoding set:004</span><br><span class="line">&quot;hashtable&quot;</span><br></pre></td></tr></table></figure>

<p>intset结构图：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">intset</span>&#123;</span></span><br><span class="line">    <span class="comment">//编码方式</span></span><br><span class="line">    <span class="type">uint32_t</span> encoding;</span><br><span class="line">    <span class="comment">//集合包含的元素数量</span></span><br><span class="line">    <span class="type">uint32_t</span> length;</span><br><span class="line">    <span class="comment">//保存元素的数组</span></span><br><span class="line">    <span class="type">int8_t</span> contents[];</span><br><span class="line">&#125;intset;</span><br></pre></td></tr></table></figure>

<p>应用场景：</p>
<p>可以保存类型为int16_t、int32_t或者int64_t的整数值，并且保证集合中不会出现重复元素。</p>
<p>快速列表（重要）</p>
<p>列表的底层实现。（在Redis3.2之前，Redis采用双向链表(adlist)和压缩列表(ziplist)实现。）在Redis3.2以后结合adlist和ziplist的优势Redis设计出了quicklist</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">192.168.200.132:0&gt;lpush list:001 1 2 5 4 3</span><br><span class="line">&quot;5&quot;</span><br><span class="line">192.168.200.132:0&gt;object encoding list:001</span><br><span class="line">&quot;quicklist&quot;</span><br></pre></td></tr></table></figure>

<h5 id="6-双向链表-adlist"><a href="#6-双向链表-adlist" class="headerlink" title="(6)双向链表(adlist)"></a>(6)双向链表(adlist)</h5><p><img src="/images/Redis/8.jpg" alt="双向列表"></p>
<p>优势：</p>
<ul>
<li><p>双向：链表具有前置节点和后置节点的引用，获取这两个节点时间复杂度都为O(1)。</p>
</li>
<li><p>普通链表(单链表)：节点类保留下⼀节点的引用。链表类只保留头节点的引用，只能从头节点插入删除</p>
</li>
<li><p>无环：表头节点的 prev 指针和表尾节点的 next 指针都指向 NULL,对链表的访问都是以 NULL 结束。</p>
<p>环状：头的前一个节点指向尾节点</p>
</li>
<li><p>带链表长度计数器：通过 len 属性获取链表⻓度的时间复杂度为 O(1)。</p>
</li>
<li><p>多态：链表节点使⽤ void* 指针来保存节点值，可以保存各种不同类型的值。</p>
</li>
</ul>
<h5 id="7-快速列表"><a href="#7-快速列表" class="headerlink" title="(7)快速列表"></a>(7)快速列表</h5><p>quicklist是一个双向链表，链表中每个节点是一个ziplist结构。quicklist中的每个节点ziplist都能够存储多个数据元素。</p>
<p>quicklist结构定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">quicklist</span>&#123;</span></span><br><span class="line">	quciklistNode *head;	<span class="comment">//指向quicklist的头部</span></span><br><span class="line">    quicklistNode *tail;	<span class="comment">//指向quicklist的尾部</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> count;	<span class="comment">//列表中所有数据项的个数总和</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> len;		<span class="comment">//quicklist节点的个数，即ziplist的个数</span></span><br><span class="line">    <span class="type">int</span> fill : <span class="number">16</span>;			<span class="comment">//ziplist大小限定，由list-max-ziplist-size给定</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> compress : <span class="number">16</span>; <span class="comment">//节点压缩深度设置，由list-compress-depth给定(Redis设定)</span></span><br><span class="line">&#125;quicklist;</span><br></pre></td></tr></table></figure>

<p>quicklistNode的结构定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">quicklistNode</span>&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">quicklistNode</span> *<span class="title">prev</span>;</span> <span class="comment">// 指向上⼀个ziplist节点</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">quicklistNode</span> *<span class="title">next</span>;</span> <span class="comment">// 指向下⼀个ziplist节点</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> *zl; <span class="comment">// 数据指针，如果没有被压缩，就指向ziplist结构，反之指向 quicklistLZF结构</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> sz; <span class="comment">// 表示指向ziplist结构的总⻓度(内存占⽤⻓度)</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> count : <span class="number">16</span>; <span class="comment">// 表示ziplist中的数据项个数</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> encoding : <span class="number">2</span>; <span class="comment">// 编码⽅式， 1--ziplist， 2--quicklistLZF</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> container : <span class="number">2</span>; <span class="comment">// 预留字段，存放数据的⽅式， 1--NONE， 2--ziplist</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> recompress : <span class="number">1</span>; <span class="comment">// 解压标记，当查看⼀个被压缩的数据时，需要暂时解压，标记此参数为 1，之后再重新进⾏压缩</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> attempted_compress : <span class="number">1</span>; <span class="comment">// 测试相关</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> extra : <span class="number">10</span>; <span class="comment">// 扩展字段，暂时没⽤</span></span><br><span class="line">&#125;quicklistNode</span><br></pre></td></tr></table></figure>

<p><strong>数据压缩</strong></p>
<p>quicklist每个节点的实际数据存储结构为ziplist ，这种结构的优势在于节省存储空间。为了进⼀步降低ziplist的存储空间，还可以对ziplist进⾏压缩。 Redis采⽤的压缩算法是LZF。其基本思想是：数据与前面重复的记录重复位置及⻓度，不重复的记录原始数据。<br>压缩过后的数据可以分成多个⽚段，每个⽚段有两个部分：解释字段和数据字段。 quicklistLZF的结构体如下：  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">quicklistLZF</span>&#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> sz;<span class="comment">//LZF压缩后占用的字节数</span></span><br><span class="line">    <span class="type">char</span> compressed[];<span class="comment">//柔性数组，指向数据部分</span></span><br><span class="line">&#125;quicklistLZF;</span><br></pre></td></tr></table></figure>

<p>应用场景</p>
<p>列表(List)的底层实现、发布与订阅、慢查询、监视器等功能</p>
<h4 id="10种encoding"><a href="#10种encoding" class="headerlink" title="10种encoding"></a>10种encoding</h4><p>encoding表示对象的内部编码，占4位。</p>
<p>Redis通过encoding属性为对象设置不同的编码</p>
<p>对于少的和小的数据，Redis采用小的和压缩的存储方式，体现Redis的灵活性，大大提高了Redis的存储量和执行效率</p>
<h5 id="1-String"><a href="#1-String" class="headerlink" title="(1)String"></a>(1)String</h5><p>int、raw、embstr</p>
<ul>
<li>当保存的是Long类型整数时，RedisObject中的指针就直接赋值为整数数据了，这样就不用额外的指针再指向整数了，节省了指针的空间开销。</li>
<li>当保存的是字符串数据，且字符串小于等于44字节时，RedisObject中的元数据、指针和SDS是一块连续的内存区域，这样就可以避免内存碎片，对cpu cacheline也比较友好。embstr编码</li>
<li>当字符串大于44字节时，SDS的数据量就开始变多了，Redis不再把SDS和RedisObject布局在一起了，而是会给SDS分配独立的空间，并用指针指向SDS结构。这种布局方式称为raw编码模式</li>
</ul>
<h6 id="int"><a href="#int" class="headerlink" title="int"></a>int</h6><p>REDIS_ENCODING_INT(int类型的整数)</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">192.168.200.132:0&gt;set n1 123</span><br><span class="line">&quot;OK&quot;</span><br><span class="line">192.168.200.132:0&gt;object encoding n1</span><br><span class="line">&quot;int&quot;</span><br></pre></td></tr></table></figure>

<h6 id="embstr"><a href="#embstr" class="headerlink" title="embstr"></a>embstr</h6><p>REDIS_ENCODING_EMBSTR(编码的简单动态字符串)</p>
<p>小字符串 长度小于44字节</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">192.168.200.132:0&gt;set n1 abc</span><br><span class="line">&quot;OK&quot;</span><br><span class="line">192.168.200.132:0&gt;object encoding n1</span><br><span class="line">&quot;embstr&quot;</span><br></pre></td></tr></table></figure>

<h6 id="raw"><a href="#raw" class="headerlink" title="raw"></a>raw</h6><p>REDIS_ENCODING_RAW(简单动态字符串)</p>
<p>大字符串 长度大于44个字节</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">192.168.200.132:0&gt;set n1 aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa</span><br><span class="line">&quot;OK&quot;</span><br><span class="line">192.168.200.132:0&gt;object encoding n1</span><br><span class="line">&quot;raw&quot;</span><br></pre></td></tr></table></figure>



<h5 id="2-list"><a href="#2-list" class="headerlink" title="(2)list"></a>(2)list</h5><p>列表的编码是quicklist。</p>
<p>REDIS_ENCODING_QUICKLIST(快速列表)</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">192.168.200.132:0&gt;lpush list:001 1 2 3 4 6 5</span><br><span class="line">&quot;11&quot;</span><br><span class="line">192.168.200.132:0&gt;object encoding list:001</span><br><span class="line">&quot;quicklist&quot;</span><br></pre></td></tr></table></figure>

<h5 id="3-hash"><a href="#3-hash" class="headerlink" title="(3)hash"></a>(3)hash</h5><p>散列的编码是字典和压缩列表</p>
<h6 id="dict"><a href="#dict" class="headerlink" title="dict"></a>dict</h6><p>REDIS_ENCODING_HT(字典)</p>
<p>当散列表元素的个数⽐较多或元素不是⼩整数或短字符串时。  </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">192.168.200.132:0&gt;hmset user:003 username11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111 222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222</span><br><span class="line">&quot;OK&quot;</span><br><span class="line">192.168.200.132:0&gt;object encoding user:003</span><br><span class="line">&quot;hashtable&quot;</span><br></pre></td></tr></table></figure>

<h6 id="ziplist"><a href="#ziplist" class="headerlink" title="ziplist"></a>ziplist</h6><p>REDIS_ENCODING_ZIPLIST (压缩列表)<br>当散列表元素的个数⽐较少，且元素都是⼩整数或短字符串时。  </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hmset user:001 username zhangfei password 111 age 23</span><br><span class="line">sex M</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; object encoding user:001</span><br><span class="line">&quot;ziplist&quot;</span><br></pre></td></tr></table></figure>

<h5 id="4-set"><a href="#4-set" class="headerlink" title="(4)set"></a>(4)set</h5><p>整形集合和字典</p>
<h6 id="intset"><a href="#intset" class="headerlink" title="intset"></a>intset</h6><p>REDIS_ENCODING_INTSET(整数集合)</p>
<p>当Redis集合类型的元素都是整数并且都处在64位有符号整数范围内(&lt;18446744073709551616)</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">192.168.200.132:0&gt;sadd set:001 1 3 5 6 2</span><br><span class="line">&quot;5&quot;</span><br><span class="line">192.168.200.132:0&gt;object encoding set:001</span><br><span class="line">&quot;intset&quot;</span><br></pre></td></tr></table></figure>

<h6 id="dict-1"><a href="#dict-1" class="headerlink" title="dict"></a>dict</h6><p>REDIS_ENCODING_HT(字典)</p>
<p>当Redis集合类型元素是非整数或都处在64位有符号整数范围外(&gt;18446744073709551616)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">192.168.200.132:0&gt;sadd set:004 11111111111111111111111111111111111111111 22222222222222222222222222222222222222222222222222222222222222222222222222222222222</span><br><span class="line">&quot;2&quot;</span><br><span class="line">192.168.200.132:0&gt;object encoding set:004</span><br><span class="line">&quot;hashtable&quot;</span><br></pre></td></tr></table></figure>



<h5 id="5-zset"><a href="#5-zset" class="headerlink" title="(5)zset"></a>(5)zset</h5><p>压缩列表和跳跃表+字典</p>
<h6 id="ziplist-1"><a href="#ziplist-1" class="headerlink" title="ziplist"></a>ziplist</h6><p>REDIS_ENCODING_ZIPLIST(压缩列表)</p>
<p>元素个数比较少，且元素都是小整数或短字符串时。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">192.168.200.132:0&gt;zadd hit:1 100 item1 20 item2 45 item3</span><br><span class="line">&quot;3&quot;</span><br><span class="line">192.168.200.132:0&gt;object encoding hit:1</span><br><span class="line">&quot;listpack&quot;</span><br></pre></td></tr></table></figure>

<h6 id="skiplist-dict"><a href="#skiplist-dict" class="headerlink" title="skiplist+dict"></a>skiplist+dict</h6><p>REDIS_ENCODING_SKIPLIST(跳跃表+字典)</p>
<p>当元素的个数比较多或元素不是小整数或短字符串时</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">192.168</span><span class="number">.200</span><span class="number">.132</span>:<span class="number">0</span>&gt;zadd hit:<span class="number">002</span> <span class="number">100</span> item1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111 <span class="number">20</span> item2 <span class="number">45</span> item3</span><br><span class="line"><span class="string">&quot;3&quot;</span></span><br><span class="line"><span class="number">192.168</span><span class="number">.200</span><span class="number">.132</span>:<span class="number">0</span>&gt;object encoding hit:<span class="number">002</span></span><br><span class="line"><span class="string">&quot;skiplist&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="三、Redis原理"><a href="#三、Redis原理" class="headerlink" title="三、Redis原理"></a>三、Redis原理</h2><h3 id="1、Redis持久化"><a href="#1、Redis持久化" class="headerlink" title="1、Redis持久化"></a>1、Redis持久化</h3><h4 id="为什么要持久化"><a href="#为什么要持久化" class="headerlink" title="为什么要持久化"></a>为什么要持久化</h4><p>目的：为了快速的恢复数据而不是为了存储数据</p>
<p>持久化方式：RDB和AOF</p>
<p>注：Redis持久化不保证数据的完整性</p>
<p>当Redis用作DB时，DB数据要完整，所以一定要有一个完整的数据源（文件、mysql）在系统启动时，从这个完整的数据源中将数据load到Redis中</p>
<h4 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h4><p>RDB（Redis DataBase），是redis默认的存储方式，RDB方式是通过快照(snapshotting)完成的。</p>
<p>触发快照的方式</p>
<p>①符合自定义配置的快照规则（在redis.conf中配置）</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">save &quot;&quot; #不使用RDB存储	不能主从</span><br><span class="line"></span><br><span class="line">save 900 1 #表示15分钟(900秒)内至少一个键被更改则进行快照</span><br></pre></td></tr></table></figure>

<p>②执行save或者bgsave命令，save会阻塞在主进程，bgsave不会</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">192.168.200.132:0&gt;bgsave</span><br><span class="line">&quot;Background saving started&quot;</span><br></pre></td></tr></table></figure>

<p>③执行flushall命令</p>
<p>④执行主从复制操作(第一次)</p>
<h5 id="RDB执行流程-原理"><a href="#RDB执行流程-原理" class="headerlink" title="RDB执行流程(原理)"></a>RDB执行流程(原理)</h5><p><img src="/images/Redis/9.png" alt="image-20220921092445189"></p>
<p>①Redis父进程⾸先判断：当前是否在执行save ，或bgsave&#x2F;bgrewriteaof ( aof文件重写命令)的子进<br>程，如果在执行则bgsave命令直接返回。<br>②父进程执行fork (调⽤OS函数复制主进程)操作创建子进程，这个 复制过程中父进程是阻塞的 ，<br>Redis不能执行来自客户端的任何命令。<br>③父进程fork后， bgsave命令返回”Background saving started”信息并不再阻塞父进程，并可以响<br>应其他命令。<br>④子进程创建RDB⽂件，根据父进程内存快照生成临时快照文件，完成后对原有文件进行原子替换。<br>( RDB始终完整)<br>⑤子进程发送信号给父进程表示完成，父进程更新统计信息。<br>⑥父进程fork子进程后，继续工作。 </p>
<h5 id="RDB优缺点"><a href="#RDB优缺点" class="headerlink" title="RDB优缺点"></a>RDB优缺点</h5><ul>
<li>优点</li>
</ul>
<p>RDB是二进制压缩文件，占用空间小，便于传输(传给slaver)</p>
<p>主进程fork子进程，可以最大化Redis性能，主进程不能太大，Redis的数据量不能太大，fork复制过程中主进程阻塞</p>
<ul>
<li>缺点</li>
</ul>
<p>不保证数据完整性，会丢失最后一次快照以后更改的所有数据</p>
<h5 id="场景提问"><a href="#场景提问" class="headerlink" title="场景提问"></a>场景提问</h5><p><strong>快照时可以修改嘛？</strong></p>
<p>Redis会借助操作系统的写时复制技术(Copy-On-Write,COW)，在执行快照的同时，正常处理写操作。</p>
<p>如果主线程也是读数据，那么和bgsave子线程不影响。</p>
<p>如果主线程要修改一块数据，这块数据会被复制一份，生成副本。主线程在这个副本上进行修改，同时bgsave子线程可以继续把原来的数据写入RDB文件。</p>
<p>详细：bgsave实际执⾏过程中，是⼦进程复制了主线程的页表，所以通过页表映射，能读到主线程的原始数<br>据，而当有新数据写⼊或数据修改时，主线程会把新数据或修改后的数据写到⼀个新的物理内存地址<br>上，并修改主线程自己的页表映射。所以， 子进程读到的类似于原始数据的⼀个副本，而主线程也可以<br>正常进行修改。  </p>
<h4 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h4><p>AOF(append only file)是Redis的另一种持久化方式。Redis默认情况下是不开启的。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Redis 将所有对数据库进⾏过写⼊的命令(及其参数) ( RESP)记录到 AOF ⽂件， 以此达到记录数据库状态的目的，</span><br><span class="line">这样当Redis重启后只要按顺序回放这些命令就会恢复到原始状态了。</span><br></pre></td></tr></table></figure>

<p><strong>AOF会记录过程， RDB只管结果</strong>  </p>
<p>AOF功能开启</p>
<p>配置redis.conf</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 可以通过修改redis.conf配置⽂件中的appendonly参数开启</span><br><span class="line">appendonly yes</span><br><span class="line"># AOF⽂件的保存位置和RDB⽂件的位置相同，都是通过dir参数设置的。</span><br><span class="line">dir ./</span><br><span class="line"># 默认的⽂件名是appendonly.aof，可以通过appendfilename参数修改</span><br><span class="line">appendfilename appendonly.aof</span><br></pre></td></tr></table></figure>

<h5 id="AOF原理"><a href="#AOF原理" class="headerlink" title="AOF原理"></a>AOF原理</h5><p><img src="/images/Redis/10.png" alt="写后日志"></p>
<p>日志格式</p>
<p>“set testkey testvalue”</p>
<p>“*3”表示当前命令由三个部分，每部分都是由“$+数字”开头</p>
<p>后面紧跟着具体的命令、键或值。这里，数字表示这部分的命令、键或值一共有多少字节。</p>
<p>例如“$3 set”表示3个字节，就是set命令</p>
<p><img src="/images/Redis/11.png" alt="日志"></p>
<p>AOF文件中存储的是redis的命令，同步命令到AOF文件的整个过程分为三个阶段</p>
<ul>
<li>命令传播：当一个Redis客户端需要执行命令时，通过网络连接，将协议文本发送给Redis服务器。服务器在接到客户端请求之后，会根据协议文本的内容，选择适当的命令函数，并将各个参数从字符串文本转换为Redis字符串对象(StringObject)。每当命令函数成功执行之后，命令参数都会被传播到AOF程序。</li>
<li>缓存追加：当命令被传播到AOF程序之后，程序会根据命令以及命令的参数，将命令从字符串对象转换回原来的协议文本。协议文本生成之后，会被追加到redis.h&#x2F;redisServer结构的aof_buf末尾</li>
<li>文件写入和保存：每当服务器常规任务函数被执行、或者事件处理器被执行时，aof.c&#x2F;flushAppendOnlyFile函数都会被调用，每个函数执行以下两个工作：<ul>
<li>WRITE：根据条件，将aof_buf中的缓存写入到AOF文件</li>
<li>SAVE：根据条件，调用fsync或fdatasync函数，将AOF文件保存到磁盘中</li>
</ul>
</li>
</ul>
<p><strong>AOF保存模式</strong></p>
<p>AOF_FSYNC_NO：不保存</p>
<p>AOF_FSYNC_EVERYSEC：每一秒钟保存一次。(默认)</p>
<p>AOF_FSYNC_ALWAYS：每执行一个命令保存一次。(不推荐)</p>
<ul>
<li><p><strong>不保存</strong></p>
<p>这种模式下，每次调用flushAppendOnlyFile函数，WRITE都会被执行，但SAVE会被略过。</p>
<p>Redis被关闭</p>
<p>AOF功能被关闭</p>
<p>系统的写缓存被刷新</p>
<p>这三种情况下save操作会引起Redis主进程阻塞</p>
</li>
<li><p><strong>每秒钟保存一次（推荐）</strong></p>
<p>save原则上每隔一秒执行一次，因为SAVE操作是由后台子线程(fork)调用的，所以不会引起服务器主进程阻塞。</p>
</li>
<li><p><strong>每执行一个命令保存一次</strong></p>
<p>每执行完一个命令之后，WRITE和SAVE都会被执行</p>
<p>另外，因为SAVE是由Redis主进程执行的，所以在SAVE执行期间，主进程会被阻塞，不能接受命令请求。</p>
</li>
</ul>
<h5 id="AOF重写"><a href="#AOF重写" class="headerlink" title="AOF重写"></a>AOF重写</h5><p>重写机制就是清理无用数据的过程</p>
<blockquote>
<p>重写的时候，根据键值对当前的最新状态，为他生成对应的写入命令。一个键值对在重写日志中只用一条命令即可，在日志恢复时，只用执行这条命令，就可直接完成这个键值对的写入。</p>
</blockquote>
<p>虽然AOF重写，日志文件会缩小，但是，要把整个数据库的最新数据的操作日志都写回磁盘，是一个非常耗时的过程。</p>
<p><strong>重写会不会阻塞主线程？</strong></p>
<p>和AOF日志由主线程写回不同，重写过程是由后台子进程<strong>bgrewriteaof</strong>来完成，为了避免阻塞主线程，导致数据库性能下降。</p>
<p><strong>“一个拷贝，两处日志”</strong></p>
<p>”一个拷贝“</p>
<p>每次执行重写，主线程fork处后台的bgrewriteaof子进程。此时，fork会把主线程的内存拷贝一份给bgrewriteaof子进程，这里包含了数据库最新数据。</p>
<p>“两处日志”</p>
<p>第一处：因为主线程未阻塞，仍然可以处理新来的操作。此时，如果有写操作，第一处日志就是指正在使用的AOF日志，Redis会把这个操作写到它的缓冲区。这样，即使宕机了，这个AOF日志的操作仍然是齐全的，可用于恢复。</p>
<p>第二处：就是指新的AOF重写日志。这个操作也会被写到重写日志的缓冲区。重写日志不会丢失最新操作。等到拷贝数据的所有操作记录重写完成后，重写日志记录的最新操作也会写入新的AOF文件。</p>
<p><img src="/images/Redis/12.png" alt="AOF重写"></p>
<p>触发方式：</p>
<ul>
<li><p>配置触发</p>
<p>redis.conf中配置</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 表示当前aof⽂件⼤⼩超过上⼀次aof⽂件⼤⼩的百分之多少的时候会进⾏重写。如果之前没有</span><br><span class="line">重写过， 以启动时aof⽂件⼤⼩为准</span><br><span class="line">auto-aof-rewrite-percentage 100</span><br><span class="line"># 限制允许重写最⼩aof⽂件⼤⼩，也就是⽂件⼤⼩⼩于64mb的时候，不需要进⾏优化</span><br><span class="line">auto-aof-rewrite-min-size 64mb</span><br></pre></td></tr></table></figure>


</li>
<li><p>执行bgrewriteaof命令</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; bgrewriteaof</span><br><span class="line">Background append only file rewriting started</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="混合持久化"><a href="#混合持久化" class="headerlink" title="混合持久化"></a>混合持久化</h5><p>RDB和AOF各有缺点，Redis4.0开始支持rdb和aof的混合持久化。如果把混合持久化打开，aof rewrite的时候就直接把rdb的内容写到aof文件开头。</p>
<h6 id="1-全量-增量的思想"><a href="#1-全量-增量的思想" class="headerlink" title="(1)全量+增量的思想"></a><strong>(1)全量+增量的思想</strong></h6><p>RDB的头+AOF的身体—&gt;appendonly.aof</p>
<p>开启混合持久化</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aof-use-rdb-preamble yes</span><br></pre></td></tr></table></figure>

<blockquote>
<p>加载时，首先会识别AOF文件是否以REDIS字符串开头，如果是就按照RDB格式加载，加载完RDB后继续按AOF加载剩余部分。</p>
</blockquote>
<h6 id="2-AOF文件的载入与数据还原"><a href="#2-AOF文件的载入与数据还原" class="headerlink" title="(2)AOF文件的载入与数据还原"></a><strong>(2)AOF文件的载入与数据还原</strong></h6><p>Redis读取AOF文件并还原数据库状态的详细步骤：</p>
<ul>
<li><p>创建一个不带网络连接的伪客户端(fake client)</p>
<p>（因为Redis的命令只能在客户端上下文中执行，而载入AOF文件时所使用的命令直接来源于AOF文件而不是网络连接，所以服务器使用了一个没有网络连接的伪客户端来执行AOF文件保存的写命令。伪客户端执行命令的效果和带网络连接的客户端执行命令的效果完全一样。）</p>
</li>
<li><p>从AOF文件中分析并读取出一条写命令</p>
</li>
<li><p>使用伪客户端执行被读出的写命令</p>
</li>
<li><p>一直执行步骤2和步骤3，直到AOF文件中的所有写命令都被处理完毕为止</p>
<p><img src="/images/Redis/13.png" alt="载入过程"></p>
</li>
</ul>
<h6 id="3-RDB与AOF对比"><a href="#3-RDB与AOF对比" class="headerlink" title="(3)RDB与AOF对比"></a><strong>(3)RDB与AOF对比</strong></h6><ul>
<li><p>RDB存某个时刻的数据快照，采用二进制压缩存储，AOF存操作命令，文本存储（混合）</p>
</li>
<li><p>RDB性能高、AOF性能较低</p>
</li>
<li><p>RDB在配置触发状态会丢失最后一次快照以后更改的所有数据，AOF设置为每秒保存一次，最多丢2秒的数据</p>
</li>
<li><p>Redis以主服务器模式运行，RDB不会保存过期键值对数据，Redis以从服务器模式运行，RDB会保存过期键值对，当主服务器向从服务器同步时，再清空键值对。</p>
<p>AOF写入文件时，对过期的key会追加一条del命令，当执行AOF重写时，会忽略过期key和del命令</p>
</li>
</ul>
<h6 id="4-应用场景"><a href="#4-应用场景" class="headerlink" title="(4)应用场景"></a>(4)应用场景</h6><p>内存数据库 rdb+aof 数据不容易丢</p>
<p>有原始数据源：每次启动时都从原始数据源中初始化，则不用开启持久化(数据量较小)</p>
<p>缓存服务器：rdb	一般	性能高</p>
<p>在数据还原时</p>
<p>有rdb+aof 则还原aof，因为RDB会造成文件的丢失，AOF相对数据要完整</p>
<p>只有rdb，则还原rdb</p>
<p>追求高性能：都不开 redis宕机从数据源恢复</p>
<p>字典库：不驱逐，保证数据完整性 不开持久化</p>
<p>用作DB：不能驱逐 数据量小</p>
<p>做缓存 较高性能：开rdb</p>
<p>Redis数据量存储过大，性能突然下降，fork时间过长阻塞主进程则只开启AOF</p>
<h3 id="2、缓存淘汰策略"><a href="#2、缓存淘汰策略" class="headerlink" title="2、缓存淘汰策略"></a>2、缓存淘汰策略</h3><p>没有必要把所有数据都存储到内存，所有我们需要设置缓存的大小以及淘汰策略。</p>
<h4 id="最大内存"><a href="#最大内存" class="headerlink" title="最大内存"></a>最大内存</h4><p>“八二原理”：20%的数据贡献了80%的访问。</p>
<p>剩余80%的数据在访问量上形成长长的尾巴，”长尾效应“</p>
<p>当80%的数据反而贡献了更多的访问量，”重尾效应“</p>
<blockquote>
<p>建议缓存容量设置为总数据量的15%到30%，兼顾访问性能和内存空间开销</p>
</blockquote>
<p>maxmemory：默认为0，不限制</p>
<p>设置：</p>
<p>在redis.conf中</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">maxmemory 1024mb</span><br></pre></td></tr></table></figure>

<p>命令行设置</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CONFIG GET maxmemory 4gb</span><br></pre></td></tr></table></figure>

<p>获得maxmemory数</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CONFIG GET maxmemory</span><br></pre></td></tr></table></figure>

<h4 id="expire数据结构"><a href="#expire数据结构" class="headerlink" title="expire数据结构"></a>expire数据结构</h4><p>设置一个键的存活时间(ttl:time to live)，过了这段时间，该键就会自动被删除</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">192.168.200.132:0&gt;expire name 2 #2秒失效</span><br><span class="line">&quot;0&quot;</span><br><span class="line">192.168.200.132:0&gt;get name</span><br><span class="line">null</span><br><span class="line">192.168.200.132:0&gt;set name zhangfei</span><br><span class="line">&quot;OK&quot;</span><br><span class="line">192.168.200.132:0&gt;ttl name #永久</span><br><span class="line">&quot;-1&quot;</span><br><span class="line">192.168.200.132:0&gt;expire name 30 #30秒失效</span><br><span class="line">&quot;1&quot;</span><br><span class="line">192.168.200.132:0&gt;ttl name #还有19秒失效</span><br><span class="line">&quot;19&quot;</span><br><span class="line">192.168.200.132:0&gt;ttl name #失效</span><br><span class="line">&quot;-2&quot;</span><br></pre></td></tr></table></figure>

<p><strong>expire原理</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisDb</span>&#123;</span></span><br><span class="line">	dict *dict;	-- key-&gt;Value</span><br><span class="line">    dict *expires;	--key-&gt;ttl 维护所有有ttl的key</span><br><span class="line">    dict *blocking_keys;</span><br><span class="line">    dict *ready_keys;</span><br><span class="line">    dict *watched_keys;</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">&#125;redisDb;</span><br></pre></td></tr></table></figure>

<p>dict用于维护一个Redis数据库中包含的所有Key-Value键值对，expires则用于维护一个Redis数据库中设置失效时间的键(即key与失效时间的映射)。</p>
<blockquote>
<p>设置了失效时间的key和具体的失效时间全部都维护在expires这个字典表中。</p>
</blockquote>
<h4 id="删除策略"><a href="#删除策略" class="headerlink" title="删除策略"></a>删除策略</h4><p>Redis的数据删除有定时删除、惰性删除和主动删除三种方式</p>
<p>Redis目前采用惰性删除+主动删除方式</p>
<h5 id="定时删除"><a href="#定时删除" class="headerlink" title="定时删除"></a>定时删除</h5><p>在设置键的过期时间的同时，创建一个定时器，让定时器在键的过期时间来临时，立即执行对键的删除操作。</p>
<p>需要创建定时器，而且消耗cpu，一般不推荐使用。</p>
<h5 id="惰性删除"><a href="#惰性删除" class="headerlink" title="惰性删除"></a>惰性删除</h5><p>在key被访问时如果发现它已经失效，那么就删除它。</p>
<p>expireIfNeeded函数：读取数据之前西安检查一下它有没有失效，如果失效了就删除它。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">expireIfNeeded</span><span class="params">(redisDb *db,robj *key)</span>&#123;</span><br><span class="line">	<span class="comment">//获取主键的失效时间 get当前时间-创建时间&gt;ttl</span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> when = getExpire(db,key);</span><br><span class="line">	<span class="comment">//假如失效时间为负数，说明该主键未设置失效时间（失效时间默认为-1），直接返回0</span></span><br><span class="line">    <span class="keyword">if</span> (when &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//假如Redis服务器正在从RDB⽂件中加载数据，暂时不进⾏失效主键的删除，直接返回0</span></span><br><span class="line">    <span class="keyword">if</span> (server.loading) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//如果以上条件都不满⾜，就将主键的失效时间与当前时间进⾏对⽐，如果发现指定的主键</span></span><br><span class="line">    <span class="comment">//还未失效就直接返回0</span></span><br><span class="line">    <span class="keyword">if</span> (mstime() &lt;= when) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//如果发现主键确实已经失效了，那么⾸先更新关于失效主键的统计个数，然后将该主键失</span></span><br><span class="line">    <span class="comment">//效的信息进⾏⼴播，最后将该主键从数据库中删除</span></span><br><span class="line">    server.stat_expiredkeys++;</span><br><span class="line">    propagateExpire(db,key);</span><br><span class="line">    <span class="keyword">return</span> dbDelete(db,key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="主动删除"><a href="#主动删除" class="headerlink" title="主动删除"></a>主动删除</h5><p><img src="/images/Redis/14.png" alt="内存淘汰策略"></p>
<p>在redis.conf文件中可以配置主动删除策略，默认no-enviction(不删除)</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">maxmemory-policy allkeys-lru</span><br></pre></td></tr></table></figure>

<h6 id="LRU"><a href="#LRU" class="headerlink" title="LRU"></a>LRU</h6><p>Least Recently Used:最近最少使用原则筛选</p>
<p>Redis 默认会记录每个数据的最近⼀次访问的时间戳（由键值对数据结构 RedisObject 中的 lru 字段记录）。  </p>
<blockquote>
<p>第⼀次会随机选出 N 个数据，把它们作为⼀个候选集合。接下来，Redis 会⽐较这 N 个数据的 lru 字段，把 lru 字段值最⼩的数据从缓存中淘汰出去。  </p>
</blockquote>
<p>配置数据格式N</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CONFIG SET maxmemory-samples 100</span><br></pre></td></tr></table></figure>

<blockquote>
<p>当再次淘汰数据时，选取标准：能进⼊候选集合的数据的 lru 字段值必须小于候选集合中最小的 lru 值   </p>
</blockquote>
<p><strong>长度可控的链表</strong></p>
<h6 id="LFU"><a href="#LFU" class="headerlink" title="LFU"></a>LFU</h6><p>LFU(Least frequently used)最不经常使用，如果一个数据在最近一段时间内使用次数很少，那么在将来一段时间被使用的可能性也很小。</p>
<p>volatile-flu</p>
<p>allkeys-flu</p>
<h6 id="random"><a href="#random" class="headerlink" title="random"></a>random</h6><p>随机</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">volatile-random</span><br><span class="line">从已设置过期时间的数据集(server.db[i].expires)中任意选择数据淘汰</span><br><span class="line">allkeys-random</span><br><span class="line">从数据集(server.db[i].dict)中任意选择数据淘汰  </span><br></pre></td></tr></table></figure>

<h6 id="ttl"><a href="#ttl" class="headerlink" title="ttl"></a>ttl</h6><p>volatile-ttl</p>
<p>从已设置过期时间的数据集(server.db[i].expires)中挑选将要过期的数据淘汰redis数据集数据结构中保存了键值对过期时间的表，即redisDb.expires。</p>
<p>TTL数据淘汰机制：从过期时间的表中随机挑选几个键值对，取出其中ttl最小的键值对淘汰。</p>
<h6 id="noenviction"><a href="#noenviction" class="headerlink" title="noenviction"></a>noenviction</h6><p>禁止驱逐数据，不删除 默认</p>
<h4 id="选取策略"><a href="#选取策略" class="headerlink" title="选取策略"></a>选取策略</h4><p>缓存场景：</p>
<ul>
<li>优先使用allkeys-lru可以充分利用LRU的优势，如果数据冷热分离明显，可以尽量把热数据留在内存，提高系统性能</li>
<li>如果访问频率相差不大可以使用allkeys-random</li>
</ul>
<p>内存数据库：</p>
<ul>
<li>不能淘汰，保证数据完整，使⽤noenviction，并且maxmemory 设置到最⼤(物理内存-1G)</li>
</ul>
<h3 id="3、通讯机制"><a href="#3、通讯机制" class="headerlink" title="3、通讯机制"></a>3、通讯机制</h3><h4 id="通讯协议"><a href="#通讯协议" class="headerlink" title="通讯协议"></a>通讯协议</h4><p>Redis是单进程单线程的。</p>
<p>应用系统和Redis通过Redis协议(RESP进行交互)</p>
<p>请求响应模式</p>
<p>Redis协议位于TCP层之上，即客户端和Redis示例保持双工的连接。</p>
<ul>
<li><p><strong>串行的请求响应模式(ping-pong)</strong></p>
<p>客户端与服务端建立长连接</p>
<p>连接通过心跳机制检测(ping-pong)ack应答</p>
<p>telnet和redis-cli发出的命令都属于该种模式</p>
<p>特点：</p>
<ul>
<li>有问有答</li>
<li>耗时在网络传输命令</li>
<li>性能较低</li>
</ul>
</li>
<li><p><strong>双工的请求响应模式(pipeline)</strong></p>
<p>批量请求，批量响应</p>
<p>请求响应交叉进行，不会混淆(TCP双工)</p>
<ul>
<li>pipeline的作用是将一批命令进行打包，然后发送给服务器，服务器执行完按顺序打包返回。</li>
<li>通过pipeline，一次pipeline(n条命令)&#x3D;一次网络时间+n次命令时间</li>
</ul>
<p>通过Jedis可以很方便的使用pipeline</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Jedis</span> <span class="variable">redis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jedis</span>(<span class="string">&quot;192.168.1.111&quot;</span>, <span class="number">6379</span>);</span><br><span class="line">redis.auth(<span class="string">&quot;12345678&quot;</span>);<span class="comment">//授权密码 对应redis.conf的requirepass密码</span></span><br><span class="line"><span class="type">Pipeline</span> <span class="variable">pipe</span> <span class="operator">=</span> jedis.pipelined();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;<span class="number">50000</span>; i++) &#123;</span><br><span class="line">	pipe.set(<span class="string">&quot;key_&quot;</span>+String.valueOf(i),String.valueOf(i));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将封装后的PIPE⼀次性发给redis</span></span><br><span class="line">pipe.sync();</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>原子化的批量请求相应模式(事务)</strong></p>
<p>Redis可以利用事务机制批量执行命令</p>
</li>
<li><p><strong>发布订阅模式(pub&#x2F;sub)</strong></p>
<p>一个客户端触发，多个客户端被动接收，通过服务器中转。</p>
</li>
<li><p><strong>脚本化的批量执行(lua)</strong></p>
<p>客户端向服务器端提交⼀个lua脚本，服务器端执行该脚本。</p>
</li>
</ul>
<h4 id="poll-epoll-select区别-重要"><a href="#poll-epoll-select区别-重要" class="headerlink" title="poll epoll select区别(重要)"></a>poll epoll select区别(重要)</h4><h5 id="socket编程"><a href="#socket编程" class="headerlink" title="socket编程"></a>socket编程</h5><p>使用Socket模型实现网络通信时，需要经过创建Socket、监听端口、处理连接和读写请求等多个步骤</p>
<ul>
<li>创建监听客户端连接的监听套接字(Listening socket)<ul>
<li>调用socket函数，创建一个套接字。主动套接字(Active Socket)</li>
<li>调用bind函数，将主动套接字和当前服务器的ip和监听端口进行绑定</li>
<li>调用listen函数，将主动套接字转换为监听套接字，开始监听客户端连接</li>
</ul>
</li>
<li>运行一个循环流程，在流程中调用accept函数(阻塞函数)，用于接收客户端连接请求。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">listenSocket = socket(); <span class="comment">//调⽤socket系统调⽤创建⼀个主动套接字</span></span><br><span class="line">bind(listenSocket); <span class="comment">//绑定地址和端⼝</span></span><br><span class="line">listen(listenSocket); <span class="comment">//将默认的主动套接字转换为服务器使⽤的被动套接字，也就是监听套接字</span></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123; <span class="comment">//循环监听是否有客户端连接请求到来</span></span><br><span class="line">	connSocket = accept(listenSocket); <span class="comment">//接受客户端连接</span></span><br><span class="line">	recv(connsocket); <span class="comment">//从客户端读取数据，只能同时处理⼀个客户端</span></span><br><span class="line">	<span class="comment">//....业务操作</span></span><br><span class="line">	send(connsocket); <span class="comment">//给客户端返回数据，只能同时处理⼀个客户端</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>Redis执行流程是由一个线程执行</strong></p>
<p><strong>IO多路复用机制</strong>，让程序通过调用多路复用函数，同时监听多个套接字上的请求。这里即可以包括监听套接字上的连接请求，也可以包括已连接套接字上的读写请求。这样当有一个或多个套接字上有请求时，多路复用函数就会返回。</p>
<blockquote>
<p>一个线程可以同时处理多个socket避免io未就绪造成线程的阻塞</p>
</blockquote>
<h5 id="select"><a href="#select" class="headerlink" title="select"></a>select</h5><p>select机制中一个重要函数就是<strong>select函数</strong>。</p>
<p>它的参数包括监听的文件描述符数量_nfds、被监听描述符的三个集合*_writefds、*_writefds和*_exceptfds，以及监听时阻塞等待的超时时长*_timeout。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">select</span> <span class="params">(<span class="type">int</span> __nfds, fd_set *__readfds, fd_set *__writefds, fd_set *__exceptfds, <span class="keyword">struct</span> timeval *__timeout)</span></span><br></pre></td></tr></table></figure>

<p>select函数的三个集合，表示监听的三类事件，读数据事件(_readfds集合)、写数据事件(_writefds集合)、异常事件(_exceptfds集合)</p>
<p>fd_set结构体主要定义部分。_fd_mask类型是long int类型的别名，FD_SETSIZE和_NFDBITS这两个宏定义的大小默认为1024和32。</p>
<p>fd_set主要定义部分如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    …</span><br><span class="line">    __fd_mask __fds_bits[__FD_SETSIZE / __NFDBITS];</span><br><span class="line">    …</span><br><span class="line">&#125; fd_set</span><br></pre></td></tr></table></figure>

<p>fd_set结构体的定义，其实就是⼀个long int类型的数组，该数组中⼀共有32个元素（1024&#x2F;32&#x3D;32），每个元素是32位（long int类型的大小），而每⼀位可以用来表示⼀个文件描述符的状态。 select函数对每⼀个描述符集合，都可以监听1024个描述符。（使用位运算）  </p>
<p>代码调用流程：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> sock_fd,conn_fd; <span class="comment">//监听套接字和已连接套接字的变量</span></span><br><span class="line">sock_fd = socket() <span class="comment">//创建套接字</span></span><br><span class="line">bind(sock_fd) <span class="comment">//绑定套接字</span></span><br><span class="line">listen(sock_fd) <span class="comment">//在套接字上进⾏监听，将套接字转为监听套接字</span></span><br><span class="line">    </span><br><span class="line">fd_set rset; <span class="comment">//被监听的描述符集合，关注描述符上的读事件</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> max_fd = sock_fd</span><br><span class="line">    </span><br><span class="line"><span class="comment">//初始化rset数组，使⽤FD_ZERO宏设置每个元素为0</span></span><br><span class="line">FD_ZERO(&amp;rset);</span><br><span class="line"><span class="comment">//使⽤FD_SET宏设置rset数组中位置为sock_fd的⽂件描述符为1，表示需要监听该⽂件描述符</span></span><br><span class="line">FD_SET(sock_fd,&amp;rset);</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置超时时间</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">timeout</span>;</span></span><br><span class="line">timeout.tv_sec = <span class="number">3</span>;</span><br><span class="line">timeout.tv_usec = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">	<span class="comment">//调⽤select函数，检测rset数组保存的⽂件描述符是否已有读事件就绪，返回就绪的⽂件描述符个数</span></span><br><span class="line">    n = select(max_fd+<span class="number">1</span>, &amp;rset, <span class="literal">NULL</span>, <span class="literal">NULL</span>, &amp;timeout);</span><br><span class="line">    <span class="comment">//调⽤FD_ISSET宏，在rset数组中检测sock_fd对应的⽂件描述符是否就绪</span></span><br><span class="line">    <span class="keyword">if</span> (FD_ISSET(sock_fd, &amp;rset)) &#123;</span><br><span class="line">        <span class="comment">//如果sock_fd已经就绪，表明已有客户端连接；调⽤accept函数建⽴连接</span></span><br><span class="line">        conn_fd = accept();</span><br><span class="line">        <span class="comment">//设置rset数组中位置为conn_fd的⽂件描述符为1，表示需要监听该⽂件描述符</span></span><br><span class="line">        FD_SET(conn_fd, &amp;rset);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//依次检查已连接套接字的⽂件描述符</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; maxfd; i++) &#123;</span><br><span class="line">        <span class="comment">//调⽤FD_ISSET宏，在rset数组中检测⽂件描述符是否就绪</span></span><br><span class="line">        <span class="keyword">if</span> (FD_ISSET(i, &amp;rset)) &#123;</span><br><span class="line">        <span class="comment">//有数据可读，进⾏读数据处理</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>select函数存在两个设计上的不足：</p>
<ul>
<li>select函数对单个进程能监听的文件描述符数量是有限制的，它能监听的文件描述符个数由_FD_SETSIZE决定，默认值1024</li>
<li>当select函数返回后，我们需要遍历描述符集合，才能找到具体是哪些描述符就绪了。这个遍历过程会产生一定开销，降低程序性能。</li>
</ul>
<p>为了解决select函数受限于1024个文件描述符的不足， poll函数对此做了改进。  </p>
<h5 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h5><p>poll机制主要函数是poll函数，原型定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">poll</span> <span class="params">(<span class="keyword">struct</span> pollfd *__fds, <span class="type">nfds_t</span> __nfds, <span class="type">int</span> __timeout)</span>;</span><br></pre></td></tr></table></figure>

<p>*_fds是pollfd结构体数组,_nfds是fds数组的元素个数，而_timeout表示poll函数阻塞的超时时间</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span>&#123;</span></span><br><span class="line">	<span class="type">int</span> fd;		<span class="comment">//进行监听的文件描述符</span></span><br><span class="line">    <span class="type">short</span> <span class="type">int</span> events;	<span class="comment">//要监听的事件类型</span></span><br><span class="line">    <span class="type">short</span> <span class="type">int</span> revents;	<span class="comment">//实际发生的事件类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>pollfd结构体中要监听和实际发生的事件类型</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> POLLRDNORM 0x040	<span class="comment">//可读时间</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> POLLWRNORM 0x100	<span class="comment">//可写事件</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> POLLERR		0x008	<span class="comment">//错误事件</span></span></span><br></pre></td></tr></table></figure>

<p>poll函数完成网络通信三步：</p>
<ul>
<li>第一步，创建pollfd数组和监听套接字，并进行绑定;</li>
<li>第二步，将监听套接字加入pollfd数组，并设置其监听读事件，也就是客户端的连接请求；</li>
<li>第三步，循环调用poll函数，检测pollfd数组中是否有就绪的文件描述符<ul>
<li>如果是连接套接字就绪，这表明有客户端连接，可以调用accept接收连接，并创建已连接套接字，并将其加入pollfd数组，并监听读事件。</li>
<li>如果是已连接套接字就绪，表明客户端有读写请求，我们可以调用recv&#x2F;send函数处理读写请求</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> sock_fd,conn_fd; <span class="comment">//监听套接字和已连接套接字的变量</span></span><br><span class="line">sock_fd = socket() <span class="comment">//创建套接字</span></span><br><span class="line">bind(sock_fd) <span class="comment">//绑定套接字</span></span><br><span class="line">listen(sock_fd) <span class="comment">//在套接字上进⾏监听，将套接字转为监听套接字</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//poll函数可以监听的⽂件描述符数量，可以⼤于1024</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_OPEN = 2048</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//pollfd结构体数组，对应⽂件描述符</span></span><br><span class="line"><span class="keyword">struct</span> pollfd client[MAX_OPEN];</span><br><span class="line"></span><br><span class="line"><span class="comment">//将创建的监听套接字加⼊pollfd数组，并监听其可读事件</span></span><br><span class="line">client[<span class="number">0</span>].fd = sock_fd;</span><br><span class="line">client[<span class="number">0</span>].events = POLLRDNORM;</span><br><span class="line">maxfd = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化client数组其他元素为-1</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; MAX_OPEN; i++)</span><br><span class="line">	client[i].fd = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">	<span class="comment">//调⽤poll函数，检测client数组⾥的⽂件描述符是否有就绪的，返回就绪的⽂件描述符个数</span></span><br><span class="line">	n = poll(client, maxfd+<span class="number">1</span>, &amp;timeout);</span><br><span class="line">	<span class="comment">//如果监听套件字的⽂件描述符有可读事件，则进⾏处理</span></span><br><span class="line">	<span class="keyword">if</span> (client[<span class="number">0</span>].revents &amp; POLLRDNORM) &#123;</span><br><span class="line">		<span class="comment">//有客户端连接；调⽤accept函数建⽴连接</span></span><br><span class="line">		conn_fd = accept();</span><br><span class="line">        </span><br><span class="line">		<span class="comment">//保存已建⽴连接套接字</span></span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; MAX_OPEN; i++)&#123;</span><br><span class="line">			<span class="keyword">if</span> (client[i].fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">				client[i].fd = conn_fd; <span class="comment">//将已建⽴连接的⽂件描述符保存到client数组</span></span><br><span class="line">				client[i].events = POLLRDNORM; <span class="comment">//设置该⽂件描述符监听可读事件</span></span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		maxfd = i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//依次检查已连接套接字的⽂件描述符</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; MAX_OPEN; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (client[i].revents &amp; (POLLRDNORM | POLLERR)) &#123;</span><br><span class="line">		<span class="comment">//有数据可读或发⽣错误，进⾏读数据处理或错误处理</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>与select相比，它允许一次监听超过1024个文件描述符，调用了poll函数后，仍需要遍历每个文件描述符，检测描述符是否就绪，再进行处理。</p>
<p>有没有方法避免遍历每个描述符？epoll机制</p>
<h5 id="epoll-重点"><a href="#epoll-重点" class="headerlink" title="epoll(重点)"></a>epoll(重点)</h5><p>epoll机制使用epoll_event结构体，来记录待监听的文件描述符及其监听的事件类型的。</p>
<p>epoll_event结构体，其中包含了epoll_data_t联合体变量，以及整数类型的events变量。而events变量会取值使用不同的宏定义值，来表示epoll_data_t变量中的文件描述符所关注的事件类型。</p>
<ul>
<li>EPOLLIN：读事件，表示⽂件描述符对应套接字有数据可读。</li>
<li>EPOLLOUT：写事件，表示⽂件描述符对应套接字有数据要写。</li>
<li>EPOLLERR：错误事件，表示⽂件描述符对于套接字出错。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span> <span class="title">epoll_data</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	...</span><br><span class="line">	<span class="type">int</span> fd; <span class="comment">//记录⽂件描述符</span></span><br><span class="line">	...</span><br><span class="line">&#125; <span class="type">epoll_data_t</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">uint32_t</span> events; <span class="comment">//epoll监听的事件类型</span></span><br><span class="line">	<span class="type">epoll_data_t</span> data; <span class="comment">//应⽤程序数据</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在select或者poll函数时，创建好文件描述符集合或pollfd数组后，就可以往数组中添加我们需要监听的文件描述符。</p>
<p>对于epoll机制来说，我们需要先调用epoll_create函数，创建一个epoll实例。这个epoll实例内部维护了两个结构，分别是记录要监听的<strong>文件描述符和已经就绪的文件描述符</strong>，对于已经就绪的文件描述符，会被返回给用户程序进行处理。</p>
<p>所以在使用epoll机制时，不需要遍历查询哪些文件描述符已就绪。</p>
<blockquote>
<p>创建epoll实例后，需要再使用epoll_ctl函数，给被监听的文件描述符添加监听事件类型，以及使用epoll_wait函数获取就绪的文件描述符。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">epoll_create</span><span class="params">(<span class="type">int</span> size)</span></span><br></pre></td></tr></table></figure>



<blockquote>
<p>创建⼀个epoll的句柄。⾃从linux2.6.8之后， size参数是被忽略的。需要注意的是，当创建好epoll句柄后，它就是会占⽤⼀个fd值，在linux下如果查看&#x2F;proc&#x2F;进程id&#x2F;fd&#x2F;，是能够看到这个fd的，所以在使⽤完epoll后，必须调⽤close()关闭，否则可能导致fd被耗尽。  </p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">epoll_ctl</span><span class="params">(<span class="type">int</span> epfd, <span class="type">int</span> op, <span class="type">int</span> fd, <span class="keyword">struct</span> epoll_event *event)</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>poll的事件注册函数，它不同于select()是在监听事件时告诉内核要监听什么类型的事件，⽽是在这⾥先注册要监听的事件类型。<br>第⼀个参数是epoll_create()的返回值。<br>第⼆个参数表示动作，⽤三个宏来表示：<br>EPOLL_CTL_ADD：注册新的fd到epfd中；<br>EPOLL_CTL_MOD：修改已经注册的fd的监听事件；<br>EPOLL_CTL_DEL：从epfd中删除⼀个fd；<br>第三个参数是需要监听的fd。<br>第四个参数是告诉内核需要监听什么事  </p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">epoll_wait</span><span class="params">(<span class="type">int</span> epfd, <span class="keyword">struct</span> epoll_event * events, <span class="type">int</span> maxevents, <span class="type">int</span> timeout)</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>等待内核返回的可读写事件，最多返回maxevents个事件。</p>
</blockquote>
<p>epoll网络通信流程：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> sock_fd,conn_fd; <span class="comment">//监听套接字和已连接套接字的变量</span></span><br><span class="line">sock_fd = socket() <span class="comment">//创建套接字</span></span><br><span class="line">bind(sock_fd) <span class="comment">//绑定套接字</span></span><br><span class="line">listen(sock_fd) <span class="comment">//在套接字上进⾏监听，将套接字转为监听套接字</span></span><br><span class="line"></span><br><span class="line">epfd = epoll_create(EPOLL_SIZE); <span class="comment">//创建epoll实例，</span></span><br><span class="line"><span class="comment">//创建epoll_event结构体数组，保存套接字对应⽂件描述符和监听事件类型</span></span><br><span class="line">ep_events = (epoll_event*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(epoll_event) * EPOLL_SIZE);</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建epoll_event变量</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">ee</span></span></span><br><span class="line"><span class="class">//监听读事件</span></span><br><span class="line"><span class="class"><span class="title">ee</span>.<span class="title">events</span> =</span> EPOLLIN;</span><br><span class="line"><span class="comment">//监听的⽂件描述符是刚创建的监听套接字</span></span><br><span class="line">ee.data.fd = sock_fd;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将监听套接字加⼊到监听列表中</span></span><br><span class="line">epoll_ctl(epfd, EPOLL_CTL_ADD, sock_fd, &amp;ee);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">	<span class="comment">//等待返回已经就绪的描述符</span></span><br><span class="line">	n = epoll_wait(epfd, ep_events, EPOLL_SIZE, <span class="number">-1</span>);</span><br><span class="line">	<span class="comment">//遍历所有就绪的描述符</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">		<span class="comment">//如果是监听套接字描述符就绪，表明有⼀个新客户端连接到来</span></span><br><span class="line">		<span class="keyword">if</span> (ep_events[i].data.fd == sock_fd) &#123;</span><br><span class="line">			conn_fd = accept(sock_fd); <span class="comment">//调⽤accept()建⽴连接</span></span><br><span class="line">			ee.events = EPOLLIN;</span><br><span class="line">			ee.data.fd = conn_fd;</span><br><span class="line">			<span class="comment">//添加对新创建的已连接套接字描述符的监听，监听后续在已连接套接字上的读事件</span></span><br><span class="line">			epoll_ctl(epfd, EPOLL_CTL_ADD, conn_fd, &amp;ee);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123; <span class="comment">//如果是已连接套接字描述符就绪，则可以读数据</span></span><br><span class="line">		...<span class="comment">//读取数据并处理</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<p><img src="/images/Redis/15.png" alt="总结"></p>
<h4 id="Reactor模型"><a href="#Reactor模型" class="headerlink" title="Reactor模型"></a>Reactor模型</h4> 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/redis/" rel="tag">redis</a></li></ul>

    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-面经手册"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/08/19/%E9%9D%A2%E7%BB%8F%E6%89%8B%E5%86%8C/"
    >面经手册总结</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/08/19/%E9%9D%A2%E7%BB%8F%E6%89%8B%E5%86%8C/" class="article-date">
  <time datetime="2022-08-19T07:15:25.000Z" itemprop="datePublished">2022-08-19</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E9%9D%A2%E7%BB%8F/">面经</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="HashMap源码分析（上）"><a href="#HashMap源码分析（上）" class="headerlink" title="HashMap源码分析（上）"></a>HashMap源码分析（上）</h1><h2 id="一、散列表实现"><a href="#一、散列表实现" class="headerlink" title="一、散列表实现"></a>一、散列表实现</h2><p>计算出存储对象的hashcode，</p>
<p>计算得出的索引位置就是存储在链表中的位置</p>
<h2 id="二、扰动函数"><a href="#二、扰动函数" class="headerlink" title="二、扰动函数"></a>二、扰动函数</h2><p>公式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">        <span class="type">int</span> h;</span><br><span class="line">        <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>hashcode取值范围[-2147483648, 2147483647]  </p>
<p>因为hashcode取值范围太大，不可能新建数组大小也这么大，所以需要扰动函数</p>
<table>
<thead>
<tr>
<th>名</th>
<th>运算值</th>
<th>运算过程</th>
</tr>
</thead>
<tbody><tr>
<td>梁哥的hashcode</td>
<td>1100  1111110010000100</td>
<td>哈希值</td>
</tr>
<tr>
<td>hashcode &gt;&gt;&gt; 16</td>
<td>0000000000001100</td>
<td>右移16位</td>
</tr>
<tr>
<td>“梁哥”.hashCode^(hashcode &gt;&gt;&gt; 16)</td>
<td>0000000000001000</td>
<td>异或高低位</td>
</tr>
<tr>
<td>(“梁哥”.hashCode^(hashcode &gt;&gt;&gt; 16))&amp;7(数组长度-1)</td>
<td>0000</td>
<td>与运算下表</td>
</tr>
</tbody></table>
<p>目的：增加随机性，减少碰撞</p>
<h2 id="三、初始化容量"><a href="#三、初始化容量" class="headerlink" title="三、初始化容量"></a>三、初始化容量</h2><p>计算阈值大小的方法</p>
<p>寻找大于容量的2的倍数最小值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">tableSizeFor</span><span class="params">(<span class="type">int</span> cap)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> cap - <span class="number">1</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">        <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>例如初始容量17</p>
<table>
<thead>
<tr>
<th>17-1</th>
<th>0 0 0 1 0 0 0 0</th>
</tr>
</thead>
<tbody><tr>
<td>n |&#x3D; n &gt;&gt;&gt; 1;</td>
<td>0 0 0 1 1 0 0 0</td>
</tr>
<tr>
<td>n |&#x3D; n &gt;&gt;&gt; 2;</td>
<td>0 0 0 1 1 1 0 0</td>
</tr>
<tr>
<td>n | &#x3D; n &gt;&gt;&gt; 4;</td>
<td>0 0 0 1 1 1 1 0</td>
</tr>
<tr>
<td>n | &#x3D; n &gt;&gt;&gt; 8;</td>
<td>0 0 0 1 1 1 1 1</td>
</tr>
<tr>
<td>n | &#x3D; n &gt;&gt;&gt; 16;</td>
<td>0 0 0 1 1 1 1 1(32)</td>
</tr>
</tbody></table>
<h2 id="四、负载因子"><a href="#四、负载因子" class="headerlink" title="四、负载因子"></a>四、负载因子</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">float</span> <span class="variable">DEFAULT_LOAD_FACTOR</span> <span class="operator">=</span> <span class="number">0.75f</span>;</span><br></pre></td></tr></table></figure>

<p>当数组实际数据超过数组容量*负载因子，进行扩容，减少hash碰撞</p>
<h2 id="五、扩容元素拆分"><a href="#五、扩容元素拆分" class="headerlink" title="五、扩容元素拆分"></a>五、扩容元素拆分</h2><p>原哈希值与扩容新增出来的长度 16，进行&amp;运算，如果值等于 0，则下标位置不变。如果不为<br>0，那么新的位置则是原来位置上加 16。  </p>
<h1 id="HashMap-源码分析-下"><a href="#HashMap-源码分析-下" class="headerlink" title="HashMap 源码分析(下)"></a>HashMap 源码分析(下)</h1><h2 id="一、插入"><a href="#一、插入" class="headerlink" title="一、插入"></a>一、插入</h2><h3 id="1、疑问点-amp-考题"><a href="#1、疑问点-amp-考题" class="headerlink" title="1、疑问点&amp;考题"></a>1、疑问点&amp;考题</h3><p>1、如果出现哈希值计算的下标碰撞了怎么办？</p>
<p>2、如果碰撞了是扩容数组还是把值存成链表结构，让一个节点有多个值存放呢？</p>
<p>3、如果存放的数据的链表过长，就失去了散列表的性能了，怎么办呢？</p>
<p>4、如果想解决链表过长，什么时候使用树结构呢，使用哪种树呢？  </p>
<h3 id="2、插入流程和源码分析"><a href="#2、插入流程和源码分析" class="headerlink" title="2、插入流程和源码分析"></a>2、插入流程和源码分析</h3><p><img src="/images/%E9%9D%A2%E7%BB%8F%E6%89%8B%E5%86%8C/hashMap%E6%B5%81%E7%A8%8B.png" alt="插入流程"></p>
<p>数据插入流程</p>
<ul>
<li><p>哈希值的扰动，获取新的哈希值。(key &#x3D;&#x3D; null) ? 0 : (h &#x3D; key.hashCode()) ^ (h &gt;&gt;&gt; 16);</p>
</li>
<li><p>判断tab是否位空或者长度为0，如果是则进行扩容。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((tab = table) == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">    n = (tab = resize()).length;</span><br></pre></td></tr></table></figure>


</li>
<li><p>根据哈希值计算下标，如果对应下标刚好没有存放数据，直接插入，否则需要覆盖。tab[i &#x3D; (n - 1) &amp; hash]</p>
</li>
<li><p>判断tab[i]是否为树节点，否则将链表中插入数据，是则向树中插入节点</p>
</li>
<li><p>如果链表中插入节点时，链表长度大于等于8，则需要把链表转红黑树。treeifyBin(tab,hash);</p>
</li>
<li><p>最后所有元素处理完成后，判断是否超过阈值；threshold，超过则扩容</p>
</li>
<li><p>treeifyBin，链表转树的方法，但不是所有的链表长度为8后都会转树。需要判断存放key值得数组桶长度是否小于64MIN_TREEIFY_CAPACITY。如果小于则需要扩容，扩容后链表上得数据会被拆分散列得相应得桶节点上，也就把链表长度缩短了。</p>
</li>
</ul>
<p><strong>JDK1.8 HashMap的put方法源码如下：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">boolean</span> onlyIfAbsent,</span></span><br><span class="line"><span class="params">                   <span class="type">boolean</span> evict)</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="type">int</span> n, i;</span><br><span class="line">        <span class="comment">//tab为本地table数组，n为数组长度</span></span><br><span class="line">    	<span class="comment">//如果数组为空，或长度为0进行初始化</span></span><br><span class="line">        <span class="keyword">if</span> ((tab = table) == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            n = (tab = resize()).length;</span><br><span class="line">    	<span class="comment">//i为哈希值进行扰乱后的数组位置，p指向存储在数组中的node节点</span></span><br><span class="line">        <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="literal">null</span>)</span><br><span class="line">            <span class="comment">//如果为空，直接new出来</span></span><br><span class="line">            tab[i] = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            Node&lt;K,V&gt; e; K k;</span><br><span class="line">            <span class="comment">//如果p节点key的哈希值和新的hash相同，代表key相等</span></span><br><span class="line">            <span class="comment">//k为p节点的key值，或者两个key都为null，直接覆盖</span></span><br><span class="line">            <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">                ((k = p.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                e = p;</span><br><span class="line">            <span class="comment">//如果桶中的引用类型为TreeNode，则调用红黑树的插入方法</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="built_in">this</span>, tab, hash, key, value);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//遍历链表，并统计长度</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                    <span class="comment">//e为p的链表下一节点</span></span><br><span class="line">                    <span class="comment">//链表中不包含要插入的键值对节点时，则将该节点接在链表的最后</span></span><br><span class="line">                    <span class="keyword">if</span> ((e = p.next) == <span class="literal">null</span>) &#123;</span><br><span class="line">                        p.next = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">                        <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                            treeifyBin(tab, hash);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//如果key相等，跳出</span></span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    p = e;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果e不为，进行值覆盖</span></span><br><span class="line">            <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">                <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> e.value;</span><br><span class="line">                <span class="comment">//onlyIfAbsent表示是否仅在oldValue为null的情况下更新键值对的值</span></span><br><span class="line">                <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="literal">null</span>)</span><br><span class="line">                    e.value = value;</span><br><span class="line">                afterNodeAccess(e);</span><br><span class="line">                <span class="keyword">return</span> oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ++modCount;</span><br><span class="line">    	<span class="comment">//如果/键值对数量超过阈值，进行扩容</span></span><br><span class="line">        <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">            resize();</span><br><span class="line">        afterNodeInsertion(evict);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="3、扩容机制"><a href="#3、扩容机制" class="headerlink" title="3、扩容机制"></a>3、扩容机制</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="comment">//oldCap为旧数组容量</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCap</span> <span class="operator">=</span> (oldTab == <span class="literal">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="comment">//threshold扩容临界值，为要调整的下一个值，容量*负载因子</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">oldThr</span> <span class="operator">=</span> threshold;</span><br><span class="line">    <span class="type">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//如果容量大于0，已经初始化</span></span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//如果容量已经超过最大容量</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//新容量为旧容量两倍，如果新容量小于最大容量，并且大于默认初始化容量，就正确</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果扩容临界值大于0，新的容量为扩容临界值</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果都为0表示，初始化数组</span></span><br><span class="line">    <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">        <span class="comment">//扩容临界值为0，进行初始化，容量为初始化16，扩容临界值为16*0.75</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (<span class="type">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//扩容临界值为0时，初始化为容量乘负载因子</span></span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">float</span> <span class="variable">ft</span> <span class="operator">=</span> (<span class="type">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="type">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (<span class="type">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//扩容临界值为新临界值</span></span><br><span class="line">    threshold = newThr;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">/************进行复制************/</span></span><br><span class="line">    <span class="comment">//新建新容器</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span></span><br><span class="line">    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">Node</span>[newCap];</span><br><span class="line">    <span class="comment">//将hashmap全局变量指向新容器</span></span><br><span class="line">    table = newTab;</span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">//遍历旧数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="literal">null</span>) &#123;</span><br><span class="line">                oldTab[j] = <span class="literal">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="literal">null</span>)</span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    <span class="comment">//红黑树拆分</span></span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="built_in">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="literal">null</span>, loTail = <span class="literal">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="literal">null</span>, hiTail = <span class="literal">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="comment">// 这里是链表，如果当前是按照链表存放的，则将链表节点按原顺序进行分组&#123;这里有专门的文章介绍，如何不需要重新计算哈希值进行拆分《HashMap核心知识，扰动函数、负载因子、扩容链表拆分，深度学习》&#125;</span></span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="literal">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="literal">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="literal">null</span>);</span><br><span class="line">                    将分组后的链表放到桶里</span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="literal">null</span>) &#123;</span><br><span class="line">                        loTail.next = <span class="literal">null</span>;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="literal">null</span>) &#123;</span><br><span class="line">                        hiTail.next = <span class="literal">null</span>;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主要步骤：</p>
<ul>
<li>扩容时计算出新的newCap、newThr，这是两个单词的缩写，一个是Capacity ，另一个是阀Threshold（扩容临界值）</li>
<li>newCap用于创新的数组桶 <code>new Node[newCap];</code></li>
<li>随着扩容后，原来那些因为哈希碰撞，存放成链表和红黑树的元素，都需要进行拆分存放到新的位置中。</li>
</ul>
<h3 id="4、链表树化"><a href="#4、链表树化" class="headerlink" title="4、链表树化"></a>4、链表树化</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">treeifyBin</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="type">int</span> hash)</span> &#123;</span><br><span class="line">        <span class="type">int</span> n, index; Node&lt;K,V&gt; e;</span><br><span class="line">    	<span class="comment">//如果数组为空，或者长度小于最小容量，不一定树化还可能只是扩容。主要桶数组容量是否小于64 MIN_TREEIFY_CAPACITY</span></span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="literal">null</span> || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">            resize();</span><br><span class="line">    	<span class="comment">//e为节点位置</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((e = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//又是单词缩写： hd=head（头部），tl=tile（结尾）</span></span><br><span class="line">            TreeNode&lt;K,V&gt; hd = <span class="literal">null</span>, tl = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="comment">//普通节点转为树节点，此时还不是红黑树，还不一定平衡</span></span><br><span class="line">                TreeNode&lt;K,V&gt; p = replacementTreeNode(e, <span class="literal">null</span>);</span><br><span class="line">                <span class="keyword">if</span> (tl == <span class="literal">null</span>)</span><br><span class="line">                    hd = p;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    p.prev = tl;</span><br><span class="line">                    tl.next = p;<span class="comment">//记录原先链表顺序</span></span><br><span class="line">                &#125;</span><br><span class="line">                tl = p;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="literal">null</span>);</span><br><span class="line">            <span class="keyword">if</span> ((tab[index] = hd) != <span class="literal">null</span>)</span><br><span class="line">                <span class="comment">//转红黑树操作，需要循环比较，染色、旋转</span></span><br><span class="line">                hd.treeify(tab);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>链表树化的条件有两点；链表长度大于等于8、桶容量大于64，否则只是扩容，不会树化。</li>
<li>链表树化的过程中是先由链表转换为树节点，此时的树可能不是一颗平衡树。同时在树转换过程中会记录链表的顺序，<code>tl.next = p</code>，这主要方便后续树转链表和拆分更方便。</li>
<li>链表转换成树完成后，在进行红黑树的转换。先简单介绍下，红黑树的转换需要染色和旋转，以及比对大小。在比较元素的大小中，有一个比较有意思的方法，<code>tieBreakOrder</code>加时赛，这主要是因为HashMap没有像TreeMap那样本身就有Comparator的实现</li>
</ol>
<h3 id="5、红黑树转链"><a href="#5、红黑树转链" class="headerlink" title="5、红黑树转链"></a>5、红黑树转链</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title function_">untreeify</span><span class="params">(HashMap&lt;K,V&gt; map)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt; hd = <span class="literal">null</span>, tl = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 遍历TreeNode</span></span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt; q = <span class="built_in">this</span>; q != <span class="literal">null</span>; q = q.next) &#123;</span><br><span class="line">    	<span class="comment">// TreeNode替换Node</span></span><br><span class="line">        Node&lt;K,V&gt; p = map.replacementNode(q, <span class="literal">null</span>);</span><br><span class="line">        <span class="keyword">if</span> (tl == <span class="literal">null</span>)</span><br><span class="line">            hd = p;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            tl.next = p;</span><br><span class="line">        tl = p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> hd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 替换方法</span></span><br><span class="line">Node&lt;K,V&gt; <span class="title function_">replacementNode</span><span class="params">(Node&lt;K,V&gt; p, Node&lt;K,V&gt; next)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(p.hash, p.key, p.value, next);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="二、查找"><a href="#二、查找" class="headerlink" title="二、查找"></a>二、查找</h2><p><img src="/images/%E9%9D%A2%E7%BB%8F%E6%89%8B%E5%86%8C/%E6%9F%A5%E6%89%BE%E6%B5%81%E7%A8%8B%E5%9B%BE.jpg" alt="查找"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="comment">//通过扰动函数极端得出哈希值</span></span><br><span class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="literal">null</span> ? <span class="literal">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title function_">getNode</span><span class="params">(<span class="type">int</span> hash, Object key)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="type">int</span> n; K k;</span><br><span class="line">    <span class="comment">//tab设为数组，first为数组具体节点</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="literal">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">//如果first为key，那么返回</span></span><br><span class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">            ((k = first.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">        <span class="keyword">if</span> ((e = first.next) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//如果是树节点，就用树节点查询方式</span></span><br><span class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">            <span class="comment">//遍历链表</span></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="三、删除"><a href="#三、删除" class="headerlink" title="三、删除"></a>三、删除</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">remove</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">       Node&lt;K,V&gt; e;</span><br><span class="line">       <span class="keyword">return</span> (e = removeNode(hash(key), key, <span class="literal">null</span>, <span class="literal">false</span>, <span class="literal">true</span>)) == <span class="literal">null</span> ?</span><br><span class="line">           <span class="literal">null</span> : e.value;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">final</span> Node&lt;K,V&gt; <span class="title function_">removeNode</span><span class="params">(<span class="type">int</span> hash, Object key, Object value,</span></span><br><span class="line"><span class="params">                              <span class="type">boolean</span> matchValue, <span class="type">boolean</span> movable)</span> &#123;</span><br><span class="line">       Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="type">int</span> n, index;</span><br><span class="line">       <span class="comment">//数组不为空或长度大于0，n数组长度，index下标位置</span></span><br><span class="line">       <span class="keyword">if</span> ((tab = table) != <span class="literal">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">           (p = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="literal">null</span>) &#123;</span><br><span class="line">           Node&lt;K,V&gt; node = <span class="literal">null</span>, e; K k; V v;</span><br><span class="line">           <span class="comment">//找到要删除节点位置，p为数组中位置，node可能为链表中的，或者树中的</span></span><br><span class="line">           <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">               ((k = p.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">               node = p;</span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> ((e = p.next) != <span class="literal">null</span>) &#123;</span><br><span class="line">               <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                   node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);</span><br><span class="line">               <span class="keyword">else</span> &#123;</span><br><span class="line">                   <span class="keyword">do</span> &#123;</span><br><span class="line">                       <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                           ((k = e.key) == key ||</span><br><span class="line">                            (key != <span class="literal">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">                           node = e;<span class="comment">//链表中node为p的下一个</span></span><br><span class="line">                           <span class="keyword">break</span>;</span><br><span class="line">                       &#125;</span><br><span class="line">                       p = e;</span><br><span class="line">                   &#125; <span class="keyword">while</span> ((e = e.next) != <span class="literal">null</span>);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//找到了进行删除</span></span><br><span class="line">           <span class="keyword">if</span> (node != <span class="literal">null</span> &amp;&amp; (!matchValue || (v = node.value) == value ||</span><br><span class="line">                                (value != <span class="literal">null</span> &amp;&amp; value.equals(v)))) &#123;</span><br><span class="line">               <span class="comment">//树节点</span></span><br><span class="line">               <span class="keyword">if</span> (node <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                   ((TreeNode&lt;K,V&gt;)node).removeTreeNode(<span class="built_in">this</span>, tab, movable);</span><br><span class="line">               <span class="comment">//数组中</span></span><br><span class="line">               <span class="keyword">else</span> <span class="keyword">if</span> (node == p)</span><br><span class="line">                   tab[index] = node.next;</span><br><span class="line">               <span class="comment">//链表中</span></span><br><span class="line">               <span class="keyword">else</span></span><br><span class="line">                   p.next = node.next;</span><br><span class="line">               ++modCount;</span><br><span class="line">               --size;</span><br><span class="line">               afterNodeRemoval(node);</span><br><span class="line">               <span class="keyword">return</span> node;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h2 id="四、遍历"><a href="#四、遍历" class="headerlink" title="四、遍历"></a>四、遍历</h2><p>KeySet和EntrySet</p>
<p>KeySet遍历是无序的，但结果是固定的</p>
<p>默认情况下，遍历，按照数组的顺序进行遍历，如果含有链表，则会根据节点位置，遍历该节点的链表，再遍历后续节点。</p>
<p>如果是树节点，会从根节点开始遍历。</p>
<h1 id="平衡树【红黑树的前身】"><a href="#平衡树【红黑树的前身】" class="headerlink" title="平衡树【红黑树的前身】"></a>平衡树【红黑树的前身】</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">看你简历写了解数据结构，可以简单介绍下2-3树吗？</span><br><span class="line">这种树节点有什么特点，与你了解其他的树结构对比下？</span><br><span class="line">你看这个图，向里面插入和删除节点，要怎么操作？</span><br></pre></td></tr></table></figure>

 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java%E5%9F%BA%E7%A1%80/" rel="tag">java基础</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%B0%8F%E5%82%85%E5%93%A5/" rel="tag">小傅哥</a></li></ul>

    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-oss"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/08/15/oss/"
    >阿里云oss改造</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/08/15/oss/" class="article-date">
  <time datetime="2022-08-15T06:45:25.000Z" itemprop="datePublished">2022-08-15</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/oss/">oss</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="1、阿里云OSS"><a href="#1、阿里云OSS" class="headerlink" title="1、阿里云OSS"></a>1、阿里云OSS</h1><ul>
<li><p>我们要做文件服务，阿里云oss是一个很好的分布式文件服务系统，所以我们只需要集成阿里云oss即可</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://www.aliyun.com/">https://www.aliyun.com/</a></p>
<p>![image-20210317153154543](D:&#x2F;拉钩&#x2F;课件&#x2F;10.阶段十&#x2F;02 图片&#x2F;image-20210317153154543.png)</p>
</li>
</ul>
<h2 id="2-1-开通“对象存储OSS”服务"><a href="#2-1-开通“对象存储OSS”服务" class="headerlink" title="2.1 开通“对象存储OSS”服务"></a>2.1 开通“对象存储OSS”服务</h2><ol>
<li><p>申请阿里云账号并实名认证</p>
</li>
<li><p>开通“对象存储OSS”服务</p>
<p>![image-20210317153335688](D:&#x2F;拉钩&#x2F;课件&#x2F;10.阶段十&#x2F;02 图片&#x2F;image-20210317153335688.png)</p>
<p>![image-20210317155050654](D:&#x2F;拉钩&#x2F;课件&#x2F;10.阶段十&#x2F;02 图片&#x2F;image-20210317155050654.png)</p>
</li>
<li><p>进入管理控制台</p>
</li>
</ol>
<p>![image-20210317155110318](D:&#x2F;拉钩&#x2F;课件&#x2F;10.阶段十&#x2F;02 图片&#x2F;image-20210317155110318.png)</p>
<h2 id="2-2-创建Bucket"><a href="#2-2-创建Bucket" class="headerlink" title="2.2 创建Bucket"></a>2.2 创建Bucket</h2><ul>
<li>类似”包”的概念，易于管理和存储</li>
<li>选择：标准存储、公共读、不开通</li>
</ul>
<p>![image-20210317155701371](D:&#x2F;拉钩&#x2F;课件&#x2F;10.阶段十&#x2F;\02 图片\image-20210317155701371.png)</p>
<ul>
<li>oss授权</li>
</ul>
<p>![image-20210317161600202](D:&#x2F;拉钩&#x2F;课件&#x2F;10.阶段十&#x2F;\02 图片\image-20210317161600202.png)</p>
<ul>
<li>pom</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 阿里云oss依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.aliyun.oss<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aliyun-sdk-oss<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 日期工具栏依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>joda-time<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>joda-time<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>yml</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">aliyun:</span></span><br><span class="line">  <span class="attr">oss:</span></span><br><span class="line">    <span class="attr">endpoint:</span> <span class="string">oss-cn-beijing.aliyuncs.com</span></span><br><span class="line">	<span class="attr">accessKeyId:</span> <span class="string">LTAI4G4SV6WtST7UYH776xxx</span></span><br><span class="line"> 	<span class="attr">secret:</span> <span class="string">X9KHNYgztNr9MI5Zp8JffQPZO4uxxx</span></span><br><span class="line">	<span class="attr">bucket:</span> <span class="string">lagou-laosun</span></span><br></pre></td></tr></table></figure>

<ul>
<li>controller</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;file&quot;)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileController</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> FileService fileService;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//上传文件到阿里云oss</span></span><br><span class="line">    <span class="meta">@PostMapping(&quot;fileUpload&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">fileUpload</span><span class="params">(<span class="meta">@RequestParam(&quot;file&quot;)</span> MultipartFile file)</span> &#123;</span><br><span class="line">        <span class="comment">//获取上传文件</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> fileService.upload(file);</span><br><span class="line">        <span class="keyword">return</span> url;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>service</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">FileService</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;aliyun.oss.endpoint&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String endpoint;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;aliyun.oss.accessKeyId&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String accessKeyId;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;aliyun.oss.secret&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String secret;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;aliyun.oss.bucket&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String bucket;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">upload</span><span class="params">(MultipartFile file)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 创建OSSClient实例。</span></span><br><span class="line">            <span class="type">OSS</span> <span class="variable">ossClient</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OSSClientBuilder</span>().build(endpoint, accessKeyId, accessKeySecret);</span><br><span class="line">            <span class="comment">// 上传文件流。</span></span><br><span class="line">            <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> file.getInputStream();</span><br><span class="line">            <span class="type">String</span> <span class="variable">fileName</span> <span class="operator">=</span> file.getOriginalFilename();</span><br><span class="line">            <span class="comment">// 生成随机唯一值，使用uuid，添加到文件名称里面</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">uuid</span> <span class="operator">=</span> UUID.randomUUID().toString().replaceAll(<span class="string">&quot;-&quot;</span>,<span class="string">&quot;&quot;</span>);</span><br><span class="line">            fileName = uuid+fileName;</span><br><span class="line">            <span class="comment">//按照当前日期，创建文件夹，上传到创建文件夹里面</span></span><br><span class="line">            <span class="comment">// 2021/02/02/01.mp4</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">timeUrl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DateTime</span>().toString(<span class="string">&quot;yyyy/MM/dd&quot;</span>);</span><br><span class="line">            fileName = timeUrl+<span class="string">&quot;/&quot;</span>+fileName; <span class="comment">// 2021/02/02/23fads85rj4hka01.mp4</span></span><br><span class="line">            <span class="comment">// 调用方法实现上传</span></span><br><span class="line">            ossClient.putObject(bucketName, fileName, inputStream);</span><br><span class="line">            <span class="comment">// 关闭OSSClient。</span></span><br><span class="line">            ossClient.shutdown();</span><br><span class="line">            <span class="comment">// 上传之后文件路径</span></span><br><span class="line">            <span class="comment">// https://lagou-laosun.oss-cn-beijing.aliyuncs.com/01.jpg</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;https://&quot;</span>+bucketName+<span class="string">&quot;.&quot;</span>+endpoint+<span class="string">&quot;/&quot;</span>+fileName;</span><br><span class="line">            <span class="comment">// 返回</span></span><br><span class="line">            <span class="keyword">return</span> url;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/springCloud%E7%BB%84%E4%BB%B6/" rel="tag">springCloud组件</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8/" rel="tag">对象存储</a></li></ul>

    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-Mysql架构设计"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/08/12/Mysql%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"
    >Mysql架构设计</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/08/12/Mysql%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/" class="article-date">
  <time datetime="2022-08-12T02:07:25.000Z" itemprop="datePublished">2022-08-12</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="MySQL架构设计"><a href="#MySQL架构设计" class="headerlink" title="MySQL架构设计"></a>MySQL架构设计</h1><h2 id="一、体系架构"><a href="#一、体系架构" class="headerlink" title="一、体系架构"></a>一、体系架构</h2><p><img src="/images/Mysql%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/1.jpg" alt="体系架构"></p>
<blockquote>
<p>网络连接层、服务层、存储引擎层和系统文件层</p>
</blockquote>
<h3 id="1、网络连接层"><a href="#1、网络连接层" class="headerlink" title="1、网络连接层"></a>1、网络连接层</h3><p>客户端连接器（Client COnnectors）:提供与MySQL服务器建立的支持。</p>
<p>各种语言通过api连接数据库。</p>
<h3 id="2、服务层（MySQL-Server）"><a href="#2、服务层（MySQL-Server）" class="headerlink" title="2、服务层（MySQL Server）"></a>2、服务层（MySQL Server）</h3><blockquote>
<p>MySQL Server的核心，主要包含系统管理和控制工具、连接池、SQL接口、解析器、查询优化器和缓存六个部分</p>
</blockquote>
<ul>
<li><p><strong>连接池（Connection Pool）:负责存储和管理客户端与数据库的连接，一个线程负责管理一个连接。</strong></p>
</li>
<li><p><strong>系统管理和控制工具（Management Services &amp; Utilities）:例如备份恢复、安全管理、集群管理等</strong>  </p>
</li>
<li><p><strong>SQL接口</strong>（SQL Interface）:用于接受客户端发送的各种SQL命令，并且返回用户需要查询的结果。比如DML、DDL、存储过程、视图、触发器等。</p>
</li>
<li><p><strong>SQL解析器</strong>（Parser）:负责将请求的SQL解析生成一个“解析树”。根据MySQL规则检查解析树是否合法</p>
</li>
<li><p><strong>查询优化器</strong>（Optimizer）：当“解析树”通过解析器语法检查后，将交由优化器将其转化成执行计划，然后与存储引擎交互。</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select uid,name from user where gender=1;</span><br></pre></td></tr></table></figure>

<p>​		选取–&gt;&gt;投影–&gt;&gt;联接 策略</p>
<p>​		1）select现根据where语句进行选取，并不是查询出全部数据再过滤</p>
<p>​		2）select查询根据uid和name进行属性投影，并不是取出所有字段</p>
<p>​		3）将前面选取和投影联接起来最终生成查询结果</p>
<ul>
<li><strong>缓存（Cache&amp;Buffer）：缓存机制是由一系列小缓存组成的。</strong></li>
</ul>
<p>⽐如表缓存，记录缓存，权限缓存，引<br>擎缓存等。如果查询缓存有命中的查询结果，查询语句就可以直接去查询缓存中取数据。  </p>
<h3 id="3、存储引擎层（Pluggable-Storage-Engines）"><a href="#3、存储引擎层（Pluggable-Storage-Engines）" class="headerlink" title="3、存储引擎层（Pluggable Storage Engines）"></a>3、存储引擎层（Pluggable Storage Engines）</h3><p>​		存储引擎负责MySQL中数据的存储与提取，与底层系统文件进行交互。</p>
<p>常见的是MyISAM和InnoDB</p>
<h3 id="4、系统文件层（File-System）"><a href="#4、系统文件层（File-System）" class="headerlink" title="4、系统文件层（File System）"></a>4、系统文件层（File System）</h3><blockquote>
<p>将数据库的数据和日志存储在文件系统之上，并完成与存储引擎的交互，是文件的物理存储层。</p>
</blockquote>
<p>主要包含日志文件、数据文件、配置文件、pid文件、socket文件等。</p>
<ul>
<li><p>日志文件</p>
<ul>
<li><p>错误日志（Error log）</p>
</li>
<li><p>通用查询日志（General query log）</p>
</li>
<li><p>二进制日志（binary log）</p>
<p>主要用于数据库恢复和主从复制</p>
</li>
<li><p>慢查询日志（Slow query log）</p>
<p>记录所有执行时间超时的查询SQL，默认10秒</p>
</li>
</ul>
</li>
<li><p>配置文件</p>
<p>用于存放MySQL所有的配置信息文件，比如my.cnf、my.ini等</p>
</li>
<li><p>数据文件</p>
<ul>
<li>db.opt文件：记录这个库的默认使用的字符集和校验规则</li>
<li>frm文件：存储与表相关的元数据( meta )信息，包括表结构的定义信息等，每⼀张表都会有⼀个frm ⽂件。</li>
<li>MYD文件：MyISAM 存储引擎专用，存放 MyISAM 表的数据( data) ，每⼀张表都会有⼀个.MYD ⽂件。</li>
<li>MYI ⽂件： MyISAM 存储引擎专⽤，存放 MyISAM 表的索引相关信息，每⼀张 MyISAM 表对应⼀个 .MYI ⽂件。</li>
<li>ibd⽂件和 IBDATA ⽂件：存放 InnoDB 的数据⽂件(包括索引)。 InnoDB 存储引擎有两种表空间⽅式：独享表空间和共享表空间。独享表空间使⽤ .ibd ⽂件来存放数据，且每⼀张 InnoDB 表对应⼀个 .ibd ⽂件。共享表空间使⽤ .ibdata ⽂件，所有表共同使⽤⼀个(或多 个，⾃⾏配置) .ibdata ⽂<br>件。</li>
<li>ibdata1 ⽂件：系统表空间数据⽂件，存储表元数据、 Undo⽇志等 。  </li>
<li>ib_logfile0、 ib_logfile1 ⽂件： Redo log ⽇志⽂件。</li>
</ul>
</li>
<li><p>pid文件</p>
<p>pid ⽂件是 mysqld 应⽤程序在 Unix&#x2F;Linux 环境下的⼀个进程⽂件，和许多其他 Unix&#x2F;Linux 服务 端程序<br>⼀样，它存放着⾃⼰的进程 id。  </p>
</li>
<li><p>socket文件</p>
<p>socket ⽂件也是在 Unix&#x2F;Linux 环境下才有的，⽤户在 Unix&#x2F;Linux 环境下客户端连接可以不通过 TCP&#x2F;IP<br>⽹络⽽直接使⽤ Unix Socket 来连接 MySQL。</p>
</li>
</ul>
<h2 id="二、运行机制"><a href="#二、运行机制" class="headerlink" title="二、运行机制"></a>二、运行机制</h2><p><img src="/images/Mysql%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/2.jpg" alt="运行机制"></p>
<h3 id="1、建立连接（Connectors-amp-Connection-Pool）"><a href="#1、建立连接（Connectors-amp-Connection-Pool）" class="headerlink" title="1、建立连接（Connectors &amp;Connection Pool）"></a>1、建立连接（Connectors &amp;Connection Pool）</h3><p>MySQL客户端与服务端的通信方式是<strong>“半双工”</strong></p>
<p><strong>通讯机制：</strong></p>
<ul>
<li>全双工：同时发送和接收数据。</li>
<li>半双工：指某一时刻，要么发送数据，要么接收数据，不能同时。</li>
<li>单工：只能发送数据或只能接收数据。</li>
</ul>
<p><strong>线程状态：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show processlist;//查看用户正在运行的线程信息，root用户能查看所有线程，其他用户只能看自己的</span><br></pre></td></tr></table></figure>

<ul>
<li>id：线程ID，可以使用kill xx；</li>
<li>user：启动这个线程的用户</li>
<li>Host：发送请求的客户端的IP和端口号</li>
<li>db：当前命令在哪个库执行</li>
<li>Command：该线程正在执行的操作命令<ul>
<li>Create DB：正在创建库操作</li>
<li>Drop DB：正在删除库操作</li>
<li>Execute：正在执行一个PreparedStatement</li>
<li>Close Stmt：正在关闭一个PreparedStatement</li>
<li>Query：正在执行一个语句</li>
<li>Sleep：正在等待客户端发送语句</li>
<li>Quit：正在退出</li>
<li>Shutdown：正在关闭服务器</li>
</ul>
</li>
<li>Time：表示线程处于当前状态的时间，单位秒</li>
<li>State：线程状态<ul>
<li>Updating：正在搜索匹配记录，进行修改</li>
<li>Sleeping：正在等待客户端发送新请求</li>
<li>Starting：正在执行请求处理</li>
<li>Checking table：正在检查数据表</li>
<li>Closing table：正在将表中数据刷新到磁盘中</li>
<li>Locked：被其他查询锁住了记录</li>
<li>Sending Date：正在处理Select查询，同时将结果发送给客户端</li>
</ul>
</li>
<li>info：记录线程执行语句，默认显示前100个字符。完整使用show full processlist</li>
</ul>
<h3 id="2、查询缓存（Cache-amp-Buffer）"><a href="#2、查询缓存（Cache-amp-Buffer）" class="headerlink" title="2、查询缓存（Cache&amp;Buffer）"></a>2、查询缓存（Cache&amp;Buffer）</h3><blockquote>
<p>MySQL的一个可优化查询的地方</p>
</blockquote>
<p>如果开启了查询缓存且在查询缓存过程中查询到完全相同的SQL语句，则将查询结果直接返回给客户端。</p>
<p>如果没有开启查询 缓存或者没有查询到完全相同的 SQL 语句则会由解析器进⾏语法语义解析，并⽣成“解析树”。  </p>
<ul>
<li>缓存Select查询的结果和SQL语句</li>
<li>执行Select查询时，先查询缓存，判断是否存在可用的记录集，要求是否完全相同（包括参数值），这样才会匹配缓存数据命中。</li>
<li>即使开启查询缓存，以下SQL也不能缓存</li>
<li><strong>show variables like ’%query_cache%‘;</strong>&#x2F;&#x2F;查询缓存是否启用，空间大小，限制等</li>
<li><strong>show variables like ‘Qcache%’;</strong>&#x2F;&#x2F;查看更详细的缓存参数，可用缓存空间，缓存块，缓存多少等</li>
</ul>
<p>进阶：</p>
<blockquote>
<p>大多数情况下建议不使用查询缓存</p>
</blockquote>
<p>查询缓存往往弊大于利。</p>
<p>1缓存需要语句完全相等，包括参数</p>
<p>2只要有对一个表的更新，这个表上所有的查询缓存都会被情况。因此，<strong>缓存命中率不高</strong>。</p>
<p>只有在表更新频率不高，查询语句完全一致的情况下，可以手动开启缓存，其他一律关闭。</p>
<p><strong>注：mysql8之后，取消了缓存功能。</strong></p>
<h3 id="3、解析器（Parser）"><a href="#3、解析器（Parser）" class="headerlink" title="3、解析器（Parser）"></a>3、解析器（Parser）</h3><p>将客户端发送的SQL进行语法解析，生成“解析树”。预处理器根据一些MySQL规则进一步检查“解析树”是否合法。</p>
<p>如果语句不对，会收到“You have an error in your SQL syntax”的错误提醒</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; use test;</span><br><span class="line">Database changed</span><br><span class="line">mysql&gt; elect * from l;</span><br><span class="line">ERROR 1064 (42000): You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near &#x27;elect * from l&#x27; at line 1</span><br></pre></td></tr></table></figure>

<h3 id="4、查询优化器（Optimizer）"><a href="#4、查询优化器（Optimizer）" class="headerlink" title="4、查询优化器（Optimizer）"></a>4、查询优化器（Optimizer）</h3><blockquote>
<p>根据“解析树”生成最优的执行计划。</p>
</blockquote>
<p>优化策略：静态优化（编译时优化）、动态优化（运行时优化）</p>
<ul>
<li><p>等价变换策略</p>
<ul>
<li><p>5&#x3D;5 and a&gt;5 改成 a&gt;5</p>
</li>
<li><p>a&lt;b and a&#x3D;5 改成b&gt;5 and a&#x3D;5</p>
</li>
<li><p>基于联合索引，调整条件位置等</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#索引</span><br><span class="line">Index(a,b)</span><br><span class="line">#原始语句</span><br><span class="line">select * from test where b=&#x27;xxx&#x27; and a=&#x27;xx&#x27;</span><br><span class="line">#优化后的语句</span><br><span class="line">select * from test where a=&#x27;xx&#x27; and b=&#x27;xxx&#x27; #(推荐)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>优化count、min、max等函数</p>
<ul>
<li>InnoDB引擎min函数只需要找索引最左边</li>
<li>InnoDB引擎max函数只需要找索引最右边</li>
<li>MyISAM引擎count(*)，不需要计算，直接返回</li>
</ul>
</li>
<li><p><strong>提前终止查询</strong></p>
<ul>
<li><strong>使用了limit查询，获取limit所需的数据，就不在继续遍历后面数据limit 100,10</strong></li>
</ul>
</li>
<li><p><strong>in的优化</strong></p>
<ul>
<li><p>MySQL对in查询，先进行排序，再采用二分法查找数据</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">where id in (2,1,3)</span><br><span class="line">变成in (1,2,3)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="5、查询执行引擎"><a href="#5、查询执行引擎" class="headerlink" title="5、查询执行引擎"></a>5、查询执行引擎</h3><p>​		查询执行引擎会根据SQL语句中表的存储引擎类型，以及对应的API接口与底层存储引擎缓存或物理文件的交互，得到查询结果并返回给客户端。</p>
<p>​		若启用查询缓存，会将SQL语句和结构完整地保存到查询缓存（Cache&amp;Buffer）中，以后若有相同地SQL语句执行则直接返回结果。</p>
<ul>
<li>如果开启了查询缓存，先将查询结果做缓存操作</li>
<li>返回结果过多，采用增量模式返回</li>
</ul>
<h2 id="三、存储引擎"><a href="#三、存储引擎" class="headerlink" title="三、存储引擎"></a>三、存储引擎</h2><h3 id="1、各个引擎对比"><a href="#1、各个引擎对比" class="headerlink" title="1、各个引擎对比"></a>1、各个引擎对比</h3><p>show engines命令</p>
<p><img src="/images/Mysql%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/3.jpg" alt="数据库支持的引擎信息"></p>
<p>MySQL5.5之前默认采用M有ISAM存储引擎，从5.5开始采用Inn哦DB存储引擎</p>
<ul>
<li>InnoDB：支持事务，具有提交，回滚和崩溃恢复能力，事务安全</li>
<li>MyISAM：不支持事务和外键，访问速度快</li>
<li>Memory：利用内存创建表，访问速度非常快，因为数据在内存，而且默认使用Hash索引，但是一旦关闭，数据就会丢失</li>
<li>Archive：归档类型引擎，仅能支持insert和select语句</li>
<li>Csv：以CSV文件进行数据存储，由于文件限制，所有列必须强制指定not null，另外CSV引擎也不支持索引和分区，适合做数据交换的中间表</li>
<li>BlackHole：黑洞，只进不出，进来小时，所有插入数据都不会保存</li>
<li>Federated：可以远程访问MySQL数据库中的表。一个本地表，不保存数据，访问远程表内容。</li>
<li>MRG_MyISAM：一组MyISAM表的组合，这些MyISAM表必须结构相同，Merge表本身没有数据，对Merge操作可以对一组MyISAM表进行操作</li>
</ul>
<h4 id="（1）InnoDB和MyISAM对比"><a href="#（1）InnoDB和MyISAM对比" class="headerlink" title="（1）InnoDB和MyISAM对比"></a>（1）InnoDB和MyISAM对比</h4><ul>
<li><strong>事务和外键</strong></li>
</ul>
<p>InnoDB⽀持事务和外键，具有安全性和完整性，适合⼤量insert或update操作<br>MyISAM不⽀持事务和外键，它提供⾼速存储和检索，适合⼤量的select查询操作 锁机制<br>InnoDB⽀持⾏级锁，锁定指定记录。基于索引来加锁实现。<br>MyISAM⽀持表级锁，锁定整张表。  </p>
<ul>
<li><strong>索引结构</strong></li>
</ul>
<p>InnoDB使⽤聚集索引(聚簇索引)，索引和记录在⼀起存储，既缓存索引，也缓存记录。<br>MyISAM使⽤⾮聚集索引(⾮聚簇索引)，索引和记录分开。  </p>
<ul>
<li><strong>并发处理能力</strong></li>
</ul>
<p>MyISAM使⽤表锁，会导致写操作并发率低，读之间并不阻塞，读写阻塞。<br>InnoDB读写阻塞可以与隔离级别有关，可以采⽤多版本并发控制( MVCC)来⽀持⾼并发(读写不加锁)，<br>⾏锁（悲观锁）  </p>
<ul>
<li><strong>存储文件</strong></li>
</ul>
<p>InnoDB表对应两个⽂件，⼀个.frm表结构⽂件，⼀个.ibd数据⽂件。 InnoDB表最⼤⽀持64TB；<br>MyISAM表对应三个⽂件，⼀个.frm表结构⽂件，⼀个MYD表数据⽂件，⼀个.MYI索引⽂件。从<br>MySQL5.0开始默认限制是256TB。  </p>
<p><strong>适用场景</strong></p>
<p><strong>MyISAM</strong></p>
<ul>
<li>不需要事务⽀持(不⽀持)  </li>
<li>并发相对较低(锁定机制问题)</li>
<li>数据修改相对较少，以读为主</li>
<li>数据⼀致性要求不⾼</li>
</ul>
<p><strong>InnoDB</strong></p>
<ul>
<li>需要事务⽀持(具有较好的事务特性)</li>
<li>行级锁定对⾼并发有很好的适应能⼒</li>
<li>数据更新较为频繁的场景</li>
<li>数据⼀致性要求较⾼</li>
<li>硬件设备内存较⼤，可以利⽤InnoDB较好的缓存能⼒来提⾼内存利⽤率，减少磁盘IO</li>
</ul>
<p>总结：</p>
<p>两种引擎该如何选择？  </p>
<ul>
<li>是否需要事务？有，InnoDB</li>
<li>是否存在并发修改？有，InnoDB</li>
<li>是否追求快速查询，求数据修改少？可以备选MyISAM。可以更多的选择其他组件MongoDB</li>
<li>绝大多数情况下，推荐使用InnoDB</li>
</ul>
<h3 id="2、Undo-Log（重点）"><a href="#2、Undo-Log（重点）" class="headerlink" title="2、Undo Log（重点）"></a>2、Undo Log（重点）</h3><h4 id="（1）Undo-Log介绍"><a href="#（1）Undo-Log介绍" class="headerlink" title="（1）Undo Log介绍"></a>（1）Undo Log介绍</h4><p>Undo：意为撤销或取消，以撤销操作为目的，返回指定某个状态的操作。</p>
<p><strong>Undo Log</strong>：数据库事务开始之前，会将修改的记录存放到Undo日志里，当事务回滚时或者数据库崩溃时，可以利用Undo日志，撤销未提交事务对数据库产生的影响。</p>
<p><strong>Undo Log产生和销毁</strong>：<strong>Undo Log在事务开始前产生</strong>；事务在提交时，并不会立刻删除undo log，innodb会将该事务对应的undo log放⼊到删除列表中，后⾯会通过后台线程purge thread进行回收处<br>理。 Undo Log属于逻辑⽇志，记录⼀个变化过程。例如执⾏⼀个delete， undolog会记 录⼀个insert；执⾏⼀个update ， undolog会记录⼀个相反的update。  </p>
<p><strong>Undo Log存储</strong>：undo log采⽤段的⽅式管理和记录。在innodb数据⽂件中包含⼀种rollback segment回滚段，内部包含1024个undo log segment。可以通过下⾯⼀组参数来控制Undo log存储。  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show variables like &#x27;%innodb_undo%&#x27;;</span><br></pre></td></tr></table></figure>

<h4 id="（2）Undo-Log作用"><a href="#（2）Undo-Log作用" class="headerlink" title="（2）Undo Log作用"></a>（2）Undo Log作用</h4><p>实现事务原子性：undo log中的备份可将数据恢复到事务开始之前的状态</p>
<p>实现多版本并发控制（MVCC）</p>
<p>事务未提交之前，Undo Log保存了未提交之前的版本数据，Undo Log中的数据可作为数据旧版本快照供其他并发事务进行快照读。</p>
<ul>
<li>事务A手动开启事务，执行更新操作，首先会把更新命中的数据被分到Undo Buffer中。</li>
<li>事务B手动开启事务，执行查询操作，会读取Undo日志数据返回，进行快照读</li>
</ul>
<h3 id="3、Redo-Log（重点）"><a href="#3、Redo-Log（重点）" class="headerlink" title="3、Redo Log（重点）"></a>3、Redo Log（重点）</h3><p>redo log可保证InnoDB即使数据库发生异常重启，之前提交的记录都不会丢失，这个能力称为<strong>crash-safe</strong>。</p>
<h4 id="（1）介绍"><a href="#（1）介绍" class="headerlink" title="（1）介绍"></a>（1）介绍</h4><p>Redo ：重做。以恢复操作为⽬的，在数据库发⽣意外时重现操作。</p>
<p>Redo Log ：指事务中修改的任何数据，将最新的数据备份存储的位置( Redo Log)，被称为重做⽇志。</p>
<p>Redo Log 的⽣成： 随着事务操作的执⾏，就会⽣成Redo Log ，在事务提交时会将产⽣ Redo Log写⼊Log Buffer ，并不是随着事务的提交就⽴刻写⼊磁盘⽂件。</p>
<p>释放：等事务操作的脏页写⼊到磁盘之后， Redo Log 的使命也就完成了， Redo Log占⽤的空间就可以重用(被覆盖写⼊)。  </p>
<h4 id="（2）工作原理"><a href="#（2）工作原理" class="headerlink" title="（2）工作原理"></a>（2）工作原理</h4><p>Redo Log 是为了实现事务的持久性而出现的产物。</p>
<p>防止在发生故障的时间点，尚有脏页未写入表的IBD⽂件中，在重启 MySQL 服务的时候，根据 Redo Log 进⾏重做，从而达到事务的未⼊磁盘数据进行持久化这⼀特性。  </p>
<h4 id="（3）写入机制"><a href="#（3）写入机制" class="headerlink" title="（3）写入机制"></a>（3）写入机制</h4><p>Redo Log 文件内容是以顺序循环的方式写⼊⽂件，写满时则回溯到第⼀个⽂件，进行覆盖写。  </p>
<p><img src="/images/Mysql%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/4.jpg" alt="写入机制"></p>
<p>write pos：当前位置记录，一边写一边往后移动，追着check point</p>
<p>check point：当前要擦除的位置，往后推移并且循环，擦除记录前要把记录更新到数据文件。</p>
<figure class="highlight plaintext"><figcaption><span>wiki</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">write pos 和 checkpoint 之间还空着的部分，可以⽤来记录新的操作，其他的空间是写⼊的redo log内</span><br><span class="line">容。如果 write pos 追上 checkpoint ，表示写满，这时候不能再执⾏新的更新，得停下来先擦掉⼀些</span><br><span class="line">记录，把 checkpoint 推进⼀下。</span><br></pre></td></tr></table></figure>

<h4 id="（4）相关配置参数"><a href="#（4）相关配置参数" class="headerlink" title="（4）相关配置参数"></a>（4）相关配置参数</h4><p>每个InnoDB存储引擎⾄少有1个重做日志文件组(group)，每个⽂件组⾄少有2个重做日志文件，默认为<br>ib_logfile0和ib_logfile1。可以通过下面⼀组参数控制Redo Log存储：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show variables like &#x27;%innodb_log%&#x27;;</span><br></pre></td></tr></table></figure>

<p>Redo Buffer 持久化到 Redo Log 的策略，可通过 Innodb_flush_log_at_trx_commit 设置：<br>0 ：每秒提交 Redo buffer -&gt;OS cache -&gt; flush cache to disk ，可能丢失⼀秒内的事务数据。由后台<br>Master线程每隔 1秒执⾏⼀次操作。<br>1 (默认值)：每次事务提交执⾏ Redo Buffer -&gt; OS cache -&gt; flush cache to disk ，最安全，性能最差<br>的⽅式。</p>
<p>2 ：每次事务提交执行 Redo Buffer -&gt; OS cache ，然后由后台Master线程再每隔1秒执行OS cache -&gt;<br>flush cache to disk 的操作。<br>⼀般建议选择取值2 ，因为 MySQL 挂了数据没有损失，整个服务器挂了才会损失1秒的事务提交数 据。  </p>
<h3 id="4、BinLog（重点）"><a href="#4、BinLog（重点）" class="headerlink" title="4、BinLog（重点）"></a>4、BinLog（重点）</h3><h4 id="（1）记录模式"><a href="#（1）记录模式" class="headerlink" title="（1）记录模式"></a>（1）记录模式</h4><blockquote>
<p>Redo Log 是属于InnoDB引擎所特有的日志，而MySQL Server也有自己的日志，即 Binary log (⼆进制日志)，简称Binlog 。  </p>
</blockquote>
<p>Binlog是<strong>记录所有数据库表结构变更以及表数据修改的⼆进制日志</strong>，不会记录SELECT和SHOW这类操作。 Binlog日志是以事件形式记录，还包含语句所执行的消耗时间。  </p>
<p>开启Binlog日志以下两个最重要的使用场景。</p>
<p><strong>主从复制</strong>：主库中开启Binlog功能，主库就可以把Binlog传递给从库，从库拿到Binlog后实现数据恢复达到主从数据一致性。</p>
<p><strong>数据恢复</strong>：通过mysqlbinlog工具来恢复数据。</p>
<p>Binlog文件名默认为“主机名_binlog-序列号”格式。例如oak_binlog-000001，也可以在配置文件中指定名称。</p>
<p>⽂件记录模式有STATEMENT、 ROW和MIXED三种，具体含义如下。</p>
<p>**ROW ( row-based replication, RBR)**：⽇志中会记录每⼀行数据被修改的情况，然后在slave端对相同的数据进⾏修改。<br>优点：能清楚记录每⼀个⾏数据的修改细节，能完全实现主从数据同步和数据的恢复。<br>缺点：批量操作，会产⽣⼤量的日志，尤其是alter table会让日志暴涨。<br>**STATMENT ( statement-based replication, SBR)**：每⼀条被修改数据的SQL都会记录到master的<br>Binlog中， slave在复制的时候SQL进程会解析成和原来master端执⾏过的相同的 SQL再次执行。简称<br>SQL语句复制。<br>优点：⽇志量⼩，减少磁盘IO ，提升存储和恢复速度<br>缺点：在某些情况下会导致主从数据不⼀致，⽐如last_insert_id()、 random等函数。<br>**MIXED ( mixed-based replication, MBR)**：以上两种模式的混合使用，⼀般会使用STATEMENT模式<br>保存binlog ，对于STATEMENT模式⽆法复制的操作使⽤ROW模式保存 binlog， MySQL会根据执⾏的<br>SQL语句选择写⼊模式。⽐如使⽤随机数函数这种statement形式⽆法保持幂等的就必须使⽤row格式存<br>储  </p>
<h4 id="（2）Binlog文件结构"><a href="#（2）Binlog文件结构" class="headerlink" title="（2）Binlog文件结构"></a>（2）Binlog文件结构</h4><p>MySQL的binlog⽂件中记录的是对数据库的各种修改操作，用来表示修改操作的数据结构是Log event。<br>不同的修改操作对应的不同的log event。比较常用的log event有： Query event、 Row event、 Xid event等。 binlog⽂件的内容就是各种Log event的集合。  </p>
<h4 id="（3）Binlog写入机制"><a href="#（3）Binlog写入机制" class="headerlink" title="（3）Binlog写入机制"></a>（3）Binlog写入机制</h4><p>根据记录模式和操作触发event事件⽣成logevent (事件触发执⾏机制)<br>将事务执⾏过程中产⽣log event写⼊缓冲区，每个事务线程都有⼀个缓冲区<br>Log Event保存在⼀个binlog_cache_mngr数据结构中，在该结构中有两个缓冲区，⼀个是 stmt_cache<br>，⽤于存放不⽀持事务的信息；另⼀个是trx_cache ，⽤于存放⽀持事务的信息。<br>事务在提交阶段会将产⽣的log event写⼊到外部binlog⽂件中。<br>不同事务以串⾏⽅式将log event写⼊binlog⽂件中，所以⼀个事务包含的log event信息在 binlog⽂件中<br>是连续的，中间不会插⼊其他事务的log event。  </p>
<h4 id="（4）Binlog文件操作"><a href="#（4）Binlog文件操作" class="headerlink" title="（4）Binlog文件操作"></a>（4）Binlog文件操作</h4><p>Binlog状态查看</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show variables like &#x27;%log_bin%&#x27;;</span><br></pre></td></tr></table></figure>

<p>开启Binlog功能</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; set global log_bin = mysqllogbin;</span><br><span class="line">ERROR 1238 (HY000): Variable &#x27;log_bin&#x27; is a read only variable</span><br></pre></td></tr></table></figure>

<p>需要修改my.cnf或my.ini配置文件，在[mysqld]下面增加log_bin&#x3D;mysql_bin_log，重启MySQL服务。</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#log-bin=ON</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#log-bin-basename=mysqlbinlog</span></span><br><span class="line"></span><br><span class="line"><span class="attr">binlog-format</span>=ROW</span><br><span class="line"></span><br><span class="line"><span class="attr">log-bin</span>=mysqlbinlog</span><br></pre></td></tr></table></figure>

<p>使用show binlog events命令</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">show binary logs;#等价于show master logs;</span><br><span class="line"></span><br><span class="line">show master status;</span><br><span class="line"></span><br><span class="line">show binlog events;</span><br><span class="line"></span><br><span class="line">show binlog events in &#x27;mysqlbinlog.000001&#x27;;#查看binglog中事件</span><br></pre></td></tr></table></figure>

<p>使用mysqlbinlog命令</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysqlbinlog &quot;文件名&quot;</span><br><span class="line"></span><br><span class="line">mysqlbinlog &quot;文件名&quot; &gt; &quot;test.sql&quot;</span><br></pre></td></tr></table></figure>

<p>使用binlog恢复数据</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#按指定时间恢复</span><br><span class="line">mysqlbinlog --start-datetime=&quot;2020-04-25 18:00:00&quot; --stop-datetime=&quot;2020-04-26 00:00:00&quot; mysqlbinlog.000002 | mysql -uroot -p1234</span><br><span class="line"></span><br><span class="line">#按事件位置号恢复</span><br><span class="line">mysqlbinlog --start-position=154 --stop-position=957 mysqlbinlog.000002 | mysql -uroot -p1234</span><br></pre></td></tr></table></figure>

<p>mysqldump：定期(每周&#x2F;每天)全部备份数据库数据。 mysqlbinlog可以做增量备份和恢复操作。恢复数据比较久远或者需要全库备份的时候需要使⽤全量+增量备份的形式。  </p>
<p>删除Binlog文件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">purge binary logs to &#x27;mysqlbinlog.000001&#x27;;#删除指定文件</span><br><span class="line">purge binary logs before &#x27;2020-04-28 00:00:00&#x27;;#删除指定时间之前的文件</span><br><span class="line">reset master;#清除所有文件</span><br></pre></td></tr></table></figure>

<p>可以通过设置expire_logs_days参数来启动自动清理功能。默认值为0表示没启用。设置为1表示超出1天binlog⽂件会自动删除掉。  </p>
<h4 id="（5）Redo-Log和Binlog区别"><a href="#（5）Redo-Log和Binlog区别" class="headerlink" title="（5）Redo Log和Binlog区别"></a>（5）Redo Log和Binlog区别</h4><ul>
<li>Redo Log是属于InnoDB引擎功能， Binlog是属于MySQL Server自带功能，并且是以⼆进制⽂件记录。</li>
<li>Redo Log属于物理日志，记录该数据页更新状态内容， Binlog是逻辑日志，记录更新过程。</li>
<li>Redo Log日志是循环写，日志空间大小是固定， Binlog是追加写⼊，写完⼀个写下⼀个，不会覆盖使用 </li>
<li>Redo Log作为服务器异常宕机后事务数据⾃动恢复使用， Binlog可以作为主从复制和数据恢复使用。Binlog没有自动crash-safe能力。</li>
</ul>
<h3 id="5、更新语句的执行流程"><a href="#5、更新语句的执行流程" class="headerlink" title="5、更新语句的执行流程"></a>5、更新语句的执行流程</h3><p>准备一个测试表</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create table T(ID int primary key,c int);</span><br></pre></td></tr></table></figure>

<p>一个简单的update语句</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update T set c=c+1 where ID=2;</span><br></pre></td></tr></table></figure>

<p>查询流程步骤</p>
<p><img src="/images/Mysql%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/5.jpg" alt="查询流程步骤"></p>
<p>更新流程步骤：</p>
<p>redo log（重做日志）和binlog（归档日志）</p>
<p>①执行器先找引擎取ID&#x3D;2这一行。ID是主键，引擎直接用树搜索找到这一行。如果ID&#x3D;2这一行所在的数据页本来就在内存中，就直接返回给执行器；否则，需要先从磁盘读入内存，然后再返回。</p>
<p>②执行器拿到引擎给的行数据，把这个值加上1，比如原来是N，现在就是N+1，得到新的一行数据，再调用引擎接口写入这行新数据</p>
<p>③<strong>引擎将这行数据更新到内存中</strong>，同时将这个更新操作记录到redo log里面，此时redo log处于prepare状态。然后告知执行器执行完成了，随时可以提交事务。</p>
<p>④执行器生成这个操作的binlog，并把binlog写入磁盘。</p>
<p>⑤执行器调用引擎的提交事务接口，引擎把刚刚写入的redo log改成提交（commit状态），更新完成。</p>
<p>浅色表示InnoDB内部执行，深色表示执行器中执行</p>
<p><img src="/images/Mysql%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/6.jpg" alt="更新流程步骤"></p>
<p>为什么最后三步需要用到“两阶段提交”？</p>
<p><strong>保证binlog和redo log的一致性</strong></p>
<p>宕机恢复的时候的大致步骤：</p>
<ul>
<li>按顺序扫描redolog，如果redolog中的事务既有prepare标识，又有commit标识，就直接提交（复制redolog disk中的数据页到磁盘数据页）</li>
<li>如果redolog事务只有prepare标识，没有commit标识，则说明当前事务在commit阶段crash（崩溃）了，binlog中当前事务是否完整未可知，此时拿着redolog中当前事务的XID（redolog和binlog中事务落盘的标识），去查看binlog中是否存在此XID。<ul>
<li>如果binlog中有当前事务的XID，则提交事务（复制redolog disk中的数据页到磁盘数据页）</li>
<li>如果binlog中没有当前事务的XID，则回滚事务（使用undolog来删除redolog中的对应事务）</li>
</ul>
</li>
</ul>
<p><img src="/images/Mysql%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/6.jpg" alt="更新流程步骤"></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/mysql/" rel="tag">mysql</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%9E%B6%E6%9E%84/" rel="tag">架构</a></li></ul>

    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-Mysql事务"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/08/01/Mysql%E4%BA%8B%E5%8A%A1/"
    >Mysql事务</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/08/01/Mysql%E4%BA%8B%E5%8A%A1/" class="article-date">
  <time datetime="2022-08-01T09:47:25.000Z" itemprop="datePublished">2022-08-01</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="Mysql事务"><a href="#Mysql事务" class="headerlink" title="Mysql事务"></a>Mysql事务</h1><blockquote>
<p>事务会把数据库从一种一致状态转换为另一种一致状态</p>
</blockquote>
<ul>
<li>原子性（atomicity）</li>
<li>一致性（consistency）</li>
<li>隔离性（isolation）</li>
<li>持久型（durability）</li>
</ul>
<p>锁保证事务的隔离性</p>
<h2 id="一、认识事务"><a href="#一、认识事务" class="headerlink" title="一、认识事务"></a>一、认识事务</h2><h3 id="1、概述（ACID）"><a href="#1、概述（ACID）" class="headerlink" title="1、概述（ACID）"></a>1、概述（ACID）</h3><blockquote>
<p>事务是访问并更新数据库中各种数据项的一个程序执行单元</p>
</blockquote>
<ul>
<li><p>A（Atomicity）原子性</p>
<p>原子性指整个数据库事务是不可分割的工作单位。只有使事务中所有的数据库操作都执行成功，才算整个事务成功。</p>
<p>修改—》Buffer Pool修改—》刷盘。可能有下面两种情况：</p>
<ul>
<li>事务提交了，如果此时Buffer Pool的脏页没有刷盘，如何保证修改的数据生效？	Redo</li>
<li>如果事务没提交，但是Buffer Pool的脏页刷盘了，如何保证不该存在的数据撤销？  Undo</li>
</ul>
<p>每一个写事务，都会修改<strong>Buffer Pool</strong>，从而产生相应的<strong>Redo&#x2F;Undo</strong>日志，在Buffer Pool中的页被刷到磁盘之前，这些日志信息都会先写入到日志文件中，如果Buffer Pool中的脏页没有刷成功，此时数据库挂了，那在数据库再次启动之后，可以通过Redo日志将其恢复出来，以保证脏页写的数据不会丢失。如果脏页刷新成功，此时数据库挂了，就需要通过Undo来实现了。</p>
</li>
<li><p>C（consistency）一致性</p>
<p>一致性指事务将数据库从一种状态转变为下一种一致的状态。事务开始前后，数据库的完整性约束没有被破坏。</p>
<p>一致性包括两方面内容，分别是约束一致性和数据一致性</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">一致性也可理解为数据的完整性。数据的完整性是通过原子性、隔离性、持久性来保证的。</span><br></pre></td></tr></table></figure>


</li>
<li><p>I（isolation）隔离性</p>
<p>事务的隔离性要求每个读写事务的对象对其他事务的操作对象能相互分离，即该事务提交前对其他事务都不可见。</p>
<p>锁和多版本控制（MVCC）技术用于保障隔离性。</p>
</li>
<li><p>D（durability）持久性</p>
<p>事务一旦提交，结果永久性的。即使发生宕机等故障，数据库也能将数据恢复。</p>
<p>与WAL技术相关，redo log在系统Crash重启之类的情况时，可以修复数据，从而保障事务的持久性，通过原子性可以保证逻辑上的持久性，通过存储引擎的数据刷盘可以保证物理上的持久型。</p>
</li>
</ul>
<p>WAL的全称为Write-Ahead Logging，先写日志，再写磁盘。</p>
<h3 id="2、分类"><a href="#2、分类" class="headerlink" title="2、分类"></a>2、分类</h3><ul>
<li><p>扁平事务（Flat Transactions）</p>
</li>
<li><p>带有保存点的扁平事务（Flat Transactions with Savepoints）</p>
</li>
<li><p>链事务（Chained Transactions）</p>
</li>
<li><p>嵌套事务（Nested Transactions）</p>
</li>
</ul>
<h4 id="扁平事务"><a href="#扁平事务" class="headerlink" title="扁平事务"></a>扁平事务</h4><p>​		所有操作处于同一层次，其次由BEGIN WORK开始，由COMMIT WORK或者ROLLBACK WORK结束，其间的操作是原子的，要么都执行，要么都回滚。</p>
<p>​		主要限制，不能提交或回滚事务的某一部分，或分几个步骤提交。</p>
<p>​		<strong>带有保存点的扁平事务</strong></p>
<p>​		保存点（Savepoint）用来通知系统应该记住事务当前的状态，以便当之后发生错误时，事务能回到保存点当时的状态。</p>
<p>​		对于扁平的事务，其隐式地设置了一个保存点。然后在整个事务中，只有这一个保存点，因此，回滚只能回滚到事务开始时的状态。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">保存点用SAVE WORK函数建立</span><br><span class="line">SAVE　WORK：２</span><br><span class="line">回滚保存点２</span><br><span class="line">ROLL　BACK　WORK：２</span><br></pre></td></tr></table></figure>

<p><img src="/images/MySql%E4%BA%8B%E5%8A%A1/1.jpg" alt="示例"></p>
<h4 id="链事务"><a href="#链事务" class="headerlink" title="链事务"></a>链事务</h4><blockquote>
<p>可视为保存点模式的一种变种。</p>
</blockquote>
<p>思想：在提交一个事务时，释放不需要的数据对象，将必要的处理上下文隐式地传给下一个要开始的事务。</p>
<p>注：提交事务操作和开始下一个事务操作将合并为一个原子操作。下一个事务将看到上一个事务的结果。</p>
<p><img src="/images/MySql%E4%BA%8B%E5%8A%A1/2.jpg" alt="链事务"></p>
<p>与带有保存点的扁平事务不同处：</p>
<ul>
<li>带有保存点的扁平事务能回滚到任意正确的保存点。链事务中的回滚仅限于当前的事务，即只能恢复到最近一个的保存点</li>
<li>对于锁的处理，两者也不相同。链事务在执行COMMIT后即释放了当前事务所持有的锁，而带有保存点的扁平事务不影响迄今为止所持有的锁。</li>
</ul>
<h4 id="嵌套事务"><a href="#嵌套事务" class="headerlink" title="嵌套事务"></a>嵌套事务</h4><p>是一个层次结构框架。由一个顶层事务控制着各个层次的事务。</p>
<p><img src="/images/MySql%E4%BA%8B%E5%8A%A1/3.jpg" alt="嵌套事务"></p>
<h4 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h4><p>通常是一个在分布式环境下运行的扁平事务，因此需要根据数据所在位置访问网络中的不同节点。</p>
<p>​		对于InnoDB存储引擎来说，其支持扁平事务、带有保存点的事务、链事务、分布式事务。对于嵌套事务，并不原生支持。</p>
<h2 id="三、事务控制语句"><a href="#三、事务控制语句" class="headerlink" title="三、事务控制语句"></a>三、事务控制语句</h2><ul>
<li>START TRANSACTION | BEGIN：显式地开启一个事务</li>
<li>COMMIT：最简形式COMMIT，详细形式COMMIT WORK，二者几乎等价。COMMIT会提交事务，并使得已对数据库做地所有修改成为永久性地。</li>
<li>ROLLBACK：最简形式，ROLLBACK。也可改写为ROLLBACK　WORK，几乎等价。回滚会结束用户地事务，并撤销正在进行地所有未提交地修改。</li>
<li>SAVEPOINT identifier:SAVEPOINT允许在事务中创建一个保存点，一个事务中可以有多个SAVEPOINT；</li>
<li>RELEASE　SAVEPOINT　identifier：删除一个事务地保存点，当没有一个保存点执行这句语句时，会抛出一个异常。</li>
<li>ROLLBACK　TO［SAVEPOINT］identifier:这个语句与SAVEPOINT命令一起使用。可以把事务回滚到标记点，而不回滚在此标记点之前地任何工作。</li>
<li>SET TRANSACTION：设置事务隔离级别。READ UNCOMMITTED、READ COMMITTED、REPEATABLE READ、SERIALIZABLE</li>
</ul>
<p>COMMIT和COMMIT WORK语句基本是一致地，提交事务。不同之处在于COMMIT WORK用来控制事务结束后地行为是CHAIN还是RELEASE的。如果是CHAIN方式，那么事务就变成了链事务。</p>
<p><strong>completion_type</strong></p>
<p>该参数默认为0，表示没有任何操作。在这种设置下COMMIT和COMMIT WORK是完全等价的。当参数completion_type的值为1时，COMMIT WORK等同于COMMIT AND CHAIN，表示马上自动开启一个相同隔离级别的事务</p>
<p>例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; begin;</span><br><span class="line">Query OK, 0 rows affected (0.01 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; insert into l select 3;</span><br><span class="line">Query OK, 1 row affected (0.01 sec)</span><br><span class="line">Records: 1  Duplicates: 0  Warnings: 0</span><br><span class="line"></span><br><span class="line">mysql&gt; commit work;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; insert into l select 4;</span><br><span class="line">Query OK, 1 row affected (0.01 sec)</span><br><span class="line">Records: 1  Duplicates: 0  Warnings: 0</span><br><span class="line"></span><br><span class="line">mysql&gt; insert into l select 4;</span><br><span class="line">ERROR 1062 (23000): Duplicate entry &#x27;4&#x27; for key &#x27;PRIMARY&#x27;</span><br><span class="line">mysql&gt; rollback;</span><br><span class="line">Query OK, 0 rows affected (0.01 sec)</span><br><span class="line"></span><br><span class="line"># 回滚之后只有3没有4</span><br></pre></td></tr></table></figure>

<p>参数completion_type为2时，COMMIT WORK等同于COMMIT AND RELEASE。事务提交后会自动断开与服务器的连接。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; set @@completion_type=2;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; begin;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; insert into l select 4;</span><br><span class="line">Query OK, 1 row affected (0.01 sec)</span><br><span class="line">Records: 1  Duplicates: 0  Warnings: 0</span><br><span class="line"></span><br><span class="line">mysql&gt; commit work;</span><br><span class="line">Query OK, 0 rows affected (0.01 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select @@version\G;</span><br><span class="line">ERROR 2013 (HY000): Lost connection to MySQL server during query</span><br><span class="line">ERROR:</span><br><span class="line">No query specified</span><br><span class="line">#提交后断开连接</span><br></pre></td></tr></table></figure>

<p>InnoDB存储引擎中的事务都是原子的。</p>
<ul>
<li>构成事务的每条语句都会提交（成为永久）</li>
<li>或者所有语句都回滚</li>
</ul>
<p>虽然有ROLLBACK，但其并不是真正的结束一个事务，因此即使执行了<strong>ROLLBACK TO SAVEPOINT</strong>，之后也需要显式地运行COMMIT或ROLLBACK命令。</p>
<blockquote>
<p>ROLLBACK TO SAVEPOINT命令并不真正地结束事务</p>
</blockquote>
<h2 id="四、隐式提交的SQL语句"><a href="#四、隐式提交的SQL语句" class="headerlink" title="四、隐式提交的SQL语句"></a>四、隐式提交的SQL语句</h2><p>以下语句会产生一个隐式的提交操作，执行完语句后，会有隐式的COMMIT操作</p>
<ul>
<li>DDL语句：ALTER DATEBASE … UPGRADE DATA DIRECTORY NAME，ALTER EVENT，ALTER PROCEDURE，ALTER TABLE，ALTER VIEW，CREATE DATABASE，CREATE EVENT，CREATE INDEX，CREATE INDEX，CREATE PROCEDURE…</li>
<li>用来隐式地修改MySQL架构的操作:CREATE USER、DROP USER、GRANT、RENAME USER、REVOKE、SET PASSWORD</li>
<li>管理语句:ANALYZE TABLE…</li>
<li>注：TRUNCATE TABLE语句是DDL，虽然结果与DELETE相同，但是不能被回滚的</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM l\G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">a: 1</span><br><span class="line">*************************** 2. row ***************************</span><br><span class="line">a: 2</span><br><span class="line">2 rows in set (0.03 sec)</span><br><span class="line"></span><br><span class="line">ERROR:</span><br><span class="line">No query specified</span><br><span class="line"></span><br><span class="line">mysql&gt; BEGIN;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; TRUNCATE TABLE L;</span><br><span class="line">Query OK, 0 rows affected (0.12 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; ROLLBACK;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; SELECT * FROM l\G;</span><br><span class="line">Empty set (0.01 sec)</span><br><span class="line"></span><br><span class="line">ERROR:</span><br><span class="line">No query specified</span><br></pre></td></tr></table></figure>

<h2 id="五、对于事务操作的统计"><a href="#五、对于事务操作的统计" class="headerlink" title="五、对于事务操作的统计"></a>五、对于事务操作的统计</h2><p>InnoDB存储引擎是支持事务的</p>
<p>因此InnoDB存储引擎的应用需要在考虑<strong>每秒请求数</strong>（Question Per Second,QPS）的同时，应该关注每秒<strong>事务处理的能力</strong>(Transaction PerSecond,TPS)</p>
<p>计算TPS方式：(com_commit+com_rollback)&#x2F;time</p>
<p>前提：所有事务必须是显式提交的，如果存在隐式地提交和回滚（默认autocommit&#x3D;1），不会计算到com_commit和com_rollback变量中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SHOW GLOBAL STATUS LIKE &#x27;com_commit&#x27;\G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">Variable_name: Com_commit</span><br><span class="line">        Value: 10878</span><br><span class="line">1 row in set (0.03 sec)</span><br><span class="line"></span><br><span class="line">ERROR:</span><br><span class="line">No query specified</span><br><span class="line"></span><br><span class="line">mysql&gt; SHOW GLOBAL STATUS LIKE &#x27;com_rollback&#x27;\G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">Variable_name: Com_rollback</span><br><span class="line">        Value: 19</span><br><span class="line">1 row in set (0.01 sec)</span><br><span class="line"></span><br><span class="line">ERROR:</span><br><span class="line">No query specified</span><br><span class="line"></span><br><span class="line">mysql&gt;</span><br></pre></td></tr></table></figure>

<h2 id="六、事务的隔离级别"><a href="#六、事务的隔离级别" class="headerlink" title="六、事务的隔离级别"></a>六、事务的隔离级别</h2><h3 id="1、事务隔离级别"><a href="#1、事务隔离级别" class="headerlink" title="1、事务隔离级别"></a>1、事务隔离级别</h3><ul>
<li><p>READ UNCOMMITTED</p>
<p>读未提交，解决了回滚覆盖类型的更新丢失</p>
<ul>
<li>回滚丢失，事务回滚导致另一事务提交后的数据被还原</li>
<li>覆盖丢失，事务提交导致另一事务提交后的数据被覆盖</li>
</ul>
<p>但可能发生脏读，读取到其他未提交事务修改的数据</p>
</li>
<li><p>READ COMMITTED</p>
<p>读已提交，可能发生不可重复读，一个事务中两次查询结果不一致</p>
</li>
<li><p>REPEATABLE READ</p>
<p>可重复读，解决了不可重复度，确保同一事务的多个势力在并发读取数据时，会看到同样的数据行。</p>
<p>理论上会出现幻读，幻读指当用户读取某一范围的数据行时，另一事务在该范围插入了新行，用户再读取该范围数据时会发现有新的幻影行。</p>
</li>
<li><p>SERIALIZABLE</p>
<p>强制事务排序，解决互相冲突。该级别可能导致大量的超时现象和锁竞争，效率低下</p>
</li>
</ul>
<h3 id="2、事务隔离级别和锁的关系"><a href="#2、事务隔离级别和锁的关系" class="headerlink" title="2、事务隔离级别和锁的关系"></a>2、事务隔离级别和锁的关系</h3><p>InnoDB引擎在REPEATABLE READ事务隔离级别下，使用Next-Key Lock锁的算法,因此避免幻读产生。</p>
<p>在SERIALABLE的事务隔离级别，InnoDB存储引擎会对每个SELECT语句后自动加上LOCK IN SHARE MODE,为每个读取操作加一个共享锁</p>
<p>（1）事务隔离级别是SQL92定制的标准，相当于事务并发控制的整体解决方案，本质上是对锁和MVCC使用的封装，隐藏了底层细节。</p>
<p>（2）锁是数据库实现并发控制的基础，事务隔离性是采用锁来实现，对相应操作加不同的锁，就可以防止其他事务同时对数据进行读写操作。</p>
<p>（3）对用户来讲，首先选择使用隔离级别，当选用的隔离级别不能解决并发问题或需求时，才有必要在开发中手动的设置锁。</p>
<p>MYSQL默认隔离级别：可重复读</p>
<p>Oracle、SQLServer默认隔离级别：读已提交</p>
<h3 id="3、MySQL隔离级别控制"><a href="#3、MySQL隔离级别控制" class="headerlink" title="3、MySQL隔离级别控制"></a>3、MySQL隔离级别控制</h3><p>MySQL默认的事务隔离级别是Repeatable Read ，查看MySQL当前数据库的事务隔离级别命令如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">show variables like &#x27;tx_isolation&#x27;;</span><br><span class="line">select @@tx_isolation;</span><br></pre></td></tr></table></figure>


<p>设置事务隔离级别可以如下命令：  </p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> tx_isolation<span class="operator">=</span><span class="string">&#x27;READ-UNCOMMITTED&#x27;</span>;</span><br><span class="line"><span class="keyword">set</span> tx_isolation<span class="operator">=</span><span class="string">&#x27;READ-COMMITTED&#x27;</span>;</span><br><span class="line"><span class="keyword">set</span> tx_isolation<span class="operator">=</span><span class="string">&#x27;REPEATABLE-READ&#x27;</span>;</span><br><span class="line"><span class="keyword">set</span> tx_isolation<span class="operator">=</span><span class="string">&#x27;SERIALIZABLE&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h2 id="七、并发事务控制"><a href="#七、并发事务控制" class="headerlink" title="七、并发事务控制"></a>七、并发事务控制</h2><h3 id="1、并发事务"><a href="#1、并发事务" class="headerlink" title="1、并发事务"></a>1、并发事务</h3><p>事务并发处理带来的问题：</p>
<ul>
<li><p>更新丢失</p>
<p>两个或多个事务更新同一行记录，会产生更新丢失现象。</p>
<ul>
<li>回滚覆盖：一个事务回滚，把其他事务已提交数据覆盖。</li>
<li>提交覆盖：一个事务提交，把其他事务已提交数据覆盖。</li>
</ul>
</li>
<li><p>脏读：读取到其他事务未提交数据。</p>
</li>
<li><p>不可重复读：事务中，多次读取同一行数据，数据不一致</p>
</li>
<li><p>幻读：一个事务中多次按相同条件查询，查到的数据不一致。</p>
</li>
</ul>
<h3 id="2、解决方法"><a href="#2、解决方法" class="headerlink" title="2、解决方法"></a>2、解决方法</h3><h4 id="（1）排队"><a href="#（1）排队" class="headerlink" title="（1）排队"></a>（1）排队</h4><p>​		完全顺序执行所有事务的数据库操作，不需要加锁。序列号执行所有的事务单元，数据库某个时刻只处理一个事务操作，特点强一致性，处理性能低。</p>
<h4 id="（2）排他锁"><a href="#（2）排他锁" class="headerlink" title="（2）排他锁"></a>（2）排他锁</h4><p>​		如果事务之间涉及到相同的数据项时，会使⽤排他锁，或叫互斥<br>锁，先进⼊的事务独占数据项以后，其他事务被阻塞，等待前⾯的事务释放锁。</p>
<h4 id="（3）读写锁"><a href="#（3）读写锁" class="headerlink" title="（3）读写锁"></a>（3）读写锁</h4><p>​		读写锁就是进一步细化锁的颗粒度，区分读操作和写操作，让读和读之间不加锁，这样两个事务就可以同时被执⾏了  </p>
<h2 id="八、MVCC（重点）"><a href="#八、MVCC（重点）" class="headerlink" title="八、MVCC（重点）"></a>八、MVCC（重点）</h2><h3 id="1、什么是MVCC？"><a href="#1、什么是MVCC？" class="headerlink" title="1、什么是MVCC？"></a>1、什么是MVCC？</h3><p>MVCC（Multi-Version COncurrency COntrol）多版本并发控制。MVCC是一种并发控制的方法，一般在数据库管理系统中，实现对数据库的并发访问。MVCC使得大部分支持行锁的事务引擎，不再单纯的使用行锁来进行数据库的并发控制，取而代之的是把数据库的行锁与行的多个版本结合起来，只需要很小的开销，就可以实现非锁定读，从⽽⼤⼤提⾼数据库系统的并发性能。  </p>
<p>MVCC 在 MySQL InnoDB 中的实现主要是为了提⾼数据库并发性能，⽤更好的方式去处理<strong>读-写冲突</strong>，做到即使有读写冲突时，也能做到不加锁， <strong>非阻塞并发读</strong>  </p>
<h3 id="2、什么是当前读和快照读？"><a href="#2、什么是当前读和快照读？" class="headerlink" title="2、什么是当前读和快照读？"></a>2、什么是当前读和快照读？</h3><ul>
<li><p>当前读</p>
<p>读取的是记录最新版本，读取时还要保证其他并发事务不能修改当前记录（使用共享锁或排他锁），会对读取的记录进行加锁。实际上是一种加锁操作，悲观锁实现。</p>
</li>
<li><p>快照读</p>
<p>不加锁的非阻塞读；快照读的实现基于多版本并发控制，有可能是之前的历史版本。</p>
</li>
</ul>
<p><strong>MVCC就是为了实现读-写冲突不加锁，读指快照读，非当前读</strong></p>
<p><strong>当前读，快照读和MVCC的关系</strong></p>
<ul>
<li>MVCC多版本并发控制是【<strong>维持一个数据的多个版本，使得读写操作没有冲突</strong>】的概念</li>
<li>【<strong>快照读就是MySQL实现MVCC理想模型的其中一个非阻塞读功能</strong>】。当前读就是悲观锁具体功能实现</li>
<li>MVCC模型在MySQL中的具体实现由<strong>3个隐式字段，undo日志，Read View</strong>等去完成的</li>
</ul>
<h3 id="3、MVCC能解决什么问题，好处是？"><a href="#3、MVCC能解决什么问题，好处是？" class="headerlink" title="3、MVCC能解决什么问题，好处是？"></a>3、MVCC能解决什么问题，好处是？</h3><p><strong>数据库并发场景</strong></p>
<ul>
<li>读-读：不存在任何问题，也不需要并发控制</li>
<li>读-写：有线程安全问题，可能会造成事务隔离性问题，可能遇到脏读、幻读、不可重复读</li>
<li>谢谢：有线程安全问题，存在更新丢失问题，回滚覆盖、提交覆盖问题。</li>
</ul>
<p><strong>MVCC带来的好处是？</strong></p>
<p>解决读-写冲突的<strong>⽆锁并发控制</strong>，也就是为事务分配单向增⻓的时间戳，为每个修改保存⼀个版本，版本与事务时间戳关联，读操作只读该事务开始前的数据库的快照。  </p>
<h3 id="4、如何使用MVCC解决并发问题？"><a href="#4、如何使用MVCC解决并发问题？" class="headerlink" title="4、如何使用MVCC解决并发问题？"></a>4、如何使用MVCC解决并发问题？</h3><ul>
<li><p>MVCC + 悲观锁  </p>
<p>MVCC解决读写冲突，悲观锁解决写写冲突  </p>
</li>
<li><p>MVCC + 乐观锁</p>
<p>MVCC解决读写冲突，乐观锁解决写写冲突</p>
</li>
</ul>
<h3 id="5、MVCC实现原理"><a href="#5、MVCC实现原理" class="headerlink" title="5、MVCC实现原理"></a>5、MVCC实现原理</h3><p>MVCC目的就是多版本并发控制，数据库中的实现，为了解决读写冲突，实现原理主要是依赖记录中的<strong>3个隐式字段，undo日志，Read View</strong>来实现的</p>
<h4 id="（1）隐式字段"><a href="#（1）隐式字段" class="headerlink" title="（1）隐式字段"></a>（1）隐式字段</h4><p>每行记录除了我们自定义的字段外，还有数据库隐式定义的DB_TRX_ID，DB_ROLL_PTR，DB_ROW_ID等字段</p>
<ul>
<li>DB_TRX_ID<br>6 byte，最近修改(修改&#x2F;插⼊)事务 ID：记录创建这条记录&#x2F;最后⼀次修改该记录的事务 ID</li>
<li>DB_ROLL_PTR<br>7 byte，回滚指针，指向这条记录的上⼀个版本的undo log</li>
<li>DB_ROW_ID<br>6 byte，隐含的⾃增 ID（隐藏主键），如果数据表没有主键， InnoDB 会⾃动以DB_ROW_ID产⽣⼀<br>个聚簇索引</li>
</ul>
<p><img src="/images/MySql%E4%BA%8B%E5%8A%A1/4.jpg" alt="某条记录"></p>
<h4 id="（2）Read-View读视图"><a href="#（2）Read-View读视图" class="headerlink" title="（2）Read View读视图"></a>（2）Read View读视图</h4><p><strong>什么是Read View？</strong></p>
<p>ReadView就是事务进行快照读操作的时候产生的读视图（Read View）</p>
<p><strong>MVCC相关问题</strong></p>
<h4 id="（3）RR是如何在RC级的基础上解决不可重复读的？"><a href="#（3）RR是如何在RC级的基础上解决不可重复读的？" class="headerlink" title="（3）RR是如何在RC级的基础上解决不可重复读的？"></a>（3）RR是如何在RC级的基础上解决不可重复读的？</h4><p>Read View生成时机的不同，造成RC，RR级别下快照读的结果的不同</p>
<p><strong>在RC隔离级别下，是每个快照读都会生成并获取最新的Read View；</strong></p>
<p><strong>而在RR隔离级别下，则是同一个事务中的第一个快照读才会创建Read View，之后的快照读获取的都是同一个Read View</strong></p>
<h2 id="九、分布式事务"><a href="#九、分布式事务" class="headerlink" title="九、分布式事务"></a>九、分布式事务</h2><h3 id="1、MySQL数据库分布式事务"><a href="#1、MySQL数据库分布式事务" class="headerlink" title="1、MySQL数据库分布式事务"></a>1、MySQL数据库分布式事务</h3><p>分布式事务：允许多个独立的事务资源参与到一个全局的事务中。</p>
<p>在使用分布式事务时，Inn哦DB存储引擎的事务隔离级别必须设置为SERIALIZABLE。</p>
<p>分布式事务使用两段式提交（two-phase commit）的方式</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/mysql/" rel="tag">mysql</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E4%BA%8B%E5%8A%A1/" rel="tag">事务</a></li></ul>

    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-Mysql锁"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/08/01/Mysql%E9%94%81/"
    >Mysql锁</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/08/01/Mysql%E9%94%81/" class="article-date">
  <time datetime="2022-08-01T09:47:25.000Z" itemprop="datePublished">2022-08-01</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="MySql锁"><a href="#MySql锁" class="headerlink" title="MySql锁"></a>MySql锁</h1><blockquote>
<p>人们认为行就送总会增加开销。实际上，只有当实现本身会增加开销时，行级锁才会增加开销。InnoDB存储引擎不需要锁升级，因为一个锁和多个锁的开销是相同的。</p>
</blockquote>
<h2 id="一、什么是锁（what）"><a href="#一、什么是锁（what）" class="headerlink" title="一、什么是锁（what）"></a>一、什么是锁（what）</h2><p>​		锁是数据库系统区别于文件系统的一个关键特性。锁机制用于管理对共享资源的并发访问。</p>
<p>​		对于MyISAM引擎，其锁是表锁设计。并发情况下的读没有问题，但是并发插入时的性能就要差一些了。</p>
<h2 id="二、lock"><a href="#二、lock" class="headerlink" title="二、lock"></a>二、lock</h2><p>​		lock的对象是事务，用来锁定的是数据库中的对象，如表、页、行。并且一般lock的对象仅在事务commit或rollback后进行释放（不同事务隔离级别释放的时间可能不同）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SHOW ENGINE INNODB STATUS</span><br><span class="line">以及information_schema架构下的表INNODB_TRX、INNODB_LOCKS、INNODB_LOCK_WAITS来观察锁信息。</span><br></pre></td></tr></table></figure>

<h2 id="三、InnoDB存储引擎中的锁"><a href="#三、InnoDB存储引擎中的锁" class="headerlink" title="三、InnoDB存储引擎中的锁"></a>三、InnoDB存储引擎中的锁</h2><h3 id="1、锁的类型"><a href="#1、锁的类型" class="headerlink" title="1、锁的类型"></a>1、锁的类型</h3><p>InnoDB实现的两种标准行级锁：</p>
<ul>
<li>共享锁（S Lock），允许事务读一行数据</li>
<li>排他锁（X Lock），允许事务删除或更新一行数据</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>X</th>
<th>S</th>
</tr>
</thead>
<tbody><tr>
<td>X</td>
<td>不兼容</td>
<td>不兼容</td>
</tr>
<tr>
<td>S</td>
<td>不兼容</td>
<td>兼容</td>
</tr>
</tbody></table>
<p>注意：S和X锁都是行锁，兼容指对同一记录（row）锁的兼容性情况。</p>
<p><strong>意向锁</strong>：将锁定的对象分为多个层次，意向锁意味着事务希望在更细粒度上进行加锁。</p>
<blockquote>
<p>若将上锁的对象看成一棵树，那么对最下层的对象上锁，也就是对最细粒度的对象进行上锁，熟悉需要对粗粒度的对象上锁。</p>
</blockquote>
<p>InnoDB意向锁即为表级别的锁。</p>
<p>支持两种意向锁：</p>
<ul>
<li>意向共享锁（IS Lock），事务想要获得一张表中某几行的共享锁。</li>
<li>意向排他锁（IX Lock），事务想要获得一张表中某几行的排他锁。</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>IS</th>
<th>IX</th>
<th>S</th>
<th>X</th>
</tr>
</thead>
<tbody><tr>
<td>IS</td>
<td>兼容</td>
<td>兼容</td>
<td>兼容</td>
<td>不兼容</td>
</tr>
<tr>
<td>IX</td>
<td>兼容</td>
<td>兼容</td>
<td>不兼容</td>
<td>不兼容</td>
</tr>
<tr>
<td>S</td>
<td>兼容</td>
<td>不兼容</td>
<td>兼容</td>
<td>不兼容</td>
</tr>
<tr>
<td>X</td>
<td>不兼容</td>
<td>不兼容</td>
<td>不兼容</td>
<td>不兼容</td>
</tr>
</tbody></table>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> ENGINE INNODB STATUS查看当前锁请求的信息</span><br></pre></td></tr></table></figure>

<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">------------</span><br><span class="line">TRANSACTIONS</span><br><span class="line">------------</span><br><span class="line">Trx id counter <span class="number">261562</span></span><br><span class="line">Purge done for trx<span class="symbol">&#x27;s</span> n:o &lt; <span class="number">261560</span> undo n:o &lt; <span class="number">0</span> state: running but idle</span><br><span class="line">History list length <span class="number">8</span></span><br><span class="line">LIST OF TRANSACTIONS FOR EACH SESSION:</span><br><span class="line">---TRANSACTION <span class="number">283159487235888</span>, not started</span><br><span class="line"><span class="number">0</span> lock struct(<span class="name">s</span>), heap size <span class="number">1136</span>, <span class="number">0</span> row lock(<span class="name">s</span>)</span><br><span class="line">---TRANSACTION <span class="number">261561</span>, ACTIVE <span class="number">30</span> sec starting index read</span><br><span class="line">mysql tables in use <span class="number">1</span>, locked <span class="number">1</span></span><br><span class="line">LOCK WAIT <span class="number">2</span> lock struct(<span class="name">s</span>), heap size <span class="number">1136</span>, <span class="number">1</span> row lock(<span class="name">s</span>)</span><br><span class="line">MySQL thread id <span class="number">13</span>, OS thread handle <span class="number">27560</span>, query id <span class="number">173</span> localhost ::<span class="number">1</span> root updating</span><br><span class="line">update rlock set a=<span class="number">4</span> where a=<span class="number">1</span></span><br><span class="line">Trx read view will not see trx with id &gt;= <span class="number">261561</span>, sees &lt; <span class="number">261560</span></span><br><span class="line">------- TRX HAS BEEN WAITING <span class="number">12</span> SEC FOR THIS LOCK TO BE GRANTED:</span><br><span class="line">RECORD LOCKS space id <span class="number">1138</span> page no <span class="number">3</span> n bits <span class="number">72</span> index GEN_CLUST_INDEX of table `test`.`rlock` trx id <span class="number">261561</span> lock_mode X waiting</span><br><span class="line">Record lock, heap no <span class="number">2</span> PHYSICAL RECORD: n_fields <span class="number">4</span><span class="comment">; compact format; info bits 0</span></span><br><span class="line"> <span class="number">0</span>: len <span class="number">6</span><span class="comment">; hex 00000003b200; asc       ;;</span></span><br><span class="line"> <span class="number">1</span>: len <span class="number">6</span><span class="comment">; hex 00000003fda6; asc       ;;</span></span><br><span class="line"> <span class="number">2</span>: len <span class="number">7</span><span class="comment">; hex 2300000124157b; asc #   $ &#123;;;</span></span><br><span class="line"> <span class="number">3</span>: len <span class="number">4</span><span class="comment">; hex 80000001; asc     ;;</span></span><br><span class="line"></span><br><span class="line">------------------</span><br><span class="line">---TRANSACTION <span class="number">261560</span>, ACTIVE <span class="number">43</span> sec</span><br><span class="line"><span class="number">2</span> lock struct(<span class="name">s</span>), heap size <span class="number">1136</span>, <span class="number">4</span> row lock(<span class="name">s</span>)</span><br><span class="line">MySQL thread id <span class="number">12</span>, OS thread handle <span class="number">14848</span>, query id <span class="number">170</span> localhost ::<span class="number">1</span> root</span><br></pre></td></tr></table></figure>

<p>locks rec but not gap代表锁住的是一个索引，不是一个范围。</p>
<p>从InnoDB1.0版本开始，在INFORMATION_SCHEMA架构下添加了表<strong>INNODB_TRX</strong>、<strong>INNODB_LOCKS</strong>、<strong>INNODB_LOCK_WAITS</strong>。通过这三张表，用户可以更简单地监控当前事务并分析可能存在的锁问题。</p>
<p><strong>INNODB_TRX</strong></p>
<table>
<thead>
<tr>
<th>字段名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>trx_id</td>
<td>事务ID</td>
</tr>
<tr>
<td>trx_state</td>
<td>事务状态</td>
</tr>
<tr>
<td>trx_started</td>
<td>事务开始时间</td>
</tr>
<tr>
<td>trx_requested_lock_id</td>
<td>等待事务的锁ID。</td>
</tr>
<tr>
<td>trx_wait_started</td>
<td>事务等待开始时间</td>
</tr>
<tr>
<td>trx_weight</td>
<td>事务权重，反映了一个事务修改和锁住的行数。在InnoDB存储引擎中，发生死锁需要回滚时，Inn哦DB存储引擎会选择该值最小的进行回滚。</td>
</tr>
<tr>
<td>trx_mysql_thread_id</td>
<td>MySql中的线程ID</td>
</tr>
<tr>
<td>trx_query</td>
<td>事务运行的SQL语句</td>
</tr>
</tbody></table>
<p>例子：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> information_schema.INNODB_TRX\G;</span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span> <span class="number">1.</span> <span class="type">row</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line">                    trx_id: <span class="number">261579</span></span><br><span class="line">                 trx_state: <span class="keyword">RUNNING</span></span><br><span class="line">               trx_started: <span class="number">2022</span><span class="number">-08</span><span class="number">-02</span> <span class="number">09</span>:<span class="number">56</span>:<span class="number">47</span></span><br><span class="line">     trx_requested_lock_id: <span class="keyword">NULL</span></span><br><span class="line">          trx_wait_started: <span class="keyword">NULL</span></span><br><span class="line">                trx_weight: <span class="number">1</span></span><br><span class="line">       trx_mysql_thread_id: <span class="number">13</span></span><br><span class="line">                 trx_query: <span class="keyword">NULL</span></span><br><span class="line">       trx_operation_state: <span class="keyword">NULL</span></span><br><span class="line">         trx_tables_in_use: <span class="number">0</span></span><br><span class="line">         trx_tables_locked: <span class="number">1</span></span><br><span class="line">          trx_lock_structs: <span class="number">1</span></span><br><span class="line">     trx_lock_memory_bytes: <span class="number">1136</span></span><br><span class="line">           trx_rows_locked: <span class="number">1</span></span><br><span class="line">         trx_rows_modified: <span class="number">0</span></span><br><span class="line">   trx_concurrency_tickets: <span class="number">0</span></span><br><span class="line">       trx_isolation_level: REPEATABLE READ</span><br><span class="line">         trx_unique_checks: <span class="number">1</span></span><br><span class="line">    trx_foreign_key_checks: <span class="number">1</span></span><br><span class="line">trx_last_foreign_key_error: <span class="keyword">NULL</span></span><br><span class="line"> trx_adaptive_hash_latched: <span class="number">0</span></span><br><span class="line"> trx_adaptive_hash_timeout: <span class="number">0</span></span><br><span class="line">          trx_is_read_only: <span class="number">0</span></span><br><span class="line">trx_autocommit_non_locking: <span class="number">0</span></span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span> <span class="number">2.</span> <span class="type">row</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line">                    trx_id: <span class="number">261578</span></span><br><span class="line">                 trx_state: <span class="keyword">RUNNING</span></span><br><span class="line">               trx_started: <span class="number">2022</span><span class="number">-08</span><span class="number">-02</span> <span class="number">09</span>:<span class="number">56</span>:<span class="number">33</span></span><br><span class="line">     trx_requested_lock_id: <span class="keyword">NULL</span></span><br><span class="line">          trx_wait_started: <span class="keyword">NULL</span></span><br><span class="line">                trx_weight: <span class="number">4</span></span><br><span class="line">       trx_mysql_thread_id: <span class="number">12</span></span><br><span class="line">                 trx_query: <span class="keyword">NULL</span></span><br><span class="line">       trx_operation_state: <span class="keyword">NULL</span></span><br><span class="line">         trx_tables_in_use: <span class="number">0</span></span><br><span class="line">         trx_tables_locked: <span class="number">1</span></span><br><span class="line">          trx_lock_structs: <span class="number">2</span></span><br><span class="line">     trx_lock_memory_bytes: <span class="number">1136</span></span><br><span class="line">           trx_rows_locked: <span class="number">1</span></span><br><span class="line">         trx_rows_modified: <span class="number">2</span></span><br><span class="line">   trx_concurrency_tickets: <span class="number">0</span></span><br><span class="line">       trx_isolation_level: REPEATABLE READ</span><br><span class="line">         trx_unique_checks: <span class="number">1</span></span><br><span class="line">    trx_foreign_key_checks: <span class="number">1</span></span><br><span class="line">trx_last_foreign_key_error: <span class="keyword">NULL</span></span><br><span class="line"> trx_adaptive_hash_latched: <span class="number">0</span></span><br><span class="line"> trx_adaptive_hash_timeout: <span class="number">0</span></span><br><span class="line">          trx_is_read_only: <span class="number">0</span></span><br><span class="line">trx_autocommit_non_locking: <span class="number">0</span></span><br><span class="line"><span class="number">2</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>



<p><strong>INNODB_LOCKS</strong>查看锁</p>
<table>
<thead>
<tr>
<th>字段名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>lock_id</td>
<td>锁ID</td>
</tr>
<tr>
<td>lock_trx_id</td>
<td>事务ID</td>
</tr>
<tr>
<td>lock_mode</td>
<td>锁的模型</td>
</tr>
<tr>
<td>lock_type</td>
<td>锁的类型，表锁还是行锁</td>
</tr>
<tr>
<td>lock_table</td>
<td>要加锁的表</td>
</tr>
<tr>
<td>lock_index</td>
<td>锁住的索引</td>
</tr>
<tr>
<td>lock_space</td>
<td>锁对象的space id</td>
</tr>
<tr>
<td>lock_page</td>
<td>事务锁定页的数量，若为表锁，null</td>
</tr>
<tr>
<td>lock_rec</td>
<td>事务锁定行的数量，若为表锁，null</td>
</tr>
<tr>
<td>lock_data</td>
<td>事务锁定记录的主键值，若为表锁，null</td>
</tr>
</tbody></table>
<p>例子：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> information_schema.INNODB_LOCKS\G;</span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span> <span class="number">1.</span> <span class="type">row</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line">    lock_id: <span class="number">261579</span>:<span class="number">1140</span>:<span class="number">3</span>:<span class="number">2</span></span><br><span class="line">lock_trx_id: <span class="number">261579</span></span><br><span class="line">  lock_mode: X</span><br><span class="line">  lock_type: RECORD</span><br><span class="line"> lock_table: `test`.`rlock`</span><br><span class="line"> lock_index: <span class="keyword">PRIMARY</span></span><br><span class="line"> lock_space: <span class="number">1140</span></span><br><span class="line">  lock_page: <span class="number">3</span></span><br><span class="line">   lock_rec: <span class="number">2</span></span><br><span class="line">  lock_data: <span class="number">1</span></span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span> <span class="number">2.</span> <span class="type">row</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line">    lock_id: <span class="number">261578</span>:<span class="number">1140</span>:<span class="number">3</span>:<span class="number">2</span></span><br><span class="line">lock_trx_id: <span class="number">261578</span></span><br><span class="line">  lock_mode: X</span><br><span class="line">  lock_type: RECORD</span><br><span class="line"> lock_table: `test`.`rlock`</span><br><span class="line"> lock_index: <span class="keyword">PRIMARY</span></span><br><span class="line"> lock_space: <span class="number">1140</span></span><br><span class="line">  lock_page: <span class="number">3</span></span><br><span class="line">   lock_rec: <span class="number">2</span></span><br><span class="line">  lock_data: <span class="number">1</span></span><br><span class="line"><span class="number">2</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span>, <span class="number">1</span> warning (<span class="number">0.02</span> sec)</span><br></pre></td></tr></table></figure>

<p>INNODB_LOCK_WAITS事务的等待</p>
<table>
<thead>
<tr>
<th>字段</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>requesting_trx_id</td>
<td>申请锁资源的事务ID</td>
</tr>
<tr>
<td>requesting_lock_id</td>
<td>申请的锁的ID</td>
</tr>
<tr>
<td>blocking_trx_id</td>
<td>阻塞的事务ID</td>
</tr>
<tr>
<td>blocking_lock_id</td>
<td>阻塞的锁ID</td>
</tr>
</tbody></table>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> information_schema.INNODB_LOCK_WAITS\G;</span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span> <span class="number">1.</span> <span class="type">row</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line">requesting_trx_id: <span class="number">261579</span></span><br><span class="line">requested_lock_id: <span class="number">261579</span>:<span class="number">1140</span>:<span class="number">3</span>:<span class="number">2</span></span><br><span class="line">  blocking_trx_id: <span class="number">261578</span></span><br><span class="line"> blocking_lock_id: <span class="number">261578</span>:<span class="number">1140</span>:<span class="number">3</span>:<span class="number">2</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span>, <span class="number">1</span> warning (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>

<p>如果需要，用户可以根据三张表联合查询得到更直观的详细信息</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span></span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span>    r.trx_id waiting_trx_id,</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span>    r.trx_mysql_thread_id waiting_thread,</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span>    r.trx_query waiting_query,</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span>    b.trx_id blocking_trx_id,</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span>    b.trx_mysql_thread_id blocking_thread,</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span>    b.trx_query blocking_query</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">from</span> information_schema.innodb_lock_waits w</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">INNER</span> <span class="keyword">JOIN</span> information_schema.innodb_trx b</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">ON</span> b.trx_id <span class="operator">=</span> w.blocking_trx_id</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">INNER</span> <span class="keyword">JOIN</span> information_schema.innodb_trx r</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">ON</span> r.trx_id <span class="operator">=</span> w.requesting_trx_id\G;</span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span> <span class="number">1.</span> <span class="type">row</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line"> waiting_trx_id: <span class="number">261579</span></span><br><span class="line"> waiting_thread: <span class="number">13</span></span><br><span class="line">  waiting_query: <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> rlock <span class="keyword">for</span> <span class="keyword">update</span></span><br><span class="line">blocking_trx_id: <span class="number">261578</span></span><br><span class="line">blocking_thread: <span class="number">12</span></span><br><span class="line"> blocking_query: <span class="keyword">NULL</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span>, <span class="number">1</span> warning (<span class="number">0.01</span> sec)</span><br></pre></td></tr></table></figure>

<h3 id="2、一致性非锁定读"><a href="#2、一致性非锁定读" class="headerlink" title="2、一致性非锁定读"></a>2、一致性非锁定读</h3><p>​		一致性的非锁定读（consistent nonlocking read）是指</p>
<p>InnoDB存储引擎通过行多版本控制（multi versioning）的方式来读取当前执行时间数据库中行的数据。如果读取的行正在执行DELETE或UPDATE操作，这是读取操作不会因此去等待行上锁的释放。相反地，InnoDB存储引擎获取读取行的一个快照数据。</p>
<p><img src="/images/MySql%E9%94%81/1.png" alt="InnoDB存储引擎非锁定的一致性读"></p>
<p>之所以称其为非锁定读，因为不需要等待访问的行上X锁的释放。</p>
<p>​		在不同事务隔离级别下，读取方式不同，并不是在每个事务隔离级别下都是采用非锁定的一致性读。</p>
<p>​		一个行记录可能不止一个快照数据，一般称这种技术为行多版本技术。由此带来的并发控制，称之为多版本并发控制（Multi Version Concurrency Control，MVCC）。</p>
<ul>
<li>在READ COMMITTED事务隔离级别下，对于快照数据，非一致性读总是读取被锁定行的最新一份快照数据。</li>
<li>在REPEATABLE READ事务隔离级别下，对于快照数据，非一致性读总是读取事务开始时的行数据版本。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span>查询事务隔离级别</span><br><span class="line"><span class="keyword">SELECT</span> @<span class="variable">@tx</span>_isolation;</span><br></pre></td></tr></table></figure>

<h3 id="3、一致性锁定读"><a href="#3、一致性锁定读" class="headerlink" title="3、一致性锁定读"></a>3、一致性锁定读</h3><p>​	某些情况下，用户需要显式地对数据库读取操作进行加锁以保证数据逻辑的一致性。而这要求数据库支持加锁语句，即使是对于select的只读操作。</p>
<p>​		InnoDB存储引擎对于select语句支持两种一致性的锁定读(locking read)操作：</p>
<ul>
<li>select ··· for update</li>
<li>select ··· lock in share mode</li>
</ul>
<p>select ··· for update 对读取的行记录加一个x锁，其他事务不能对已锁定的行加上任何锁。</p>
<p>select ··· lock in share mode对读取的行记录加一个S锁，其他事务可以想被锁定的行加S锁，但如果加X锁，会被阻塞。</p>
<p>​		select···for update，select···lock in share mode必须在一个事务中，事务提交，锁释放。可使用begin，start transaction 或者set autocommit&#x3D;0。</p>
<h3 id="4、自增长与锁"><a href="#4、自增长与锁" class="headerlink" title="4、自增长与锁"></a>4、自增长与锁</h3><p>​	对于有自增长值得列得并发插入性能较差，事务必须等待前一个插入的完成（虽然不用等待事务的完成）。其次，对于INSERT···SELECT的大数据量的插入会影响插入的性能，因为另一个事务中的插入会被阻塞。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">max</span>(auto_inc_col) <span class="keyword">from</span> t <span class="keyword">for</span> <span class="keyword">update</span>;</span><br></pre></td></tr></table></figure>

<p>在InnoDB存储引擎中，自增长值得列必须是索引，同时必须是索引的第一个列。</p>
<h3 id="5、外键和锁"><a href="#5、外键和锁" class="headerlink" title="5、外键和锁"></a>5、外键和锁</h3><p>​		在InnoDB存储引擎中，对于一个外键列，如果没有显式地对这个列加索引，InnoDB存储引擎自动对其加一个索引，因为这样可以避免表锁———这比Oracle数据库做得好。</p>
<p>​		对于外键值的插入或更新，首先需要查询父表中的记录，即SELECT父表。但是对于父表的SELECT操作，不是使用一致性非锁定读方式，因为这样会发生数据不一致问题，因此这时使用的是SELECT···LOCK IN SHARE MODE方式，主动对父表加S锁。</p>
<p>示例：</p>
<table>
<thead>
<tr>
<th>时间</th>
<th>会话A</th>
<th>会话B</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>BEGIN</td>
<td></td>
</tr>
<tr>
<td>2</td>
<td>DELETE FROM parent WHERE id&#x3D;3;</td>
<td></td>
</tr>
<tr>
<td>3</td>
<td></td>
<td>BEGIN</td>
</tr>
<tr>
<td>4</td>
<td></td>
<td>INSERT INTO child SELECT 2,3#第二列是外键，执行该句被阻塞（waiting）</td>
</tr>
</tbody></table>
<h2 id="四、锁的算法"><a href="#四、锁的算法" class="headerlink" title="四、锁的算法"></a>四、锁的算法</h2><h3 id="1、行锁的3种算法"><a href="#1、行锁的3种算法" class="headerlink" title="1、行锁的3种算法"></a>1、行锁的3种算法</h3><p>InnoDB存储引擎有3种行锁的算法，分别是：</p>
<ul>
<li>Record Lock：单个行记录上的锁</li>
<li>Gap Lock：间隙锁，锁定一个范围，不包含记录本身</li>
<li>Next-Key Lock：Gap Lock+Record Lock，锁定一个范围，并且锁定记录本身</li>
</ul>
<p>Record Lock总是会去锁住<strong>索引</strong>记录，如果InnoDB存储引擎表在建立的时候没有设置任何一个索引，那么这时InnoDB存储引擎会使用隐式的主键来锁定。</p>
<blockquote>
<p><strong>使用算法需要添加索引</strong></p>
</blockquote>
<p>InnoDB对于行的查询都是采用Next-Key Lock算法。</p>
<p>例如：</p>
<p>​	一个索引有10，11，13和20，区间：</p>
<p>(-∞,10]</p>
<p>(10,11]</p>
<p>(11,13]</p>
<p>(13,20]</p>
<p>(20,+∞)</p>
<p>若事务T1已经通过next-key locking锁定了如下范围：</p>
<p>(10,11]、(11,13]</p>
<p>当插入新的记录12时，锁定的范围会变成:</p>
<p>(10,11]、(11,12]、(12,13]</p>
<p><strong>唯一索引</strong>：当查询的索引含有<strong>唯一属性</strong>时，InnoDB存储引擎会对Next-Key Lock进行优化，将其降级为Record Lock，即仅锁住索引本身，而不是范围，提高应用的并发性。</p>
<p><strong>辅助索引情况</strong></p>
<p>实例：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> z ( a <span class="type">int</span>,b <span class="type">int</span>,<span class="keyword">PRIMARY</span> KEY(a),KEY(b));</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> z <span class="keyword">select</span> <span class="number">1</span>,<span class="number">1</span>;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> z <span class="keyword">select</span> <span class="number">3</span>,<span class="number">1</span>;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> z <span class="keyword">select</span> <span class="number">5</span>,<span class="number">3</span>;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> z <span class="keyword">select</span> <span class="number">7</span>,<span class="number">6</span>;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> z <span class="keyword">select</span> <span class="number">10</span>,<span class="number">8</span>;</span><br></pre></td></tr></table></figure>

<p>事务A</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> z <span class="keyword">where</span> b<span class="operator">=</span><span class="number">3</span> <span class="keyword">for</span> <span class="keyword">update</span></span><br></pre></td></tr></table></figure>

<p>sql通过索引列b进行查询，使用传统的Next-Key Locking技术加锁。</p>
<p>由于有两个索引，需要分别进行锁定。</p>
<p>对于辅助索引，加上的是Next-Key Lock,锁定的范围是**(1,3)<strong>，特别需要注意的是，InnoDB存储引擎会对辅助索引下一个键值加上gap lock，即还有一个辅助索引范围为</strong>(3,6)**的锁。</p>
<p>Gap Lock的作用是为了阻止多个事务将记录插入到同一范围内，而这会导致Phantom Problem问题的产生。</p>
<h3 id="2、解决Phantom-Problem（幻读）"><a href="#2、解决Phantom-Problem（幻读）" class="headerlink" title="2、解决Phantom Problem（幻读）"></a>2、解决Phantom Problem（幻读）</h3><p>Phantom Problem指同一事务下，连续执行两次同样的SQL语句可能导致不同的结果，第二次的SQL语句可能会返回之前不存在的行。</p>
<p>​		InnoDB存储引擎默认的事务隔离级别是<strong>REPEATABLE READ</strong>，在该隔离级别下，其采用Next-Key Locking方式加锁。</p>
<p>​		而在事务隔离级别<strong>READ COMMITED</strong>下，其仅采用Record Lock；</p>
<p>实现唯一性检查：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">table</span> <span class="keyword">WHERE</span> col <span class="operator">=</span> xxx LOCK <span class="keyword">IN</span> SHARE MODE;</span><br><span class="line"></span><br><span class="line">If <span class="keyword">not</span> found <span class="keyword">any</span> <span class="type">row</span>:</span><br><span class="line">	# <span class="keyword">unique</span> <span class="keyword">for</span> <span class="keyword">insert</span> <span class="keyword">value</span></span><br><span class="line">	<span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">table</span> <span class="keyword">VALUES</span> (...);</span><br></pre></td></tr></table></figure>



<table>
<thead>
<tr>
<th>时间</th>
<th>会话A</th>
<th>会话B</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>begin</td>
<td></td>
</tr>
<tr>
<td>2</td>
<td>select * from z where b &#x3D; 4 lock in share mode；（S锁）</td>
<td></td>
</tr>
<tr>
<td>3</td>
<td></td>
<td>select * from z where b &#x3D; 4 lock in share mode；（S锁）</td>
</tr>
<tr>
<td>4</td>
<td>INSERT INTO z SELECT 4，4；#阻塞</td>
<td></td>
</tr>
<tr>
<td>5</td>
<td></td>
<td>INSERT INTO z SELECT 4，4；<br>ERROR 1213（40001）:Deadlock found when trying to get lock;try restarting transaction#抛出死锁异常</td>
</tr>
<tr>
<td>6</td>
<td>#INSERT插入成功</td>
<td></td>
</tr>
</tbody></table>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> session tx_isolation<span class="operator">=</span><span class="number">0</span> #设置事务隔离级别</span><br></pre></td></tr></table></figure>



<p>锁定由Next-Key Lock算法降级为了Record Lock，从而提高应用的并发性。</p>
<h2 id="五、锁问题"><a href="#五、锁问题" class="headerlink" title="五、锁问题"></a>五、锁问题</h2><h3 id="1、脏读"><a href="#1、脏读" class="headerlink" title="1、脏读"></a>1、脏读</h3><p>脏数据：指事务对缓冲池中行记录的修改，并且还没有被提交（commit）。</p>
<p>如果读到了脏数据，即一个事务可以读到另外一个事务中未提交的数据，显然违反了数据库隔离性。</p>
<p>脏读：指的是不同的事务下，当前事务可以读到另外事务未提交的数据，可以读到脏数据。</p>
<p>示例：</p>
<table>
<thead>
<tr>
<th>时间</th>
<th>会话A</th>
<th>会话B</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>set session tx_isolation&#x3D;0;</td>
<td></td>
</tr>
<tr>
<td>2</td>
<td></td>
<td>set session tx_isolation&#x3D;0;</td>
</tr>
<tr>
<td>3</td>
<td></td>
<td>begin;</td>
</tr>
<tr>
<td>4</td>
<td></td>
<td>mysql&gt; select * from l;<br>a<br>1<br>2</td>
</tr>
<tr>
<td>5</td>
<td>insert into l select 3;</td>
<td></td>
</tr>
<tr>
<td>6</td>
<td></td>
<td>mysql&gt; select * from l;<br/>a<br/>1<br/>2<br>3</td>
</tr>
</tbody></table>
<p>脏读发生条件需要事务隔离级别为READ UNCOMMITTED</p>
<ul>
<li>InnoDB存储引擎默认的事务隔离级别为<strong>READ REPEATABLE</strong></li>
<li>Microsoft SQL Server数据库为READ COMMITTED</li>
<li>Oracle数据库也是READ COMMITTED</li>
</ul>
<h3 id="2、不可重复读"><a href="#2、不可重复读" class="headerlink" title="2、不可重复读"></a>2、不可重复读</h3><p>不可重复读和脏读的区别是：脏读是读到未提交的数据，而不可重复读读到的却是已经提交的数据。</p>
<table>
<thead>
<tr>
<th>时间</th>
<th>会话A</th>
<th>会话B</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>set session tx_isolation&#x3D;1</td>
<td></td>
</tr>
<tr>
<td>2</td>
<td></td>
<td>set session tx_isolation&#x3D;1</td>
</tr>
<tr>
<td>3</td>
<td>begin</td>
<td>begin</td>
</tr>
<tr>
<td>4</td>
<td>mysql&gt; select * from l;<br>a<br>1</td>
<td></td>
</tr>
<tr>
<td>5</td>
<td></td>
<td>insert into l select 2;</td>
</tr>
<tr>
<td>6</td>
<td></td>
<td>commit;</td>
</tr>
<tr>
<td>7</td>
<td>mysql&gt; select * from l;<br/>a<br/>1<br>2</td>
<td></td>
</tr>
</tbody></table>
<p>隔离级别READ COMMITTED下允许不可重复读现象</p>
<p>在NextKey Lock算法下，对于索引的扫描，不仅是锁住扫描到的所有，还所著索引覆盖的范围(gap)。</p>
<p>InnoDB存储引擎的默认事务隔离级别是READ REPEATABLE，采用Next-Key Lock算法，避免了不可重复读现象。</p>
<h3 id="3、丢失更新"><a href="#3、丢失更新" class="headerlink" title="3、丢失更新"></a>3、丢失更新</h3><p>一个事务的更新操作被另一个事务的更新操作覆盖，导致数据结果不一致。</p>
<p>示例：</p>
<ul>
<li>事务T1将行记录r更新为v1，但是事务T1并未提交</li>
<li>与此同时，事务T2将行记录r更新为v2，事务T2未提交</li>
<li>事务T1提交。</li>
<li>事务T2提交。</li>
</ul>
<p>在当前数据库的任何隔离级别下，都不会导致数据库理论意义上丢失更新问题。因为即使是READ UNCOMMITTED的事务隔离级别，对于行的DML操作，需要对行或其他粗粒度级别的对象加锁。</p>
<p><strong>逻辑意义的丢失更新问题</strong></p>
<p>示例：</p>
<ul>
<li>事务T1查询一行数据，放入本地内存，并显示给一个终端用户User1.</li>
<li>事务T2也查询改行数据，并将取得的数据显示给终端用户User2</li>
<li>User1修改这行记录，更新数据库并提交。</li>
<li>User2修改这行记录，更新数据库并提交。</li>
</ul>
<p>（重点）需要在数据库层解决这个问题，避免任何可能发生丢失更新的情况。</p>
<blockquote>
<p>最好将操作串行化</p>
</blockquote>
<p>处理方法：</p>
<table>
<thead>
<tr>
<th>时间</th>
<th>会话A</th>
<th>会话B</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>begin;</td>
<td></td>
</tr>
<tr>
<td>2</td>
<td>select cash into @cash from account where user &#x3D;pUser for update;</td>
<td></td>
</tr>
<tr>
<td>3</td>
<td></td>
<td>select cash into @cash from account where user &#x3D;pUser for update;#等待</td>
</tr>
<tr>
<td></td>
<td>···</td>
<td>···</td>
</tr>
<tr>
<td>m</td>
<td>update account set cash&#x3D;@cash-9000 where user&#x3D;pUser;</td>
<td></td>
</tr>
<tr>
<td>m+1</td>
<td>commit;</td>
<td></td>
</tr>
<tr>
<td>m+2</td>
<td></td>
<td>update account set cash&#x3D;@cash-1 where user&#x3D;pUser;</td>
</tr>
<tr>
<td>m+3</td>
<td></td>
<td>commit;</td>
</tr>
</tbody></table>
<h2 id="六、阻塞"><a href="#六、阻塞" class="headerlink" title="六、阻塞"></a>六、阻塞</h2><blockquote>
<p>因为不同锁之间的兼容性关系，有些时刻一个事务中的锁需要等待另一个事务中的锁释放它所占用的资源</p>
</blockquote>
<p>参数innodb_lock_wait_timeout</p>
<ul>
<li>用来控制等待的时间（默认50秒）</li>
<li>动态的</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">set</span> @<span class="variable">@innodb</span>_lock_wait_timeout<span class="operator">=</span><span class="number">60</span>;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.01</span> sec)</span><br></pre></td></tr></table></figure>



<p>参数innodb_rollback_on_timeout</p>
<ul>
<li>设定是否在等待超时时对进行中的事务进行回滚操作（默认是OFF，不回滚）</li>
<li>静态，不可在启动时修改</li>
</ul>
<blockquote>
<p>默认情况下InnoDB存储引擎不会回滚超时引发的错误异常</p>
</blockquote>
<h2 id="七、死锁"><a href="#七、死锁" class="headerlink" title="七、死锁"></a>七、死锁</h2><h3 id="1、死锁的概念"><a href="#1、死锁的概念" class="headerlink" title="1、死锁的概念"></a>1、死锁的概念</h3><p><strong>死锁指两个或两个以上的事务在执行过程中，因争夺锁资源而造成的一种互相等待的现象。</strong></p>
<h3 id="2、死锁概率"><a href="#2、死锁概率" class="headerlink" title="2、死锁概率"></a>2、死锁概率</h3><ul>
<li>系统中事务的数量（n），数量越多发生死锁的概率越大</li>
<li>每个事务操作的数量（r），每个事务操作的数量越多，发生死锁的概率越大</li>
<li>操作数据的集合（R），越小则发生死锁的概率越大</li>
</ul>
<h3 id="3、死锁的示例"><a href="#3、死锁的示例" class="headerlink" title="3、死锁的示例"></a>3、死锁的示例</h3><p>1213错误提示，表示事务发生了死锁。</p>
<h4 id="（1）AB-BA死锁："><a href="#（1）AB-BA死锁：" class="headerlink" title="（1）AB-BA死锁："></a>（1）AB-BA死锁：</h4><table>
<thead>
<tr>
<th>时间</th>
<th>会话A</th>
<th>会话B</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>begin;</td>
<td></td>
</tr>
<tr>
<td>2</td>
<td>mysql&gt; select * from l where a&#x3D;2 for update;<br>a<br>2</td>
<td>begin;</td>
</tr>
<tr>
<td>3</td>
<td></td>
<td>mysql&gt; select * from l where a&#x3D;5 for update;<br>a<br>5</td>
</tr>
<tr>
<td>4</td>
<td>mysql&gt; select * from l where a&#x3D;5 for update;<br>#等待</td>
<td></td>
</tr>
<tr>
<td>5</td>
<td></td>
<td>mysql&gt; select * from l where a&#x3D;2 for update;<br>ERROR 1213 (40001): Deadlock found when trying to get lock; try restarting transaction</td>
</tr>
</tbody></table>
<p>InnoDB存储引擎并不会回滚大部分的错误异常，但是死锁除外。发现死锁后，InnoDB存储引擎会马上回滚一个事务。因此如果在应用程序中捕获了1213错误，并不需要对其进行回滚。</p>
<h4 id="（2）持有X锁，等待队列存在S锁"><a href="#（2）持有X锁，等待队列存在S锁" class="headerlink" title="（2）持有X锁，等待队列存在S锁"></a>（2）持有X锁，等待队列存在S锁</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> l (</span><br><span class="line">    a <span class="type">int</span> <span class="keyword">primary</span> key</span><br><span class="line">)engine<span class="operator">=</span>InnoDB</span><br><span class="line">inset <span class="keyword">into</span> l <span class="keyword">values</span>(<span class="number">1</span>);</span><br><span class="line">inset <span class="keyword">into</span> l <span class="keyword">values</span>(<span class="number">2</span>);</span><br><span class="line">inset <span class="keyword">into</span> l <span class="keyword">values</span>(<span class="number">5</span>);</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>时间</th>
<th>会话A</th>
<th>会话B</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>begin;</td>
<td></td>
</tr>
<tr>
<td>2</td>
<td></td>
<td>begin;</td>
</tr>
<tr>
<td>3</td>
<td>select * from l where a&#x3D;5 for update;</td>
<td></td>
</tr>
<tr>
<td>4</td>
<td></td>
<td>select * from l where a&lt;&#x3D;5 lock in share mode;<br>–等待</td>
</tr>
<tr>
<td>5</td>
<td>insert into t values(4);<br>ERROR 1213 (40001): Deadlock found when trying to get lock; try restarting transaction</td>
<td></td>
</tr>
<tr>
<td>6</td>
<td></td>
<td>–事务获得锁，正常运行</td>
</tr>
</tbody></table>
<p>会话A持有X锁，会话B之后持有S锁，进入等待，此时会话A插入记录4，发生死锁。原因是会话A持有记录5的X锁，会话B持有记录1，记录2的S锁，等待记录5的S锁，此时会话A插入记录4，会话B在持有记录5的S锁之后，还要获得记录4的S锁，不合理。</p>
<p>因此，InnoDB存储引擎主动选择死锁。回滚的是undo log记录大的事务。</p>
<h2 id="八、锁升级"><a href="#八、锁升级" class="headerlink" title="八、锁升级"></a>八、锁升级</h2><blockquote>
<p><strong>InnoDB存储引擎不存在锁升级的问题。</strong></p>
</blockquote>
<p>因为其不是根据每个记录来产生行锁的，相反，其根据每个事务访问的每个页对锁进行管理的，采用的是位图的方式。因此不管一个事务锁住页中一个记录还是多个记录，开销通常是一致的。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/mysql/" rel="tag">mysql</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%94%81/" rel="tag">锁</a></li></ul>

    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-Mysql索引"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/07/28/Mysql%E7%B4%A2%E5%BC%95/"
    >Mysql索引</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/07/28/Mysql%E7%B4%A2%E5%BC%95/" class="article-date">
  <time datetime="2022-07-28T03:34:25.000Z" itemprop="datePublished">2022-07-28</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="MySql索引"><a href="#MySql索引" class="headerlink" title="MySql索引"></a>MySql索引</h1><h2 id="一、什么是索引（what）"><a href="#一、什么是索引（what）" class="headerlink" title="一、什么是索引（what）"></a>一、什么是索引（what）</h2><p>索引：对数据库中一列或多列的值进行排序的一种结构</p>
<h2 id="二、为什么用索引（why）"><a href="#二、为什么用索引（why）" class="headerlink" title="二、为什么用索引（why）"></a>二、为什么用索引（why）</h2><p>当表中由大量记录时，若要对表进行查询</p>
<p>第一种方式，可进行全表搜索，是将所有记录一一取出，和查询条件进行一一对比，然后返回满足条件的记录，这样做会消耗大量数据库系统时间，并造成大量磁盘I&#x2F;O操作。</p>
<p>第二种方式，在表中建立索引，然后在索引中找到符合查询条件的索引值，最后通过保存在索引中的ROWID（相当于页码）快速找到表中对应的记录。</p>
<p>优点：</p>
<ul>
<li>索引大大加快数据的检索速度</li>
<li>创建唯一性索引，保证数据库表中每一行数据的唯一性。</li>
<li>加速表和表之间的连接</li>
<li>在使用分组和排序子句进行数据检索时，可以显著减少查询中分组和排序的时间。</li>
</ul>
<p>缺点：</p>
<ul>
<li>额外的占用物理空间</li>
<li>对表中数据进行增加、删除和修改的时候，索引也要动态的维护，降低了数据的维护速度。</li>
</ul>
<h2 id="三、如何使用索引（how）"><a href="#三、如何使用索引（how）" class="headerlink" title="三、如何使用索引（how）"></a>三、如何使用索引（how）</h2><blockquote>
<p>B+树索引就是传统意义上的索引，目前关系型数据库系统中查找最为常用和最为有效的索引。</p>
</blockquote>
<h3 id="1、索引类型"><a href="#1、索引类型" class="headerlink" title="1、索引类型"></a>1、索引类型</h3><p><strong>索引存储结构划分</strong>：B Tree索引、Hash索引、FULLTEXT全文索引、R Tree索引</p>
<p><strong>从应用层次划分</strong>：普通索引、唯一索引、主键索引、复合索引</p>
<h4 id="（1）普通索引"><a href="#（1）普通索引" class="headerlink" title="（1）普通索引"></a>（1）普通索引</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CREATE INDEX &lt;索引名字&gt; ON tablename(字段名)</span><br><span class="line">ALTER TABLE tablename ADD INDEX[索引的名字](字段名);</span><br><span class="line">CREATE TABLE tablename ([...],INDEX [索引的名字](字段名))</span><br></pre></td></tr></table></figure>

<h4 id="（2）唯一索引"><a href="#（2）唯一索引" class="headerlink" title="（2）唯一索引"></a>（2）唯一索引</h4><p>索引字段的值必须唯一，允许有空值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CREATE UNIQUE INDEX &lt;索引的名字&gt; ON tablename(字段名);</span><br><span class="line">ALTER TABLE tablename ADD UNIQUE INDEX[索引的名字](字段名);</span><br><span class="line">CREATE TABLE tablename([...],UNIQUE[索引的名字](字段名))</span><br></pre></td></tr></table></figure>

<h4 id="（3）主键索引"><a href="#（3）主键索引" class="headerlink" title="（3）主键索引"></a>（3）主键索引</h4><p>特殊的唯一索引，不允许有控制，每个表只能有一个主键。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE tablename([...],PRIMARY KEY(字段名));</span><br><span class="line">ALTER TABLE tablename ADD PRIMARY KEY(字段名);</span><br></pre></td></tr></table></figure>

<h4 id="（4）复合索引"><a href="#（4）复合索引" class="headerlink" title="（4）复合索引"></a>（4）复合索引</h4><p>相比多个单一索引，复合索引所需的开销更小。</p>
<p>窄索引指索引列为1-2列的索引，宽索引指超过2列的索引，设计索引的重要原则就是能用窄索引不用宽索引。因为窄索引往往比组合索引更有效</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CREATE INDEX&lt;索引的名字&gt; ON tablename(字段名1,字段名2...);</span><br><span class="line">ALTER TABLE tablename ADD INDEX[索引的名字](字段名1,字段名2...);</span><br><span class="line">CREATE TABLE tablename([...],INDEX[索引的名字](字段名1,字段名2...));</span><br></pre></td></tr></table></figure>

<p>注：复合索引字段是有顺序的</p>
<h4 id="（5）全文索引"><a href="#（5）全文索引" class="headerlink" title="（5）全文索引"></a>（5）全文索引</h4><p>使用情景：查询操作再数据量比较少时，可以使用like模糊查询，但是对于大量的文本数据检索，效率很低。如果使用全文索引，查询速度回避like快很多倍。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CREATE FULLTEXT INDEX&lt;索引的名字&gt; ON tablename(字段名);</span><br><span class="line">ALTER TABLE tablename ADD FULLTEXT[索引的名字](字段名);</span><br><span class="line">CREATE TABLE tablename([...],FULLTEXT KEY[索引的名字](字段名));</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#查询语句</span><br><span class="line">select * from user where match(name) against(&#x27;aaa&#x27;);</span><br></pre></td></tr></table></figure>

<p>注意事项：</p>
<ul>
<li>全文索引必须在字符串、文本字段上建立</li>
<li>必须在最小字符和最大字符之间才会有效（innodb:3-84；myisam:4-84）</li>
<li>全文索引字段值要进行切词处理，按syntax字符进行切割，例如b+aaa,切分成b和aaa</li>
<li>全文索引匹配查询，默认使用的是等值匹配，例如a匹配a，不会匹配ab,ac。如果想匹配可以在布尔模式下搜索a*</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select * from user where match(name) against(&#x27;a*&#x27; in blooean mode);</span><br><span class="line">#+/- 运算符代表单词必须出现或一定不出现时方能匹配</span><br><span class="line">SELECT * FROM articles WHERE MATCH (title,body)</span><br><span class="line">    AGAINST (&#x27;+MySQL -YourSQL&#x27; IN BOOLEAN MODE);</span><br></pre></td></tr></table></figure>

<h3 id="2、索引原理"><a href="#2、索引原理" class="headerlink" title="2、索引原理"></a>2、索引原理</h3><blockquote>
<p>存储引擎用于快速查找记录的一种数据结构</p>
</blockquote>
<h4 id="（1）Hash结构"><a href="#（1）Hash结构" class="headerlink" title="（1）Hash结构"></a>（1）Hash结构</h4><p>底层实现由Hash表实现，根据键值&lt;key,value&gt;存储数据的value值，单个key查询，等值查询。</p>
<p>Hash索引可以方便的提供等值查询，但是对于范围查询需要全表扫描。</p>
<p>Hash索引在MySQL中Hash结构主要应用在Memory元素的Hash索引、InnoDB自适应哈希索引。</p>
<p><strong>InnoDB自适应哈希索引</strong></p>
<blockquote>
<p>在使用Hash索引访问时，一次性查找就能定位数据，等值查询效率要优于B+Tree；</p>
</blockquote>
<p>​		InnoDB自适应哈希索引为了提升效率，InnoDB存储引擎会监控表上各个索引页的查询，当InnoDB注意到某些索引值访问非常频繁时，会在内存中基于B+Tree索引在创建一个哈希索引，是的内存中的B+Tree索引具备哈希索引的功能。</p>
<p>即能够快速定值访问频繁访问的索引页。</p>
<p>自动根据索引页访问的频率和模式自动地为某些热点页 建立哈希索引来加速访问。</p>
<p>InnoDB自适应哈希索引的功能，用户只能选择开启或关闭功能，无法进行人工干涉。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">show engine innodb status\G;</span><br><span class="line">show variables like &#x27;%innodb_adaptive%&#x27;</span><br></pre></td></tr></table></figure>



<h4 id="（2）B-Tree结构（重点）"><a href="#（2）B-Tree结构（重点）" class="headerlink" title="（2）B+Tree结构（重点）"></a>（2）B+Tree结构（重点）</h4><p>B-Tree结构</p>
<ul>
<li>索引值和data数据分布在整棵树结构中</li>
<li>每个节点可以存放多个索引值及对应的data数据</li>
<li>树节点的多个索引值从左到右升序排列</li>
</ul>
<p>B+Tree结构</p>
<ul>
<li>非叶子节点不存储data数据，只存储索引值，便于存储更多索引值。</li>
<li>叶子节点包含了所有的索引值和data数据</li>
<li>叶子节点用指针连接，提高区间的访问性能</li>
</ul>
<p><strong>为什么数据库存储使用b+树，而不是二叉树？</strong></p>
<p>二叉树树高过高，每次查询都需要访问过多节点，即访问数据块过多造成磁盘IO过多影响性能。B+树一次随机io能拿出更多数据。</p>
<p><strong>N叉树的N是多少？</strong></p>
<p>InnoDB一个整数字段索引为例，N差不多是1200。MySql默认一个page为16k，假设主键，一个整数（bigint）字段索引的长度为8B，另外每个索引还跟着6B的指向其子树的指针;所以16KB&#x2F;14B ≈ 1170</p>
<h2 id="四、B-树"><a href="#四、B-树" class="headerlink" title="四、B+树"></a>四、B+树</h2><p>​		B+树是为磁盘或其他直接存取辅助设备设计的一种平衡查找树。在B+树中，所有记录节点都是按键值的大小顺序存放在同一层的叶子节点上，由各叶子节点指针进行连接。</p>
<p><img src="/images/MySql%E7%B4%A2%E5%BC%95/%E9%AB%98%E5%BA%A6%E4%B8%BA2%E7%9A%84B+tree.jpg" alt="高度为2的B+tree"></p>
<h3 id="1、插入操作"><a href="#1、插入操作" class="headerlink" title="1、插入操作"></a>1、插入操作</h3><table>
<thead>
<tr>
<th>Leaf Page满</th>
<th>Index Page满</th>
<th>操作</th>
</tr>
</thead>
<tbody><tr>
<td>No</td>
<td>No</td>
<td>直接将记录插入到叶子节点</td>
</tr>
<tr>
<td>Yes</td>
<td>No</td>
<td>1）拆分Leaf Page<br>2）将中间的节点放入到Index Page中<br>3）小于中间节点的记录放左边<br>4）大于或等于中间节点的记录放右边</td>
</tr>
<tr>
<td>Yes</td>
<td>Yes</td>
<td>1）拆分Leaf Page<br/>2）将中间的节点放入到Index Page中<br/>3）小于中间节点的记录放左边<br/>4）大于或等于中间节点的记录放右边<br>5）小于中间节点的记录放左边<br>6）大于中间节点的记录放右边<br>7）中间节点放入上一层Index Page</td>
</tr>
</tbody></table>
<p>示例：</p>
<p><img src="/images/MySql%E7%B4%A2%E5%BC%95/%E5%9B%BE5-7.jpg" alt="直接插入28"></p>
<p><img src="/images/MySql%E7%B4%A2%E5%BC%95/%E5%9B%BE5-8.jpg" alt="插入70"></p>
<p><img src="/images/MySql%E7%B4%A2%E5%BC%95/%E5%9B%BE5-9.jpg" alt="插入95"></p>
<h4 id="旋转功能"><a href="#旋转功能" class="headerlink" title="旋转功能"></a><strong>旋转功能</strong></h4><p>why</p>
<p>​		为了保持平衡，对于新插入的键值可能需要做大量的拆分页（split）操作。因为B+树结构主要用于磁盘，所有应该再可能的情况下尽量减少页的拆分操作。</p>
<p>因此，B+树提供了类似与平衡二叉树的旋转功能。</p>
<p>how</p>
<p>​		旋转发生在Leaf Page已经满，但是其左右兄弟节点没有满的情况下。会先将记录移到所在页的兄弟节点上。</p>
<p>通常情况，做兄弟会被首先检查用来做旋转操作。</p>
<p>示例：</p>
<p><img src="/images/MySql%E7%B4%A2%E5%BC%95/%E5%9B%BE5-7.jpg" alt="准备插入70"></p>
<p><img src="/images/MySql%E7%B4%A2%E5%BC%95/B+tree%E7%9A%84%E6%97%8B%E8%BD%AC.jpg" alt="旋转后"></p>
<h3 id="2、删除操作"><a href="#2、删除操作" class="headerlink" title="2、删除操作"></a>2、删除操作</h3><p>​		B+树使用填充因子（fill factor）来控制树的删除变化，50%是填充因子可设的最小值。</p>
<table>
<thead>
<tr>
<th>叶子节点小于填充因子</th>
<th>中间节点小于填充因子</th>
<th>操作</th>
</tr>
</thead>
<tbody><tr>
<td>No</td>
<td>No</td>
<td>直接将记录从叶子节点删除，如果该节点还是Index Page的节点，用该节点的右节点代替</td>
</tr>
<tr>
<td>Yes</td>
<td>No</td>
<td>合并叶子节点和它的兄弟节点，同时更新Index Page</td>
</tr>
<tr>
<td>Yes</td>
<td>Yes</td>
<td>1）合并叶子节点和它的兄弟节点<br>2）更新Index Page<br>3）合并Index Page和它的兄弟节点</td>
</tr>
</tbody></table>
<p><img src="/images/MySql%E7%B4%A2%E5%BC%95/%E5%9B%BE5-11.jpg" alt="删除70"></p>
<p><img src="/images/MySql%E7%B4%A2%E5%BC%95/%E5%9B%BE5-12.jpg" alt="删除25"></p>
<p><img src="/images/MySql%E7%B4%A2%E5%BC%95/%E5%9B%BE5-13.jpg" alt="删除60"></p>
<h2 id="五、B-树索引"><a href="#五、B-树索引" class="headerlink" title="五、B+树索引"></a>五、B+树索引</h2><blockquote>
<p>数据库中的B+树索引可以分为<strong>聚集索引</strong>和<strong>辅助索引</strong>。</p>
</blockquote>
<p>聚集索引与辅助索引不同的是，叶子节点存放的是否是一整行的信息。</p>
<h3 id="1、聚集索引"><a href="#1、聚集索引" class="headerlink" title="1、聚集索引"></a>1、聚集索引</h3><p>​		聚集索引（clustered index）就是按照每张表的主键构造一棵B+树，同时叶子节点中存放的即为整张表的行记录数据，也将聚集索引的叶子节点称为数据页。聚集索引的这个特性决定了索引组织表中数据也是索引的一部分。</p>
<p>​		同B+树数据结构一样，每个数据页都通过一个<strong>双向链表</strong>进行链接。</p>
<p><strong>聚集索引的存储</strong></p>
<p>​		聚集索引的存储并不是物理上连续的，而是逻辑上连续的。其中有两点：</p>
<ul>
<li>1、页通过双向链表链接，页按照主键顺序排序</li>
<li>2、页中的记录通过双向链表进行维护的。物理存储上可以同样不按照主键存储。</li>
</ul>
<p>​		聚集索引的另一个好处是，对于主键的排序查找和范围查找速度非常快。</p>
<h3 id="2、辅助索引"><a href="#2、辅助索引" class="headerlink" title="2、辅助索引"></a>2、辅助索引</h3><p><strong>概念</strong></p>
<p>​		也称非聚集索引，叶子节点并不包含记录的全部数据。叶子节点除了包含键值外，索引行中还包含了一个书签（bookmark）。用来告诉InnoDB存储引擎那里可以找到与索引相对应的行数据。</p>
<p>​		由于InnoDB存储引擎表是索引组织表，因此InnoDB存储引擎的辅助索引的书签就是相应行数据的聚集索引键。</p>
<p><img src="/images/MySql%E7%B4%A2%E5%BC%95/%E5%9B%BE5-15.jpg" alt="辅助索引与聚集索引关系"></p>
<p>​		当通过辅助索引来寻找数据时，InnoDB存储引擎会遍历辅助索引并通过叶级别的指针获得指向主键索引的主键，然后通过主键索引找到一个完整的行记录。</p>
<h2 id="六、Cardinality值"><a href="#六、Cardinality值" class="headerlink" title="六、Cardinality值"></a>六、Cardinality值</h2><h3 id="1、什么是Cardinality"><a href="#1、什么是Cardinality" class="headerlink" title="1、什么是Cardinality"></a>1、什么是Cardinality</h3><p>一般的经验是，访问表中很少一部分时使用B+树索引才有意义。</p>
<ul>
<li><p>低选择性：对于性别、地区、类型，可取值的范围很小。</p>
</li>
<li><p>高选择性：如果某个字段的取值范围很广，几乎没有重复。</p>
</li>
</ul>
<blockquote>
<p>高选择性使用B+树索引最适合的。</p>
</blockquote>
<p><strong>如何查看索引是否是高选择性？</strong></p>
<p>通过<strong>SHOW INDEX</strong>结果中的列Cardinality来观察。</p>
<p>Cardinality表示索引中不重复记录数量的<strong>预估值</strong>。</p>
<p>实际应用中，Cardinality&#x2F;n_rows_in_table应尽可能地接近1.如果非常小，需要考虑是否有必要创建这个索引。</p>
<p>所以在访问高选择性属性地字段并从表中取出很少一部分数据时，对这个字段添加B+树索引非常有必要地。</p>
<h3 id="2、InnoDB存储引擎的Cardinality统计"><a href="#2、InnoDB存储引擎的Cardinality统计" class="headerlink" title="2、InnoDB存储引擎的Cardinality统计"></a>2、InnoDB存储引擎的Cardinality统计</h3><p>​		数据库对于Cardinality的统计是通过采样（Sample）的方法来完成的。</p>
<p>​		在InnoDB存储引擎中，Cardinality统计信息的更新发生在两个操作中：INSERT和UPDATE。</p>
<p>​		InnoDB存储引擎内部对更新Cardinality信息的策略为：</p>
<ul>
<li><p>表中1&#x2F;16的数据已发生过变化</p>
</li>
<li><p>stat_modeified_counter&gt;2 000 000 000</p>
<p>策略二表示，如果对表中某一行数据频繁地进行更新操作，表中数据实际并没有增加，实际发生变化地还是这一行数据，则第一种更新策略就无法适用这种情况。</p>
<p>故InnoDB存储引擎内部有一个计数器stat_modified_counter,用来表示变化次数，当stat_modified_counter大于2 000 000 000时，同样需要更新Cardinality信息。</p>
</li>
</ul>
<p><strong>采样过程</strong></p>
<p>默认InnoDB存储引擎对8个叶子节点（Leaf Page）进行采样。</p>
<ul>
<li>取得B+树索引中叶子节点的数量，记为A</li>
<li>随机取得B+树索引中的8个叶子节点。统计每个页不同记录的个数，记为P1，P2，。。。。，P8</li>
<li>根据采样信息给出Cardinality的预估值：Cardinality&#x3D;（P1+P2+…+P8）*A、8。</li>
</ul>
<h2 id="七、B-树索引的使用"><a href="#七、B-树索引的使用" class="headerlink" title="七、B+树索引的使用"></a>七、B+树索引的使用</h2><h3 id="1、不同应用中B-树索引的使用"><a href="#1、不同应用中B-树索引的使用" class="headerlink" title="1、不同应用中B+树索引的使用"></a>1、不同应用中B+树索引的使用</h3><p>OLTP（Online Transaction Processing在线事务处理）</p>
<ul>
<li>主要是对数据的增删改，侧重实时性</li>
<li>查询操作只从数据库中取得一小部分数据</li>
<li>这种情况下，B+树索引建立后，对该索引的使用只是通过该索引取得表中少部分数据，这时最有意义。</li>
</ul>
<p>OLAP（Online Analytical Processing在线分析处理）</p>
<ul>
<li>对数据的查询，侧重大数据量查询</li>
<li>需要访问表中大量数据，根据数据产生查询结果，这些查询多是面向分析的查询</li>
<li>索引的添加根据的应该是宏观的信息，而不是微观<strong>（具体怎么添加索引？）</strong></li>
</ul>
<h3 id="2、联合索引"><a href="#2、联合索引" class="headerlink" title="2、联合索引"></a>2、联合索引</h3><blockquote>
<p>对表上对各列进行索引</p>
</blockquote>
<p><img src="/images/MySql%E7%B4%A2%E5%BC%95/%E5%9B%BE5-22.png" alt="多个键值的B+树"></p>
<p>假定两个键值的名称分别为a、b</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">对于条件<span class="keyword">where</span> a<span class="operator">=</span> XX <span class="keyword">and</span> b<span class="operator">=</span> XX</span><br><span class="line">以及 <span class="keyword">where</span> a<span class="operator">=</span> XX 都是可用的</span><br><span class="line">但是 <span class="keyword">where</span> b<span class="operator">=</span> XX 不可用</span><br></pre></td></tr></table></figure>

<p>优势，已经对第二个键值进行了排序</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">where</span> a<span class="operator">=</span>xx <span class="keyword">order</span> <span class="keyword">by</span> b可用</span><br></pre></td></tr></table></figure>

<h3 id="3、覆盖索引"><a href="#3、覆盖索引" class="headerlink" title="3、覆盖索引"></a>3、覆盖索引</h3><p>覆盖索引（overing index）</p>
<p>从辅助索引中就可以得到查询的记录，不需要查询聚集索引中的记录。</p>
<p>优势：</p>
<ul>
<li>由于覆盖索引是辅助索引不包含整行记录的索引信息，大小远小于聚集索引，减少IO操作。</li>
<li>对统计问题而言，由于bug_log表上有辅助索引，辅助索引远小于聚集索引，选择辅助索引可以减少IO操作，优化器自动选择辅助索引。（表现为possible_keys列为null，但实际使用了索引）</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> bug_log</span><br></pre></td></tr></table></figure>

<p>联合索引</p>
<p>SQL查询是统计操作，并且可以利用到覆盖索引的信息，因此优化器会选择联合索引。</p>
<h3 id="4、优化器选择不使用索引的情况"><a href="#4、优化器选择不使用索引的情况" class="headerlink" title="4、优化器选择不使用索引的情况"></a>4、优化器选择不使用索引的情况</h3><p>对于不能进行索引覆盖的情况，优化器选择辅助索引的情况是，<strong>通过辅助索引查找的数据是少量的</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> orderdetails</span><br><span class="line"><span class="keyword">WHERE</span> orderid<span class="operator">&gt;</span><span class="number">10000</span> <span class="keyword">and</span> orderid<span class="operator">&lt;</span><span class="number">102000</span>;</span><br></pre></td></tr></table></figure>



<p>可使用FORCXE INDEX强制使用某个索引</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">FROM</span> orderdetails FORCE INDEX(OrderID)</span><br><span class="line"><span class="keyword">WHERE</span> orderid<span class="operator">&gt;</span><span class="number">10000</span> <span class="keyword">and</span> orderid<span class="operator">&lt;</span><span class="number">102000</span>;</span><br></pre></td></tr></table></figure>

<h2 id="八、索引分析与优化"><a href="#八、索引分析与优化" class="headerlink" title="八、索引分析与优化"></a>八、索引分析与优化</h2><h3 id="1、EXPLAN"><a href="#1、EXPLAN" class="headerlink" title="1、EXPLAN"></a>1、EXPLAN</h3><p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN select * from user where id &lt; 3;</span><br></pre></td></tr></table></figure>

<p>EXPALIN命令输出内容：</p>
<ul>
<li><p>select_type</p>
<p>表示查询的类型</p>
<ul>
<li>SIMPLE：查询语句包不包含子查询或union</li>
<li>PRIMARY：表示此查询是最外层查询</li>
<li>UNION：此查询是UNION的第二个或后续的查询</li>
<li>DEPENDENT UNION：UNION中的第二个或后续的查询语句，使用了外面查询结果</li>
<li>UNION RESULT：UNION的结果</li>
<li>SUBQUERY：SELECT子查询语句</li>
<li>DEPENDENT SUBQUERY：SELECT子查询语句依赖外层查询的结果。</li>
</ul>
<p>最常见查询类型是SIMPLE，表示查询没有子查询也没有用到UNION查询</p>
</li>
<li><p><strong>type</strong></p>
<p>存储引擎查询数据时采用的方式。通过它可以判断出查询是全表扫描还是基于索引的部分扫描。常用属性值如下，从上到下效率依次增强。</p>
<ul>
<li>ALL：表示全表扫描，性能最差。</li>
<li>index：表示基于索引的全表扫描，先扫描索引再扫描全表数据</li>
<li>range：表示使用索引范围查询。使用&gt;、&gt;&#x3D;、&lt;、&lt;&#x3D;、in等等。</li>
<li>ref：表示使用非唯一索引进行单值查询</li>
<li>eq_ref：一般情况下出现在多表join查询，表示前面表的每一个记录都只能匹配后面表的一行结果。</li>
<li>const：表示使用主键或唯一索引做等值查询，常量查询。</li>
<li>NULL：表示不用访问表，速度最快。</li>
</ul>
</li>
<li><p>possible_keys</p>
<p>查询时能够使用到的索引。注意并不一定会真正使用，显示的是索引名称。</p>
</li>
<li><p><strong>key</strong></p>
<p>查询时真正使用到的索引，显示的是索引名称。</p>
</li>
<li><p><strong>rows</strong></p>
<p>MySQL查询优化器会根据统计信息，估算SQL要查询到结果需要扫描多少行记录。rows越少效率越高。</p>
</li>
<li><p>key_len</p>
<p>查询使用了索引的字节数量。可以判断是否全部使用了组合索引。</p>
<p>计算规则：</p>
<ul>
<li><p>字符串类型</p>
<p>字符串长度跟字符集有关：lation1&#x3D;1、gbk&#x3D;2、utf8&#x3D;3、utf8mb4&#x3D;4</p>
<p>char(n)：n*字符集长度</p>
<p>varchar(n)：n*字符集长度+2字节</p>
</li>
<li><p>数值类型：</p>
<p>TINYINT：１个字节</p>
<p>SMALLINT： 2个字节</p>
<p>MEDIUMINT： 3个字节</p>
<p>INT、 FLOAT： 4个字节</p>
<p>BIGINT、 DOUBLE： 8个字节  </p>
</li>
<li><p>时间类型</p>
<p>DATE：３个字节</p>
<p>TIMESTAMP：４个字节</p>
<p>DATETIME：８个字节</p>
</li>
<li><p>字段属性：</p>
<p>NULL属性占用1个字节，如果一个字段设置了NOT NULL，则没有此项</p>
</li>
</ul>
</li>
<li><p><strong>Extra</strong></p>
<p>Extra表示很多额外的信息，各种操作会在Extra提示相关信息，常⻅⼏种如下：</p>
<p><strong>－Using where</strong><br>索引(age,name) select salary,age name from t;进⾏回表<br>表示查询需要通过索引回表查询数据。<br><strong>－Using index</strong><br>索引(age,name) select age name from t;可以使⽤覆盖索引<br>表示查询需要通过索引，索引就可以满⾜所需数据。<br><strong>－Using filesort</strong><br>表示查询出来的结果需要额外排序，数据量⼩在内存，⼤的话在磁盘，因此有Using filesort 建议优化。<br><strong>－Using temprorary</strong><br>查询使⽤到了临时表，⼀般出现于去重、分组等操作。</p>
</li>
</ul>
<h3 id="2、回表查询"><a href="#2、回表查询" class="headerlink" title="2、回表查询"></a>2、回表查询</h3><p>​		InnoDB有聚集索引和辅助索引，聚集索引存储索引值和行数据，InnoDB必须要有，且只有一个。辅助索引的叶子节点存储主键值和索引值。通过辅助索引无法直接定位行记录，通常情况下，需要扫码两遍索引树。</p>
<p>回表查询：先通过辅助索引查询主键值，再通过聚集索引查询行记录。性能比扫一遍索引树低。</p>
<h3 id="3、覆盖索引-1"><a href="#3、覆盖索引-1" class="headerlink" title="3、覆盖索引"></a>3、覆盖索引</h3><p>explain的输出结果Extra字段为Using index时，能够出发索引覆盖。</p>
<p>只需要在一棵索引树上就能获取SQL所需的所有列数据，无需回表，速度更快，就叫索引覆盖。</p>
<p>实现索引覆盖：将被查询的字段，建立到组合索引</p>
<h3 id="4、最左前缀原则"><a href="#4、最左前缀原则" class="headerlink" title="4、最左前缀原则"></a>4、最左前缀原则</h3><p>复合索引使用时遵循最左原则，查询中使用到最左侧列，查询就会使用到索引，如果从索引第二列开始查找，索引将失效。</p>
<h3 id="5、LIKE查询"><a href="#5、LIKE查询" class="headerlink" title="5、LIKE查询"></a>5、LIKE查询</h3><p>MySQL在使用like模糊查询时，索引能不能起作用？</p>
<p>回答：索引可以被使用，只有把%字符卸载后面才会用到索引</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select * from user where name like &#x27;%o%&#x27;;//不起作用</span><br><span class="line">select * from user where name like &#x27;o%&#x27;;//起作用</span><br><span class="line">select * from user where name like &#x27;%o&#x27;;//不起作用</span><br></pre></td></tr></table></figure>

<h3 id="6、NULL查询"><a href="#6、NULL查询" class="headerlink" title="6、NULL查询"></a>6、NULL查询</h3><p>如果MySQL表的某一列含有NULL值，那么该列索引是否有效？</p>
<p>对于NULL来说，NULL是一个特殊的值，从概念上讲，NULL意味着“一个未知值”，处理方式与其他值不同。</p>
<p>不能使用＝，＜，＞这样的运算符，对NULL做算术运算的结果都是NULL，count时　不会包括NULL行等。</p>
<p>NULL比空字符串需要更多的存储空间等。</p>
<blockquote>
<p>不建议列上允许为NULL</p>
</blockquote>
<h3 id="7、索引与排序"><a href="#7、索引与排序" class="headerlink" title="7、索引与排序"></a>7、索引与排序</h3><blockquote>
<p>filesort和index两种索引</p>
</blockquote>
<ul>
<li><p>filesort先把结果查出，在缓存或磁盘进行排序，效率低。</p>
<p>filesort有两种排序算法</p>
<ul>
<li><p>双路排序：两次磁盘扫描读取，第一次读取排序字段，然后排序；第二次读取其他字段数据</p>
</li>
<li><p>单路排序：从磁盘查询所需的所有列数据，然后再内存排序将结果返回。（如果查询数据超出缓存sort_buffer，会导致多次磁盘读取操作，并创建临时表，最后产生多次IO，增加负担）</p>
<p>解决方式：少使用select *;增加sort_buffer_size容量和max_length_for_sort_data容量</p>
</li>
</ul>
</li>
<li><p>index指利用索引自动实现排序，不需另作排序操作，效率较高</p>
</li>
</ul>
<p>Explain分析SQL，Extra属性显示</p>
<table>
<thead>
<tr>
<th>Extra</th>
<th>意义</th>
</tr>
</thead>
<tbody><tr>
<td>Using filesort</td>
<td>使用filesort排序</td>
</tr>
<tr>
<td>Using index</td>
<td>覆盖索引</td>
</tr>
</tbody></table>
<p>使用index排序情况</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ORDER BY子句索引列组合满足所有最左前列</span><br><span class="line">explain select id from user order by id;//对应(id)、(id,name)索引有效</span><br><span class="line"></span><br><span class="line">where子句+order by子句索引列组合满足所有最左前列</span><br><span class="line">explain select id from user where age=18 order by name;//对应(age,name)索引</span><br></pre></td></tr></table></figure>

<p>使⽤filesort⽅式的排序  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">对索引列同时使⽤了ASC和DESC</span><br><span class="line">explain select id from user order by age asc,name desc; //对应(age,name)索引</span><br><span class="line"></span><br><span class="line">WHERE⼦句和ORDER BY⼦句满⾜最左前缀，但where⼦句使⽤了范围查询(例如&gt;、 &lt;、 in等)</span><br><span class="line">explain select id from user where age&gt;10 order by name; //对应(age,name)索引</span><br><span class="line"></span><br><span class="line">ORDER BY或者WHERE+ORDER BY索引列没有满⾜索引最左前列</span><br><span class="line">explain select id from user order by name; //对应(age,name)索引</span><br><span class="line"></span><br><span class="line">使⽤了不同的索引， MySQL每次只采⽤⼀个索引， ORDER BY涉及了两个索引</span><br><span class="line">explain select id from user order by name,age; //对应(name)、 (age)两个索引</span><br><span class="line"></span><br><span class="line">WHERE⼦句与ORDER BY⼦句，使⽤了不同的索引</span><br><span class="line">explain select id from user where name=&#x27;tom&#x27; order by age; //对应 (name)、 (age)索引</span><br><span class="line"></span><br><span class="line">WHERE⼦句或者ORDER BY⼦句中索引列使⽤了表达式，包括函数表达式</span><br><span class="line">explain select id from user order by abs(age); //对应(age)索引</span><br></pre></td></tr></table></figure>

<h3 id="8、主键选择"><a href="#8、主键选择" class="headerlink" title="8、主键选择"></a>8、主键选择</h3><blockquote>
<p>推荐小的自增数字，因为有序，占用内存小</p>
</blockquote>
<h2 id="九、查询优化"><a href="#九、查询优化" class="headerlink" title="九、查询优化"></a>九、查询优化</h2><h3 id="1、慢查询定位"><a href="#1、慢查询定位" class="headerlink" title="1、慢查询定位"></a>1、慢查询定位</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &#x27;slow_query_log%&#x27;;</span><br><span class="line">+---------------------+------------------------------------------+</span><br><span class="line">| Variable_name       | Value                                    |</span><br><span class="line">+---------------------+------------------------------------------+</span><br><span class="line">| slow_query_log      | OFF                                      |</span><br><span class="line">| slow_query_log_file | D:\Environment\mysql-5.7.19-winx64\data\ |</span><br><span class="line">+---------------------+------------------------------------------+</span><br><span class="line">2 rows in set, 8 warnings (0.06 sec)</span><br><span class="line"></span><br><span class="line">#开启慢查询</span><br><span class="line">mysql&gt; set global slow_query_log = ON;</span><br><span class="line">Query OK, 0 rows affected (0.02 sec)</span><br><span class="line"></span><br><span class="line">#设置慢查询文件</span><br><span class="line">mysql&gt; set global slow_query_log_file = &#x27;OAK-slow.log&#x27;;</span><br><span class="line">Query OK, 0 rows affected (0.01 sec)</span><br><span class="line"></span><br><span class="line">#表示会记录没有使用索引的查询SQL。</span><br><span class="line">mysql&gt; set global log_queries_not_using_indexes = ON;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">#指定慢查询的阈值，单位秒。如果SQL执行时间超过阈值，属于慢查询记录到日志文件中</span><br><span class="line">mysql&gt; set long_query_time = 10;</span><br><span class="line">Query OK, 0 rows affected (0.01 sec)</span><br></pre></td></tr></table></figure>

<p>日志文件</p>
<ul>
<li>time ：⽇志记录的时间</li>
<li>User@Host ：执⾏的⽤户及主机</li>
<li>Query_time ：执⾏的时间</li>
<li>Lock_time ：锁表时间</li>
<li>Rows_sent ：发送给请求⽅的记录数，结果数量</li>
<li>Rows_examined ：语句扫描的记录条数</li>
<li>SET timestamp ：语句执⾏的时间点</li>
<li>select…. ：执⾏的具体的SQL语句</li>
</ul>
<h3 id="2、慢查询优化"><a href="#2、慢查询优化" class="headerlink" title="2、慢查询优化"></a>2、慢查询优化</h3><p>慢查询原因总结</p>
<ul>
<li>全表扫描：explain分析type属性all</li>
<li>全索引扫描</li>
<li>索引过滤性不好：靠索引字段选型、数据量和状态、表设计</li>
<li>频繁的回表查询开销：尽量少⽤select * ，使⽤覆盖索引</li>
</ul>
<h3 id="3、分页查询优化"><a href="#3、分页查询优化" class="headerlink" title="3、分页查询优化"></a>3、分页查询优化</h3><p>分页优化方案</p>
<p>第一步：利用覆盖索引优化</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">原：</span><br><span class="line">select * from user limit 10000,100;</span><br><span class="line">优化：</span><br><span class="line">select id from user limit 10000,100;</span><br></pre></td></tr></table></figure>



<p>第二步：利用子查询优化</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">原：</span><br><span class="line">select * from user limit 10000,100;</span><br><span class="line">优化后：</span><br><span class="line">select * from user where id&gt;= (select id from user limit 10000,1) limit 100;</span><br><span class="line">使用了id做主键比较(id&gt;=),并且子查询使用了覆盖索引进行优化。</span><br></pre></td></tr></table></figure>



<h2 id="十、最佳实践"><a href="#十、最佳实践" class="headerlink" title="十、最佳实践"></a>十、最佳实践</h2><h3 id="1、阿里开发规范"><a href="#1、阿里开发规范" class="headerlink" title="1、阿里开发规范"></a>1、阿里开发规范</h3><ol>
<li><strong>【强制】业务上具有唯⼀特性的字段，即使是多个字段的组合，也必须建成唯⼀索引。</strong><br>说明：不要以为唯⼀索引影响了insert速度，这个速度损耗可以忽略，但提⾼查找速度是明显的；<br>另外，即使在应⽤层做了⾮常完善的校验控制，只要没有唯⼀索引，根据墨菲定律，必然有脏数据产⽣。</li>
<li><strong>【强制】超过三个表禁⽌join。需要join的字段，数据类型必须绝对⼀致；多表关联查询时，保证被关联的字段需要有索引。</strong><br>说明：即使双表join也要注意表索引、 SQL性能。</li>
<li><strong>【强制】在varchar字段上建⽴索引时，必须指定索引长度，没必要对全字段建⽴索引，根据实际⽂</strong><br><strong>本区分度决定索引⻓度即可。</strong><br>说明：索引的⻓度与区分度是⼀对⽭盾体，⼀般对字符串类型数据，⻓度为20的索引，区分度会⾼<br>达90%以上，可以使⽤count(distinct left(列名, 索引⻓度))&#x2F;count(<em>)的区分度来确定。</em></li>
<li><strong>【强制】⻚⾯搜索严禁左模糊或者全模糊，如果需要请⾛搜索引擎来解决。</strong><br>说明：索引⽂件具有B-Tree的最左前缀匹配特性，如果左边的值未确定，那么⽆法使⽤此索引。</li>
<li><strong>【推荐】如果有order by的场景，请注意利⽤索引的有序性。 order by 最后的字段是组合索引的⼀部分，并且放在索引组合顺序的最后，避免出现file_sort的情况，影响查询性能。</strong><br>正例： where a&#x3D;? and b&#x3D;? order by c; 索引： a_b_c<br>反例：索引中有范围查找，那么索引有序性⽆法利⽤，如： WHERE a&gt;10 ORDER BY b; 索引a_b⽆法排序。</li>
<li><strong>【推荐】利⽤覆盖索引来进⾏查询操作，避免回表。</strong><br>说明：如果⼀本书需要知道第11章是什么标题，会翻开第11章对应的那⼀⻚吗？⽬录浏览⼀下就好，这个⽬录就是起到覆盖索引的作⽤。<br>正例：能够建⽴索引的种类分为主键索引、唯⼀索引、普通索引三种，⽽覆盖索引只是⼀种查询的<br>SELECT a.* FROM 表1 a, (select id from 表1 where 条件 LIMIT 100000,20 ) b<br>where a.id&#x3D;b.id<br>⼀种效果，⽤explain的结果， extra列会出现： using index。</li>
<li><strong>【推荐】利⽤延迟关联或者⼦查询优化超多分⻚场景。</strong><br>说明： MySQL并不是跳过offset⾏，⽽是取offset+N⾏，然后返回放弃前offset⾏，返回N⾏，那当<br>offset特别⼤的时候，效率就⾮常的低下，要么控制返回的总⻚数，要么对超过特定阈值的⻚数进<br>⾏SQL改写。<br>正例：先快速定位需要获取的id段，然后再关联：</li>
<li><strong>【推荐】 SQL性能优化的⽬标：⾄少要达到 range 级别，要求是ref级别，如果可以是consts最好。</strong><br>说明：<br>1） consts 单表中最多只有⼀个匹配⾏（主键或者唯⼀索引），在优化阶段即可读取到数据。<br>2） ref 指的是使⽤普通的索引（normal index）。<br>3） range 对索引进⾏范围检索。<br>反例： explain表的结果， type&#x3D;index，索引物理⽂件全扫描，速度⾮常慢，这个index级别⽐较<br>range还低，与全表扫描是⼩巫⻅⼤巫。</li>
<li><strong>【推荐】建组合索引的时候，区分度最⾼的在最左边。</strong><br>正例：如果where a&#x3D;? and b&#x3D;? ， a列的⼏乎接近于唯⼀值，那么只需要单建idx_a索引即可。<br>说明：存在⾮等号和等号混合判断条件时，在建索引时，请把等号条件的列前置。如： where a&gt;?<br>and b&#x3D;? 那么即使a的区分度更⾼，也必须把b放在索引的最前列。</li>
<li><strong>【推荐】防⽌因字段类型不同造成的隐式转换，导致索引失效。</strong></li>
<li>【参考】创建索引时避免有如下极端误解： 1）宁滥勿缺。认为⼀个查询就需要建⼀个索引。 2）<br>宁缺勿滥。认为索引会消耗空间、严重拖慢更新和新增速度。 3）抵制惟⼀索引。认为业务的惟⼀<br>性⼀律需要在应⽤层通过“先查后插”⽅式解决。</li>
</ol>
<h3 id="2、普通索引和唯一索引的选择"><a href="#2、普通索引和唯一索引的选择" class="headerlink" title="2、普通索引和唯一索引的选择"></a>2、普通索引和唯一索引的选择</h3><p>读性能：</p>
<p>普通索引：查找到满足条件的第一个记录，需要查找下一个记录，直到碰到第一个不满足条件的记录。</p>
<p>唯一索引：索引定义了唯一性，查找到第一个满足条件的记录后，就会停止继续检索。</p>
<p>InnoDB的数据是按数据页为单位来读写的。也就是说。当需要读一条记录的时候，并不是将记录本身从磁盘读出来，而是以页为单位，将其整体读入内存。在InnoDB中，每个数据页的大小默认是16KB。<strong>所以唯一索引读的性能优势微乎其微。</strong></p>
<p>写性能：</p>
<blockquote>
<p>对于唯一索引来说，所有更新操作都要先判断这个操作是否违反唯一性约束</p>
</blockquote>
<p>插入记录前，先判断是否存在相同主键的记录，必须将数据页读入内存才能判断。</p>
<p>如果已经读入到内存了，直接更新内存会更快，没必要使用change buffer。</p>
<p><strong>因此，唯一索引的更新不能使用change buffer，实际上也只有普通索引可以使用。</strong></p>
<p><strong>change buffer</strong>就是在非唯一普通索引页不在buffer pool中时，对页进行了写操作的情况下，先将记录变更缓冲，等未来数据被读取时，再将 change buffer 中的操作merge到原数据页的技术。在MySQL5.5之前，叫插入缓冲(insert buffer)，只针对insert做了优化；现在对delete和update也有效，叫做写缓冲(change buffer)。</p>
<p>结论：</p>
<p><strong>在实际使用中，普通索引和change buffer 的配合使用，对于数据量大的表的更新优化还是很明显的。</strong></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/mysql/" rel="tag">mysql</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%B4%A2%E5%BC%95/" rel="tag">索引</a></li></ul>

    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-学习方法"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/07/26/%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/"
    >学习方法</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/07/26/%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/" class="article-date">
  <time datetime="2022-07-26T02:29:00.000Z" itemprop="datePublished">2022-07-26</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/">学习方法</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="学习思维What、why、how"><a href="#学习思维What、why、how" class="headerlink" title="学习思维What、why、how"></a>学习思维What、why、how</h1><h2 id="一、what"><a href="#一、what" class="headerlink" title="一、what"></a>一、what</h2><p>是什么</p>
<h2 id="二、Why"><a href="#二、Why" class="headerlink" title="二、Why"></a>二、Why</h2><p>为什么使用</p>
<h2 id="三、How"><a href="#三、How" class="headerlink" title="三、How"></a>三、How</h2><p>如何使用</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/" rel="tag">学习方法</a></li></ul>

    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-xxl-job学习"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/07/26/xxl-job%E5%AD%A6%E4%B9%A0/"
    >xxl-job学习笔记</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/07/26/xxl-job%E5%AD%A6%E4%B9%A0/" class="article-date">
  <time datetime="2022-07-26T00:58:25.000Z" itemprop="datePublished">2022-07-26</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/SpringCloud%E7%BB%84%E4%BB%B6/">SpringCloud组件</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="xxl-job"><a href="#xxl-job" class="headerlink" title="xxl-job"></a>xxl-job</h1><blockquote>
<p>官网：<a target="_blank" rel="noopener" href="https://www.xuxueli.com/xxl-job/">https://www.xuxueli.com/xxl-job/</a></p>
</blockquote>
<h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h2><h3 id="1、概述"><a href="#1、概述" class="headerlink" title="1、概述"></a>1、概述</h3><p>XXL-JOB是一个分布式任务调度平台</p>
<p>开发迅速、学习简单、轻量级、易扩展</p>
<h3 id="2、下载"><a href="#2、下载" class="headerlink" title="2、下载"></a>2、下载</h3><p><strong>源码仓库地址</strong></p>
<table>
<thead>
<tr>
<th>地址</th>
</tr>
</thead>
<tbody><tr>
<td><a target="_blank" rel="noopener" href="https://github.com/xuxueli/xxl-job">https://github.com/xuxueli/xxl-job</a></td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="http://gitee.com/xuxueli0323/xxl-job">http://gitee.com/xuxueli0323/xxl-job</a></td>
</tr>
</tbody></table>
<p><strong>中央仓库地址</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- http://repo1.maven.org/maven2/com/xuxueli/xxl-job-core/ --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.xuxueli<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>xxl-job-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;最新稳定版本&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="二、快速入门"><a href="#二、快速入门" class="headerlink" title="二、快速入门"></a>二、快速入门</h2><h3 id="1、初始化调度数据库"><a href="#1、初始化调度数据库" class="headerlink" title="1、初始化调度数据库"></a>1、初始化调度数据库</h3><p>项目源码中，“调度数据库初始化SQL脚本” 位置为:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/xxl-job/doc/db/tables_xxl_job.sql</span><br></pre></td></tr></table></figure>

<p>调度中心支持集群部署，集群情况下各节点务必连接同一个mysql实例;</p>
<p>如果mysql做主从,调度中心集群节点务必强制走主库;</p>
<h3 id="2、编译源码"><a href="#2、编译源码" class="headerlink" title="2、编译源码"></a>2、编译源码</h3><p>解压源码，导入IDE</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">xxl-job-admin：调度中心</span><br><span class="line">xxl-job-core：公共依赖</span><br><span class="line">xxl-job-executor-samples：执行器Sample示例（选择合适的版本执行器，可直接使用，也可以参考其并将现有项目改造成执行器）</span><br><span class="line">    ：xxl-job-executor-sample-springboot：Springboot版本，通过Springboot管理执行器，推荐这种方式；</span><br><span class="line">    ：xxl-job-executor-sample-frameless：无框架版本；</span><br></pre></td></tr></table></figure>

<h3 id="3、配置部署“调度中心”"><a href="#3、配置部署“调度中心”" class="headerlink" title="3、配置部署“调度中心”"></a>3、配置部署“调度中心”</h3><p>调度中心项目:xxl-job-admin</p>
<p>作用：统一管理任务调度平台上调度任务，负责触发调度执行，并且提供任务管理平台。</p>
<h4 id="步骤一：调度中心配置"><a href="#步骤一：调度中心配置" class="headerlink" title="步骤一：调度中心配置"></a>步骤一：调度中心配置</h4><p>调度中心配置文件地址：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/xxl-job/xxl-job-admin/src/main/resources/application.properties</span><br></pre></td></tr></table></figure>

<p>内容说明:</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">### 调度中心JDBC链接：链接地址请保持和创建的调度数据库的地址一致</span></span><br><span class="line"><span class="attr">spring.datasource.url</span>=<span class="string">jdbc:mysql://127.0.0.1:3306/xxl_job?useUnicode=true&amp;characterEncoding=UTF-8&amp;autoReconnect=true&amp;serverTimezone=Asia/Shanghai</span></span><br><span class="line"><span class="attr">spring.datasource.username</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">spring.datasource.password</span>=<span class="string">root_pwd</span></span><br><span class="line"><span class="attr">spring.datasource.driver-class-name</span>=<span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="comment">### 报警邮箱</span></span><br><span class="line"><span class="attr">spring.mail.host</span>=<span class="string">smtp.qq.com</span></span><br><span class="line"><span class="attr">spring.mail.port</span>=<span class="string">25</span></span><br><span class="line"><span class="attr">spring.mail.username</span>=<span class="string">xxx@qq.com</span></span><br><span class="line"><span class="attr">spring.mail.password</span>=<span class="string">xxx</span></span><br><span class="line"><span class="attr">spring.mail.properties.mail.smtp.auth</span>=<span class="string">true</span></span><br><span class="line"><span class="attr">spring.mail.properties.mail.smtp.starttls.enable</span>=<span class="string">true</span></span><br><span class="line"><span class="attr">spring.mail.properties.mail.smtp.starttls.required</span>=<span class="string">true</span></span><br><span class="line"><span class="attr">spring.mail.properties.mail.smtp.socketFactory.class</span>=<span class="string">javax.net.ssl.SSLSocketFactory</span></span><br><span class="line"><span class="comment">### 调度中心通讯TOKEN [选填]：非空时启用；</span></span><br><span class="line"><span class="attr">xxl.job.accessToken</span>=<span class="string"></span></span><br><span class="line"><span class="comment">### 调度中心国际化配置 [必填]： 默认为 &quot;zh_CN&quot;/中文简体, 可选范围为 &quot;zh_CN&quot;/中文简体, &quot;zh_TC&quot;/中文繁体 and &quot;en&quot;/英文；</span></span><br><span class="line"><span class="attr">xxl.job.i18n</span>=<span class="string">zh_CN</span></span><br><span class="line"><span class="comment">## 调度线程池最大线程配置【必填】</span></span><br><span class="line"><span class="attr">xxl.job.triggerpool.fast.max</span>=<span class="string">200</span></span><br><span class="line"><span class="attr">xxl.job.triggerpool.slow.max</span>=<span class="string">100</span></span><br><span class="line"><span class="comment">### 调度中心日志表数据保存天数 [必填]：过期日志自动清理；限制大于等于7时生效，否则, 如-1，关闭自动清理功能；</span></span><br><span class="line"><span class="attr">xxl.job.logretentiondays</span>=<span class="string">30</span></span><br></pre></td></tr></table></figure>

<h4 id="步骤二：部署项目"><a href="#步骤二：部署项目" class="headerlink" title="步骤二：部署项目"></a>步骤二：部署项目</h4><p>调度中心访问地址：<a target="_blank" rel="noopener" href="http://localhost:8080/xxl-job-admin%EF%BC%88%E6%89%A7%E8%A1%8C%E5%99%A8%E4%BC%9A%E4%BD%BF%E7%94%A8%E8%AF%A5%E5%9C%B0%E5%9D%80%E4%BD%9C%E4%B8%BA%E5%9B%9E%E8%B0%83%E5%9C%B0%E5%9D%80%EF%BC%89">http://localhost:8080/xxl-job-admin（执行器会使用该地址作为回调地址）</a></p>
<p>默认登录账号 “admin&#x2F;123456”</p>
<p><img src="/images/xxl-job%E5%AD%A6%E4%B9%A0/%E8%B0%83%E5%BA%A6%E4%B8%AD%E5%BF%83%E9%A6%96%E9%A1%B5.png" alt="首页"></p>
<h4 id="步骤三：调度中心集群（可选）："><a href="#步骤三：调度中心集群（可选）：" class="headerlink" title="步骤三：调度中心集群（可选）："></a>步骤三：调度中心集群（可选）：</h4><p>调度中心支持集群部署，提升调度系统容灾和可用性。</p>
<p>调度中心集群部署时：</p>
<ul>
<li>DB配置保持一致</li>
<li>集群机器时钟保持一致（单机集群忽视）</li>
<li>建议：推荐通过nginx为调度中心集群做负载均衡，分配域名。调度中心访问、执行器回调配置、调用API服务等操作均通过改域名进行。</li>
</ul>
<h4 id="其他：Docker镜像方式搭建调度中心"><a href="#其他：Docker镜像方式搭建调度中心" class="headerlink" title="其他：Docker镜像方式搭建调度中心"></a>其他：Docker镜像方式搭建调度中心</h4><p>下载镜像</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// Docker地址：https://hub.docker.com/r/xuxueli/xxl-job-admin/     (建议指定版本号)</span><br><span class="line">docker pull xuxueli/xxl-job-admin:&#123;指定版本&#125;</span><br></pre></td></tr></table></figure>

<p>创建容器并运行</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 8080:8080 -v /tmp:/data/applogs --name xxl-job-admin  -d xuxueli/xxl-job-admin:&#123;指定版本&#125;</span><br><span class="line">/**</span><br><span class="line">* 如需自定义 mysql 等配置，可通过 &quot;-e PARAMS&quot; 指定，参数格式 PARAMS=&quot;--key=value  --key2=value2&quot; ；</span><br><span class="line">* 配置项参考文件：/xxl-job/xxl-job-admin/src/main/resources/application.properties</span><br><span class="line">* 如需自定义 JVM内存参数 等配置，可通过 &quot;-e JAVA_OPTS&quot; 指定，参数格式 JAVA_OPTS=&quot;-Xmx512m&quot; ；</span><br><span class="line">*/</span><br><span class="line">docker run -e PARAMS=&quot;--spring.datasource.url=jdbc:mysql://127.0.0.1:3306/xxl_job?useUnicode=true&amp;characterEncoding=UTF-8&amp;autoReconnect=true&amp;serverTimezone=Asia/Shanghai --spring.datasource.username=root --spring.datasource.password=123456&quot; -p 8080:8080 -v /tmp:/data/applogs --name xxl-job-admin  -d xuxueli/xxl-job-admin:&#123;指定版本&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">	如果数据库部署在容器中</span><br><span class="line">	--link &lt;name or id&gt;:alias</span><br><span class="line">	其中，name和id是源容器的name和id，alias是源容器在link下的别名。</span><br><span class="line">**/</span><br><span class="line">--link mysql:mysql</span><br></pre></td></tr></table></figure>

<h3 id="4、配置部署“执行器项目”"><a href="#4、配置部署“执行器项目”" class="headerlink" title="4、配置部署“执行器项目”"></a>4、配置部署“执行器项目”</h3><p>执行器：xxl-job-executor-sample-springboot;(可以参考，将现有项目改成执行器)</p>
<p>作用：负责接收“调度中心”的调度并执行；可直接部署执行器，也可以将执行器集成到现有业务项目中。</p>
<h4 id="步骤一：maven依赖"><a href="#步骤一：maven依赖" class="headerlink" title="步骤一：maven依赖"></a>步骤一：maven依赖</h4><p>确认pom文件中引入了 “xxl-job-core” 的maven依赖；</p>
<h4 id="步骤二：执行器配置"><a href="#步骤二：执行器配置" class="headerlink" title="步骤二：执行器配置"></a>步骤二：执行器配置</h4><p>执行器配置，配置文件地址：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/xxl-job/xxl-job-executor-samples/xxl-job-executor-sample-springboot/src/main/resources/application.properties</span><br></pre></td></tr></table></figure>

<p>执行器配置，配置内容说明：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">### 调度中心部署根地址 [选填]：如调度中心集群部署存在多个地址则用逗号分隔。执行器将会使用该地址进行&quot;执行器心跳注册&quot;和&quot;任务结果回调&quot;；为空则关闭自动注册；</span></span><br><span class="line"><span class="attr">xxl.job.admin.addresses</span>=<span class="string">http://127.0.0.1:8080/xxl-job-admin</span></span><br><span class="line"><span class="comment">### 执行器通讯TOKEN [选填]：非空时启用；</span></span><br><span class="line"><span class="attr">xxl.job.accessToken</span>=<span class="string"></span></span><br><span class="line"><span class="comment">### 执行器AppName [选填]：执行器心跳注册分组依据；为空则关闭自动注册</span></span><br><span class="line"><span class="attr">xxl.job.executor.appname</span>=<span class="string">xxl-job-executor-sample</span></span><br><span class="line"><span class="comment">### 执行器注册 [选填]：优先使用该配置作为注册地址，为空时使用内嵌服务 ”IP:PORT“ 作为注册地址。从而更灵活的支持容器类型执行器动态IP和动态映射端口问题。</span></span><br><span class="line"><span class="attr">xxl.job.executor.address</span>=<span class="string"></span></span><br><span class="line"><span class="comment">### 执行器IP [选填]：默认为空表示自动获取IP，多网卡时可手动设置指定IP，该IP不会绑定Host仅作为通讯实用；地址信息用于 &quot;执行器注册&quot; 和 &quot;调度中心请求并触发任务&quot;；</span></span><br><span class="line"><span class="attr">xxl.job.executor.ip</span>=<span class="string"></span></span><br><span class="line"><span class="comment">### 执行器端口号 [选填]：小于等于0则自动获取；默认端口为9999，单机部署多个执行器时，注意要配置不同执行器端口；</span></span><br><span class="line"><span class="attr">xxl.job.executor.port</span>=<span class="string">9999</span></span><br><span class="line"><span class="comment">### 执行器运行日志文件存储磁盘路径 [选填] ：需要对该路径拥有读写权限；为空则使用默认路径；</span></span><br><span class="line"><span class="attr">xxl.job.executor.logpath</span>=<span class="string">/data/applogs/xxl-job/jobhandler</span></span><br><span class="line"><span class="comment">### 执行器日志文件保存天数 [选填] ： 过期日志自动清理, 限制值大于等于3时生效; 否则, 如-1, 关闭自动清理功能；</span></span><br><span class="line"><span class="attr">xxl.job.executor.logretentiondays</span>=<span class="string">30</span></span><br></pre></td></tr></table></figure>

<h4 id="步骤三：执行器组件配置"><a href="#步骤三：执行器组件配置" class="headerlink" title="步骤三：执行器组件配置"></a>步骤三：执行器组件配置</h4><p>执行器组件，配置文件地址：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/xxl-job/xxl-job-executor-samples/xxl-job-executor-sample-springboot/src/main/java/com/xxl/job/executor/core/config/XxlJobConfig.java</span><br></pre></td></tr></table></figure>

<p>配置内容：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> XxlJobSpringExecutor <span class="title function_">xxlJobExecutor</span><span class="params">()</span> &#123;</span><br><span class="line">    logger.info(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; xxl-job config init.&quot;</span>);</span><br><span class="line">    <span class="type">XxlJobSpringExecutor</span> <span class="variable">xxlJobSpringExecutor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XxlJobSpringExecutor</span>();</span><br><span class="line">    xxlJobSpringExecutor.setAdminAddresses(adminAddresses);</span><br><span class="line">    xxlJobSpringExecutor.setAppname(appname);</span><br><span class="line">    xxlJobSpringExecutor.setIp(ip);</span><br><span class="line">    xxlJobSpringExecutor.setPort(port);</span><br><span class="line">    xxlJobSpringExecutor.setAccessToken(accessToken);</span><br><span class="line">    xxlJobSpringExecutor.setLogPath(logPath);</span><br><span class="line">    xxlJobSpringExecutor.setLogRetentionDays(logRetentionDays);</span><br><span class="line">    <span class="keyword">return</span> xxlJobSpringExecutor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>jobHandler，具体任务内容</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * XxlJob开发示例（Bean模式）</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 开发步骤：</span></span><br><span class="line"><span class="comment"> *      1、任务开发：在Spring Bean实例中，开发Job方法；</span></span><br><span class="line"><span class="comment"> *      2、注解配置：为Job方法添加注解 &quot;<span class="doctag">@XxlJob</span>(value=&quot;自定义jobhandler名称&quot;, init = &quot;JobHandler初始化方法&quot;, destroy = &quot;JobHandler销毁方法&quot;)&quot;，注解value值对应的是调度中心新建任务的JobHandler属性的值。</span></span><br><span class="line"><span class="comment"> *      3、执行日志：需要通过 &quot;XxlJobHelper.log&quot; 打印执行日志；</span></span><br><span class="line"><span class="comment"> *      4、任务结果：默认任务结果为 &quot;成功&quot; 状态，不需要主动设置；如有诉求，比如设置任务结果为失败，可以通过 &quot;XxlJobHelper.handleFail/handleSuccess&quot; 自主设置任务结果；</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> xuxueli 2019-12-11 21:52:51</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SampleXxlJob</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(SampleXxlJob.class);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 1、简单任务示例（Bean模式）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@XxlJob(&quot;demoJobHandler&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">demoJobHandler</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        XxlJobHelper.log(<span class="string">&quot;XXL-JOB, Hello World.&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            XxlJobHelper.log(<span class="string">&quot;beat at:&quot;</span> + i);</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// default success</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="步骤四：部署执行器项目"><a href="#步骤四：部署执行器项目" class="headerlink" title="步骤四：部署执行器项目"></a>步骤四：部署执行器项目</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">xxl-job-executor-sample-springboot：项目编译打包成springboot类型的可执行JAR包，命令启动即可；</span><br><span class="line">xxl-job-executor-sample-frameless：项目编译打包成JAR包，命令启动即可；</span><br></pre></td></tr></table></figure>

<h4 id="步骤五：执行器集群（可选）"><a href="#步骤五：执行器集群（可选）" class="headerlink" title="步骤五：执行器集群（可选）"></a>步骤五：执行器集群（可选）</h4><p>执行器支持集群部署，提升调度系统可用性，同时提升任务处理能力。</p>
<p>执行器集群部署时，几点要求和建议：</p>
<ul>
<li>执行器回调地址（xxl.job.admin.addresses）需要保持一致；执行器根据该配置进行执行器自动注册等操作。</li>
<li>同一个执行器集群内AppName（xxl.job.executor.appname）需要保持一致；调度中心根据该配置动态发现不同集群的在线执行器列表。</li>
</ul>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/SpringCloud%E7%BB%84%E4%BB%B6/" rel="tag">SpringCloud组件</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6/" rel="tag">分布式任务调度</a></li></ul>

    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-Sleuth+Zipkin链路追踪"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/07/22/Sleuth+Zipkin%E9%93%BE%E8%B7%AF%E8%BF%BD%E8%B8%AA/"
    >Sleuth+Zipkin链路追踪</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/07/22/Sleuth+Zipkin%E9%93%BE%E8%B7%AF%E8%BF%BD%E8%B8%AA/" class="article-date">
  <time datetime="2022-07-22T09:04:25.000Z" itemprop="datePublished">2022-07-22</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/SpringCloud/">SpringCloud</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="Sleuth-Zipkin"><a href="#Sleuth-Zipkin" class="headerlink" title="Sleuth+Zipkin"></a>Sleuth+Zipkin</h1><h2 id="一、什么是链路追踪"><a href="#一、什么是链路追踪" class="headerlink" title="一、什么是链路追踪"></a>一、什么是链路追踪</h2><blockquote>
<p>指一次任务的开始到结束，期间调用的所有系统及耗时（时间跨度）都可以完整记录下来</p>
</blockquote>
<h2 id="二、什么是Sleuth"><a href="#二、什么是Sleuth" class="headerlink" title="二、什么是Sleuth"></a>二、什么是Sleuth</h2><p>Spring Cloud Sleuth为SpringCloud实现了分布式跟踪解决方案。兼容Zipkin，HTrace和其他基于日志的追踪系统，例如ELK（Elasticsearch、LogStash、Kibana）。</p>
<p>Spring Cloud Sleuth提供了以下功能</p>
<ul>
<li>链路追踪：通过Sleuth可以很清楚看出一个请求经过了哪些服务，可以很方便的理清服务间的调用关系等。</li>
<li>性能分析：观察每个采样请求的耗时，可分析哪些服务调用比较耗时。当服务调用的耗时随着请求量的增大而增大时，可以对服务的扩容提供一定的提醒。</li>
<li>数据分析，优化链路：对于频繁调用一个服务，或并行调用等，可以针对业务进行优化。</li>
<li>可视化错误：对于程序未捕获的异常，可以配合Zipkin查看。</li>
</ul>
<h2 id="三、专业术语"><a href="#三、专业术语" class="headerlink" title="三、专业术语"></a>三、专业术语</h2><h3 id="Span"><a href="#Span" class="headerlink" title="Span"></a>Span</h3><p>基本工作单位，一次请求称为一个Span，Dapper记录的是Span的名称，以及每个Span的ID和父ID，以重建在一次追踪过程中不同Span之间的关系。</p>
<p>图中一个矩形框为一个Span。</p>
<p><img src="/images/Sleuth+Zipkin%E9%93%BE%E8%B7%AF%E8%BF%BD%E8%B8%AA/1.webp" alt="请求"></p>
<blockquote>
<p>开始追踪的初始跨度成为root span。</p>
</blockquote>
<p>Dapper记录了span名称，以及每个span的ID和父span ID，以重建在一次追踪过程中不同span之间的关系。如果一个span没有父ID被称为root span。所有span都挂在一个特定的Trace上，也共用一个trace id。</p>
<p><img src="/images/Sleuth+Zipkin%E9%93%BE%E8%B7%AF%E8%BF%BD%E8%B8%AA/2.webp" alt="请求"></p>
<h3 id="Trace"><a href="#Trace" class="headerlink" title="Trace"></a>Trace</h3><p>一系列Span组成的树状结构，一个Trace认为是一次完整的链路，内部包含n多个Span。Trace和Span存在一对多关系，Span与Span存在父子关系。</p>
<p>举个例子：客户端调用服务A、服务B、服务C、服务F，而每个服务例如C就是一个Span，如果在服务C中另启现场调用D，D为C的子Span，如果在服务D中另起线程调用了E，那么E就是D的子Span，C-&gt;D-&gt;E的链路是一条Trace。</p>
<p><img src="/images/Sleuth+Zipkin%E9%93%BE%E8%B7%AF%E8%BF%BD%E8%B8%AA/3.webp" alt="Trace"></p>
<h3 id="Annotation"><a href="#Annotation" class="headerlink" title="Annotation"></a>Annotation</h3><p>用来及时记录一个事件的存在，一些核心annotations用来定义一个请求的开始和结束。</p>
<ul>
<li>cs-Client Sent:客户端发起一个请求，描述span开始</li>
<li>sr-Server Received:服务端获得请求并准备开始处理它，如果sr减去cs时间戳便可得到网络延迟。</li>
<li>ss-Server Sent:请求处理完成（当请求返回客户端），如果ss减去sr时间戳便可得到服务端处理请求需要的时间。</li>
<li>cr-Client Received:表示span结束，客户端成功接收到服务端的回复，如果cr减去cs时间戳便可得到客户端从服务端获取回复的所有所需时间。</li>
</ul>
<h2 id="四、实现原理"><a href="#四、实现原理" class="headerlink" title="四、实现原理"></a>四、实现原理</h2><p><img src="/images/Sleuth+Zipkin%E9%93%BE%E8%B7%AF%E8%BF%BD%E8%B8%AA/4.webp" alt="调用链"></p>
<p><img src="/images/Sleuth+Zipkin%E9%93%BE%E8%B7%AF%E8%BF%BD%E8%B8%AA/5.webp" alt="增加标识spanid"></p>
<p><img src="/images/Sleuth+Zipkin%E9%93%BE%E8%B7%AF%E8%BF%BD%E8%B8%AA/6.webp" alt="请求唯一表示traceid"></p>
<p><img src="/images/Sleuth+Zipkin%E9%93%BE%E8%B7%AF%E8%BF%BD%E8%B8%AA/7.webp" alt="问：无法分辨层级顺序"></p>
<p><img src="/images/Sleuth+Zipkin%E9%93%BE%E8%B7%AF%E8%BF%BD%E8%B8%AA/8.webp" alt="调用方标识parentid"></p>
<p><img src="/images/Sleuth+Zipkin%E9%93%BE%E8%B7%AF%E8%BF%BD%E8%B8%AA/9.webp" alt="时间戳timestamp"></p>
<p><img src="/images/Sleuth+Zipkin%E9%93%BE%E8%B7%AF%E8%BF%BD%E8%B8%AA/10.webp" alt="返回时间戳timestamp"></p>
<p>如何计算网络延迟？</p>
<ul>
<li>Client Sent 简称 cs，客户端发起调用请求到服务端。</li>
<li>Server Received 简称 sr，指服务端接收到了客户端的调用请求。</li>
<li>Server Sent 简称 ss，指服务端完成了处理，准备将信息返给客户端。</li>
<li>Client Received 简称 cr，指客户端接收到了服务端的返回信息。</li>
</ul>
<p><img src="/images/Sleuth+Zipkin%E9%93%BE%E8%B7%AF%E8%BF%BD%E8%B8%AA/11.webp" alt="计算耗时"></p>
<p>其实 span 内除了记录这几个参数之外，还可以记录一些其他信息，比如发起调用服务名称、被调服务名称、返回结果、IP、调用服务的名称等，最后，我们再把相同 parentid 的 span 信息合成一个大的 span 块，就完成了一个完整的调用链。</p>
<h2 id="五、实操"><a href="#五、实操" class="headerlink" title="五、实操"></a>五、实操</h2><h3 id="1、添加依赖"><a href="#1、添加依赖" class="headerlink" title="1、添加依赖"></a>1、添加依赖</h3><p>在需要进行链路追踪的项目中（服务网关、商品服务、订单服务）添加spring-cloud-starter-sleuth依赖。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&lt;!--</span> <span class="string">spring</span> <span class="string">cloud</span> <span class="string">sleuth</span> <span class="string">依赖</span> <span class="string">--&gt;</span></span><br><span class="line"><span class="string">&lt;dependency&gt;</span></span><br><span class="line">    <span class="string">&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span></span><br><span class="line">    <span class="string">&lt;artifactId&gt;spring-cloud-starter-sleuth&lt;/artifactId&gt;</span></span><br><span class="line"><span class="string">&lt;/dependency&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="2、记录日志"><a href="#2、记录日志" class="headerlink" title="2、记录日志"></a>2、记录日志</h3><p>在需要进行链路追踪的项目中添加logback.xml日志文件，内容如下（logback日志的输出级别需要是DEBUG级别）：</p>
<p>注意修改&lt;property  name&#x3D;”log.path” value&#x3D;”${catalina.base}&#x2F;gateway-server&#x2F;logs”&#x2F;&gt;中项目名。</p>
<p>日志核心配置：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [$&#123;applicationName&#125;,%X&#123;X-B3-TraceId:-&#125;,%X&#123;X-B3-SpanId:-&#125;] [%thread] %-5level %logger&#123;50&#125; - %msg%n</span><br></pre></td></tr></table></figure>



<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 日志级别从低到高分为TRACE &lt; DEBUG &lt; INFO &lt; WARN &lt; ERROR &lt; FATAL，如果设置为WARN，则低于WARN的信息都不会输出 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- scan: 当此属性设置为true时，配置文件如果发生改变，将会被重新加载，默认值为true --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- scanPeriod: 设置监测配置文件是否有修改的时间间隔，如果没有给出时间单位，默认单位是毫秒。当scan为true时，此属性生效。默认的时间间隔为1分钟。 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- de<span class="doctag">bug:</span> 当此属性设置为true时，将打印出logback内部日志信息，实时查看logback运行状态。默认值为false。 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span> <span class="attr">scan</span>=<span class="string">&quot;true&quot;</span> <span class="attr">scanPeriod</span>=<span class="string">&quot;10 seconds&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 日志上下文名称 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">contextName</span>&gt;</span>my_logback<span class="tag">&lt;/<span class="name">contextName</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- name的值是变量的名称，value的值是变量定义的值。通过定义的值会被插入到logger上下文中。定义变量后，可以使“$&#123;&#125;”来使用变量。 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;log.path&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;catalina.base&#125;/gateway-server/logs&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 加载 Spring 配置文件信息 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">springProperty</span> <span class="attr">scope</span>=<span class="string">&quot;context&quot;</span> <span class="attr">name</span>=<span class="string">&quot;applicationName&quot;</span> <span class="attr">source</span>=<span class="string">&quot;spring.application.name&quot;</span> <span class="attr">defaultValue</span>=<span class="string">&quot;localhost&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 日志输出格式 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;LOG_PATTERN&quot;</span> <span class="attr">value</span>=<span class="string">&quot;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [$&#123;applicationName&#125;,%X&#123;X-B3-TraceId:-&#125;,%X&#123;X-B3-SpanId:-&#125;] [%thread] %-5level %logger&#123;50&#125; - %msg%n&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--输出到控制台--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;CONSOLE&quot;</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.ConsoleAppender&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--此日志appender是为开发使用，只配置最底级别，控制台输出的日志级别是大于或等于此级别的日志信息--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.classic.filter.ThresholdFilter&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">level</span>&gt;</span>DEBUG<span class="tag">&lt;/<span class="name">level</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>$&#123;LOG_PATTERN&#125;<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 设置字符集 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">charset</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">charset</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 输出到文件 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 时间滚动输出 level为 DEBUG 日志 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;DEBUG_FILE&quot;</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 正在记录的日志文件的路径及文件名 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">file</span>&gt;</span>$&#123;log.path&#125;/log_debug.log<span class="tag">&lt;/<span class="name">file</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--日志文件输出格式--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>$&#123;LOG_PATTERN&#125;<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">charset</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">charset</span>&gt;</span> <span class="comment">&lt;!-- 设置字符集 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 日志记录器的滚动策略，按日期，按大小记录 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rollingPolicy</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 日志归档 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">fileNamePattern</span>&gt;</span>$&#123;log.path&#125;/debug/log-debug-%d&#123;yyyy-MM-dd&#125;.%i.log<span class="tag">&lt;/<span class="name">fileNamePattern</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">timeBasedFileNamingAndTriggeringPolicy</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">maxFileSize</span>&gt;</span>100MB<span class="tag">&lt;/<span class="name">maxFileSize</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">timeBasedFileNamingAndTriggeringPolicy</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--日志文件保留天数--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">maxHistory</span>&gt;</span>15<span class="tag">&lt;/<span class="name">maxHistory</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">rollingPolicy</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 此日志文件只记录debug级别的 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.classic.filter.LevelFilter&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">level</span>&gt;</span>DEBUG<span class="tag">&lt;/<span class="name">level</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">onMatch</span>&gt;</span>ACCEPT<span class="tag">&lt;/<span class="name">onMatch</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">onMismatch</span>&gt;</span>DENY<span class="tag">&lt;/<span class="name">onMismatch</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 时间滚动输出 level为 INFO 日志 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;INFO_FILE&quot;</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 正在记录的日志文件的路径及文件名 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">file</span>&gt;</span>$&#123;log.path&#125;/log_info.log<span class="tag">&lt;/<span class="name">file</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--日志文件输出格式--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>$&#123;LOG_PATTERN&#125;<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">charset</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">charset</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 日志记录器的滚动策略，按日期，按大小记录 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rollingPolicy</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 每天日志归档路径以及格式 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">fileNamePattern</span>&gt;</span>$&#123;log.path&#125;/info/log-info-%d&#123;yyyy-MM-dd&#125;.%i.log<span class="tag">&lt;/<span class="name">fileNamePattern</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">timeBasedFileNamingAndTriggeringPolicy</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">maxFileSize</span>&gt;</span>100MB<span class="tag">&lt;/<span class="name">maxFileSize</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">timeBasedFileNamingAndTriggeringPolicy</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--日志文件保留天数--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">maxHistory</span>&gt;</span>15<span class="tag">&lt;/<span class="name">maxHistory</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">rollingPolicy</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 此日志文件只记录info级别的 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.classic.filter.LevelFilter&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">level</span>&gt;</span>INFO<span class="tag">&lt;/<span class="name">level</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">onMatch</span>&gt;</span>ACCEPT<span class="tag">&lt;/<span class="name">onMatch</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">onMismatch</span>&gt;</span>DENY<span class="tag">&lt;/<span class="name">onMismatch</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 时间滚动输出 level为 WARN 日志 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;WARN_FILE&quot;</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 正在记录的日志文件的路径及文件名 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">file</span>&gt;</span>$&#123;log.path&#125;/log_warn.log<span class="tag">&lt;/<span class="name">file</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--日志文件输出格式--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>$&#123;LOG_PATTERN&#125;<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">charset</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">charset</span>&gt;</span> <span class="comment">&lt;!-- 此处设置字符集 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 日志记录器的滚动策略，按日期，按大小记录 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rollingPolicy</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">fileNamePattern</span>&gt;</span>$&#123;log.path&#125;/warn/log-warn-%d&#123;yyyy-MM-dd&#125;.%i.log<span class="tag">&lt;/<span class="name">fileNamePattern</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 每个日志文件最大100MB --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">timeBasedFileNamingAndTriggeringPolicy</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">maxFileSize</span>&gt;</span>100MB<span class="tag">&lt;/<span class="name">maxFileSize</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">timeBasedFileNamingAndTriggeringPolicy</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--日志文件保留天数--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">maxHistory</span>&gt;</span>15<span class="tag">&lt;/<span class="name">maxHistory</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">rollingPolicy</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 此日志文件只记录warn级别的 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.classic.filter.LevelFilter&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">level</span>&gt;</span>WARN<span class="tag">&lt;/<span class="name">level</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">onMatch</span>&gt;</span>ACCEPT<span class="tag">&lt;/<span class="name">onMatch</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">onMismatch</span>&gt;</span>DENY<span class="tag">&lt;/<span class="name">onMismatch</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 时间滚动输出 level为 ERROR 日志 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;ERROR_FILE&quot;</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 正在记录的日志文件的路径及文件名 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">file</span>&gt;</span>$&#123;log.path&#125;/log_error.log<span class="tag">&lt;/<span class="name">file</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--日志文件输出格式--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>$&#123;LOG_PATTERN&#125;<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">charset</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">charset</span>&gt;</span> <span class="comment">&lt;!-- 此处设置字符集 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 日志记录器的滚动策略，按日期，按大小记录 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rollingPolicy</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">fileNamePattern</span>&gt;</span>$&#123;log.path&#125;/error/log-error-%d&#123;yyyy-MM-dd&#125;.%i.log<span class="tag">&lt;/<span class="name">fileNamePattern</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">timeBasedFileNamingAndTriggeringPolicy</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">maxFileSize</span>&gt;</span>100MB<span class="tag">&lt;/<span class="name">maxFileSize</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">timeBasedFileNamingAndTriggeringPolicy</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--日志文件保留天数--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">maxHistory</span>&gt;</span>15<span class="tag">&lt;/<span class="name">maxHistory</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 日志量最大 10 GB --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">totalSizeCap</span>&gt;</span>10GB<span class="tag">&lt;/<span class="name">totalSizeCap</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">rollingPolicy</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 此日志文件只记录ERROR级别的 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.classic.filter.LevelFilter&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">level</span>&gt;</span>ERROR<span class="tag">&lt;/<span class="name">level</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">onMatch</span>&gt;</span>ACCEPT<span class="tag">&lt;/<span class="name">onMatch</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">onMismatch</span>&gt;</span>DENY<span class="tag">&lt;/<span class="name">onMismatch</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 对于类路径以 com.example.logback 开头的Logger,输出级别设置为warn,并且只输出到控制台 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 这个logger没有指定appender，它会继承root节点中定义的那些appender --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- &lt;logger name=&quot;com.example.logback&quot; level=&quot;warn&quot;/&gt; --&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--通过 LoggerFactory.getLogger(&quot;myLog&quot;) 可以获取到这个logger--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--由于这个logger自动继承了root的appender，root中已经有stdout的appender了，自己这边又引入了stdout的appender--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--如果没有设置 additivity=&quot;false&quot; ,就会导致一条日志在控制台输出两次的情况--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--additivity表示要不要使用rootLogger配置的appender进行输出--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">&quot;myLog&quot;</span> <span class="attr">level</span>=<span class="string">&quot;INFO&quot;</span> <span class="attr">additivity</span>=<span class="string">&quot;false&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;CONSOLE&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">logger</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 日志输出级别及方式 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">&quot;DEBUG&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;CONSOLE&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;DEBUG_FILE&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;INFO_FILE&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;WARN_FILE&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;ERROR_FILE&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="3、访问"><a href="#3、访问" class="headerlink" title="3、访问"></a>3、访问</h3><p>访问项目链接，得到日志打印结果</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[order-service,95aa725089b757f8,f4ee41a6dcf08717]</span><br></pre></td></tr></table></figure>

<p>通过打印信息可以得知，整个链路的 traceId 为：95aa725089b757f8，spanId 为：e494e064842ce4e8 和 f4ee41a6dcf08717。</p>
<h2 id="六、使用-Zipkin-进行链路跟踪"><a href="#六、使用-Zipkin-进行链路跟踪" class="headerlink" title="六、使用 Zipkin 进行链路跟踪"></a>六、使用 Zipkin 进行链路跟踪</h2><h3 id="1、什么是Zipkin"><a href="#1、什么是Zipkin" class="headerlink" title="1、什么是Zipkin"></a>1、什么是Zipkin</h3><p>​		Zipkin是Twitter公司开发贡献的一款开源的分布式实时数据追踪系统（Distributed Tracking System），基于Google Dapper的论文设计而来，其主要功能是聚集各个异构系统的实时监控数据。</p>
<p>​		它可以收集各个服务器上请求链路的跟踪数据，并通过Rest API接口来辅助我们查询跟踪数据，实现对分布式系统的实时监控，及时发现系统中出现的延迟升高问题并找出系统性能瓶颈的根源。除了面向开发的API接口之外，它还提供了方便的UI组件，每个服务向Zipkin报告计时数据，Zipkin会根据调用关系生成依赖关系图，帮助我们直观的搜索跟踪信息和分析请求链路明细。Zipkin提供了可插拔数据存储方式：In-Memory、MySql、Cassandra以及Elasticsearch。</p>
<p>分布式跟踪系统还有其他比较成熟的实现，例如：Naver 的 PinPoint、Apache 的 HTrace、阿里的鹰眼 Tracing、京东的 Hydra、新浪的 Watchman，美团点评的 CAT，Apache 的 SkyWalking 等。</p>
<p><img src="/images/Sleuth+Zipkin%E9%93%BE%E8%B7%AF%E8%BF%BD%E8%B8%AA/12.webp" alt="Zipkin"></p>
<h3 id="2、工作原理"><a href="#2、工作原理" class="headerlink" title="2、工作原理"></a>2、工作原理</h3><p><img src="/images/Sleuth+Zipkin%E9%93%BE%E8%B7%AF%E8%BF%BD%E8%B8%AA/13.webp" alt="工作原理"></p>
<p>共有四个组件构成Zipkin：</p>
<ul>
<li>Collector：收集器组件，处理从外部系统发送过来的跟踪信息，将这些信息转换为Zipkin内部处理的Span格式，以支持后续的存储、分析、展示等功能。</li>
<li>Storage：存储组件，处理收集器接收到的跟踪信息，默认将信息存储在内存中，可以修改存储策略使用其他存储组件，支持MySQL，Elasticsearch等。</li>
<li>Web UI：UI组件，基于API组件实现的上层应用，提供Web页面，用来展示Zipkin中的调用链和系统依赖关系等。</li>
<li>RESTful API：API组件，为Web界面提供查询存储中数据的接口。</li>
</ul>
<p>Zipkin分为两端，一个Zipkin服务端，一个是Zipkin客户端，客户端也就是微服务的应用，客户端回配置服务端的URL地址，一旦发生服务间的调用时，会被配置在微服务里的Sleuth的监听器监听，并生成相应的Trace和Span信息发送给服务端。发送的方式有两种，一种是消息总线的方式如RabbitMQ发送，还有一种是HTTP报文的方式发送。</p>
<h3 id="3、服务端部署"><a href="#3、服务端部署" class="headerlink" title="3、服务端部署"></a>3、服务端部署</h3><p>服务端是一个独立的可执行的jar包，官方下载地址：<a target="_blank" rel="noopener" href="https://search.maven.org/remote_content?g=io.zipkin&amp;a=zipkin-server&amp;v=LATEST&amp;c=exec%EF%BC%8C">https://search.maven.org/remote_content?g=io.zipkin&amp;a=zipkin-server&amp;v=LATEST&amp;c=exec，</a></p>
<p>使用java -jar zipkin.jar命令启动，端口默认为9411。</p>
<p>我们下载的jar包为： zipkin-server-2.23.18-exec.jar，启动命令如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar zipkin-server-<span class="number">2.20</span><span class="number">.1</span>-exec.jar</span><br></pre></td></tr></table></figure>

<p>访问：<a target="_blank" rel="noopener" href="https://link.segmentfault.com/?enc=sNLi3f42oHgjTRHVdyZygA==.1A8iamJraEKLOUvTRuKMLir9F/vf+vS1f5BdjKsJ3Dg=">http://localhost:9411/</a> 结果如下：</p>
<p><img src="/images/Sleuth+Zipkin%E9%93%BE%E8%B7%AF%E8%BF%BD%E8%B8%AA/14.webp" alt="工作原理"></p>
<h3 id="4、客户端部署"><a href="#4、客户端部署" class="headerlink" title="4、客户端部署"></a>4、客户端部署</h3><h4 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h4><p>在需要进行链路追踪的项目中（服务网关、商品服务、订单服务）添加 spring-cloud-starter-zipkin 依赖。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- spring cloud zipkin 依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-zipkin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h4><p>在需要进行链路追踪的项目中（服务网关、商品服务、订单服务）配置Zipkin服务端地址及数据传输方式。默认即如下配置。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  zipkin:</span><br><span class="line">    base-url: http://localhost:9411/ # 服务端地址</span><br><span class="line">    sender:</span><br><span class="line">      type: web                      # 数据传输方式，web 表示以 HTTP 报文的形式向服务端发送数据</span><br><span class="line">  sleuth:</span><br><span class="line">    sampler:</span><br><span class="line">      probability: 1.0               # 收集数据百分比，默认 0.1（10%）</span><br></pre></td></tr></table></figure>

<h4 id="访问"><a href="#访问" class="headerlink" title="访问"></a>访问</h4><p>访问：<a target="_blank" rel="noopener" href="https://link.segmentfault.com/?enc=NiINZULRaEEEPCpSpKh9LA==.WveUv7aWuQTmc+ukxCGhRtnpfHsyV/zaOTVljc/AWHo=">http://localhost:9411/</a> 根据时间过滤点击搜索结果如下：</p>
<p><img src="/images/Sleuth+Zipkin%E9%93%BE%E8%B7%AF%E8%BF%BD%E8%B8%AA/15.webp" alt="页面"></p>
<p>点击对应的追踪信息可查看请求链路详细。</p>
<p><img src="/images/Sleuth+Zipkin%E9%93%BE%E8%B7%AF%E8%BF%BD%E8%B8%AA/16.webp" alt="链路详情"></p>
<p>通过依赖可以查看链路中服务的依赖关系。</p>
<p><img src="/images/Sleuth+Zipkin%E9%93%BE%E8%B7%AF%E8%BF%BD%E8%B8%AA/17.webp" alt="依赖"></p>
<p>Zipkin Server默认存储追踪数据至内存中（容易丢失数据，一旦服务停止，数据会消失）。Zipkin支持修改存储策略是用其他存储组件，支持MySQL，Elasticsearch等。</p>
<h3 id="5、指定mysql启动"><a href="#5、指定mysql启动" class="headerlink" title="5、指定mysql启动"></a>5、指定mysql启动</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">java -jar zipkin.jar </span><br><span class="line"></span><br><span class="line">--zipkin.storage.type=mysql</span><br><span class="line"></span><br><span class="line">--zipkin.storage.mysql.host=127.0.0.1</span><br><span class="line"></span><br><span class="line">--zipkin.storage.mysql.port=3306</span><br><span class="line"></span><br><span class="line">--zipkin.storage.mysql.username=root</span><br><span class="line"></span><br><span class="line">--zipkin.storage.mysql.password=123456</span><br><span class="line"></span><br><span class="line">--zipkin.storage.mysql.db=zipkin</span><br></pre></td></tr></table></figure>



<h4 id="（1）创建zipkin数据库"><a href="#（1）创建zipkin数据库" class="headerlink" title="（1）创建zipkin数据库"></a>（1）创建zipkin数据库</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE IF NOT EXISTS zipkin_spans (</span><br><span class="line">  `trace_id_high` BIGINT NOT NULL DEFAULT 0 COMMENT &#x27;If non zero, this means the trace uses 128 bit traceIds instead of 64 bit&#x27;,</span><br><span class="line">  `trace_id` BIGINT NOT NULL,</span><br><span class="line">  `id` BIGINT NOT NULL,</span><br><span class="line">  `name` VARCHAR(255) NOT NULL,</span><br><span class="line">  `remote_service_name` VARCHAR(255),</span><br><span class="line">  `parent_id` BIGINT,</span><br><span class="line">  `debug` BIT(1),</span><br><span class="line">  `start_ts` BIGINT COMMENT &#x27;Span.timestamp(): epoch micros used for endTs query and to implement TTL&#x27;,</span><br><span class="line">  `duration` BIGINT COMMENT &#x27;Span.duration(): micros used for minDuration and maxDuration query&#x27;,</span><br><span class="line">  PRIMARY KEY (`trace_id_high`, `trace_id`, `id`)</span><br><span class="line">) ENGINE=InnoDB ROW_FORMAT=COMPRESSED CHARACTER SET=utf8 COLLATE utf8_general_ci;</span><br><span class="line"></span><br><span class="line">ALTER TABLE zipkin_spans ADD INDEX(`trace_id_high`, `trace_id`) COMMENT &#x27;for getTracesByIds&#x27;;</span><br><span class="line">ALTER TABLE zipkin_spans ADD INDEX(`name`) COMMENT &#x27;for getTraces and getSpanNames&#x27;;</span><br><span class="line">ALTER TABLE zipkin_spans ADD INDEX(`remote_service_name`) COMMENT &#x27;for getTraces and getRemoteServiceNames&#x27;;</span><br><span class="line">ALTER TABLE zipkin_spans ADD INDEX(`start_ts`) COMMENT &#x27;for getTraces ordering and range&#x27;;</span><br><span class="line"></span><br><span class="line">CREATE TABLE IF NOT EXISTS zipkin_annotations (</span><br><span class="line">  `trace_id_high` BIGINT NOT NULL DEFAULT 0 COMMENT &#x27;If non zero, this means the trace uses 128 bit traceIds instead of 64 bit&#x27;,</span><br><span class="line">  `trace_id` BIGINT NOT NULL COMMENT &#x27;coincides with zipkin_spans.trace_id&#x27;,</span><br><span class="line">  `span_id` BIGINT NOT NULL COMMENT &#x27;coincides with zipkin_spans.id&#x27;,</span><br><span class="line">  `a_key` VARCHAR(255) NOT NULL COMMENT &#x27;BinaryAnnotation.key or Annotation.value if type == -1&#x27;,</span><br><span class="line">  `a_value` BLOB COMMENT &#x27;BinaryAnnotation.value(), which must be smaller than 64KB&#x27;,</span><br><span class="line">  `a_type` INT NOT NULL COMMENT &#x27;BinaryAnnotation.type() or -1 if Annotation&#x27;,</span><br><span class="line">  `a_timestamp` BIGINT COMMENT &#x27;Used to implement TTL; Annotation.timestamp or zipkin_spans.timestamp&#x27;,</span><br><span class="line">  `endpoint_ipv4` INT COMMENT &#x27;Null when Binary/Annotation.endpoint is null&#x27;,</span><br><span class="line">  `endpoint_ipv6` BINARY(16) COMMENT &#x27;Null when Binary/Annotation.endpoint is null, or no IPv6 address&#x27;,</span><br><span class="line">  `endpoint_port` SMALLINT COMMENT &#x27;Null when Binary/Annotation.endpoint is null&#x27;,</span><br><span class="line">  `endpoint_service_name` VARCHAR(255) COMMENT &#x27;Null when Binary/Annotation.endpoint is null&#x27;</span><br><span class="line">) ENGINE=InnoDB ROW_FORMAT=COMPRESSED CHARACTER SET=utf8 COLLATE utf8_general_ci;</span><br><span class="line"></span><br><span class="line">ALTER TABLE zipkin_annotations ADD UNIQUE KEY(`trace_id_high`, `trace_id`, `span_id`, `a_key`, `a_timestamp`) COMMENT &#x27;Ignore insert on duplicate&#x27;;</span><br><span class="line">ALTER TABLE zipkin_annotations ADD INDEX(`trace_id_high`, `trace_id`, `span_id`) COMMENT &#x27;for joining with zipkin_spans&#x27;;</span><br><span class="line">ALTER TABLE zipkin_annotations ADD INDEX(`trace_id_high`, `trace_id`) COMMENT &#x27;for getTraces/ByIds&#x27;;</span><br><span class="line">ALTER TABLE zipkin_annotations ADD INDEX(`endpoint_service_name`) COMMENT &#x27;for getTraces and getServiceNames&#x27;;</span><br><span class="line">ALTER TABLE zipkin_annotations ADD INDEX(`a_type`) COMMENT &#x27;for getTraces and autocomplete values&#x27;;</span><br><span class="line">ALTER TABLE zipkin_annotations ADD INDEX(`a_key`) COMMENT &#x27;for getTraces and autocomplete values&#x27;;</span><br><span class="line">ALTER TABLE zipkin_annotations ADD INDEX(`trace_id`, `span_id`, `a_key`) COMMENT &#x27;for dependencies job&#x27;;</span><br><span class="line"></span><br><span class="line">CREATE TABLE IF NOT EXISTS zipkin_dependencies (</span><br><span class="line">  `day` DATE NOT NULL,</span><br><span class="line">  `parent` VARCHAR(255) NOT NULL,</span><br><span class="line">  `child` VARCHAR(255) NOT NULL,</span><br><span class="line">  `call_count` BIGINT,</span><br><span class="line">  `error_count` BIGINT,</span><br><span class="line">  PRIMARY KEY (`day`, `parent`, `child`)</span><br><span class="line">) ENGINE=InnoDB ROW_FORMAT=COMPRESSED CHARACTER SET=utf8 COLLATE utf8_general_ci;</span><br></pre></td></tr></table></figure>

 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Sleuth/" rel="tag">Sleuth</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Zipkin/" rel="tag">Zipkin</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%93%BE%E8%B7%AF%E8%BF%BD%E8%B8%AA/" rel="tag">链路追踪</a></li></ul>

    </footer>
  </div>

    
 
    
</article>

    
  </article>
  

  
  <nav class="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/">下一页</a>
  </nav>
  
</section>
</div>

      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2015-2022
        <i class="ri-heart-fill heart_icon"></i> liang sm
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>访问人数:<span id="busuanzi_value_site_uv"></span></span>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>浏览次数:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="卡西莫多的小站"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/photos">照片</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/friends">友链</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/about">关于我</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="搜索">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>谢谢老板~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->

<script src="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.staticfile.org/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/default-skin/default-skin.min.css">
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.js"></script>
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->
 
<script src="/js/busuanzi-2.3.pure.min.js"></script>
 
<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->

<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.staticfile.org/clipboard.js/2.0.10/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->
 
<script src="/js/dz.js"></script>
 
<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    <div id="music">
    
    
    
    <iframe frameborder="no" border="1" marginwidth="0" marginheight="0" width="200" height="52"
        src="//music.163.com/outchain/player?type=2&id=28457938&auto=1&height=32"></iframe>
</div>

<style>
    #music {
        position: fixed;
        right: 15px;
        bottom: 0;
        z-index: 998;
    }
</style>
    
    

  </div>
</body>

</html>